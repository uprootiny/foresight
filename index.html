<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Foresight â€” Time Series Forecasting Compendium</title>
<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body style="margin:0;background:#08080c">
<div id="root"></div>
<script type="text/babel">
const { useState, useEffect, useCallback, useMemo, useRef } = React;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DESIGN TOKENS â€” Chromatic Lattice
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const T = {
  bg0:"#08080c", bg1:"#0f0f18", bg2:"#161624", bg3:"#1e1e30", bg4:"#28283c",
  border0:"#1e1e2e", border1:"#2c2c40", border2:"#3a3a50",
  text0:"#eae9f0", text1:"#c4c3ce", text2:"#9a99aa", text3:"#8a8999",
  // Semantic colors
  accent:"#4a8fe7", accentDim:"rgba(74,143,231,0.12)",
  positive:"#3dbe78", positiveDim:"rgba(61,190,120,0.12)",
  warning:"#e0c040", warningDim:"rgba(224,192,64,0.10)",
  danger:"#e84a5a", dangerDim:"rgba(232,74,90,0.12)",
  info:"#9b6dff", infoDim:"rgba(155,109,255,0.12)",
  highlight:"#e8762b", highlightDim:"rgba(232,118,43,0.12)",
  // Legacy aliases
  blue:"#4a8fe7", blueDim:"rgba(74,143,231,0.12)", blueMid:"rgba(74,143,231,0.35)",
  red:"#e84a5a", redDim:"rgba(232,74,90,0.12)", redMid:"rgba(232,74,90,0.35)",
  purple:"#9b6dff", purpleDim:"rgba(155,109,255,0.12)", purpleMid:"rgba(155,109,255,0.35)",
  green:"#3dbe78", greenDim:"rgba(61,190,120,0.12)", greenMid:"rgba(61,190,120,0.35)",
  yellow:"#e0c040", yellowDim:"rgba(224,192,64,0.10)", yellowMid:"rgba(224,192,64,0.30)",
  orange:"#e8762b", orangeDim:"rgba(232,118,43,0.12)", orangeMid:"rgba(232,118,43,0.35)",
  teal:"#2bbfa0", tealDim:"rgba(43,191,160,0.12)", tealMid:"rgba(43,191,160,0.35)",
  silver:"#b0b3c0", silverDim:"rgba(176,179,192,0.10)", silverMid:"rgba(176,179,192,0.28)",
  crimson:"#dc2640", crimsonDim:"rgba(220,38,64,0.12)", crimsonMid:"rgba(220,38,64,0.35)",
  rSm:4, rMd:6, rLg:10, rPill:100,
  mono:"ui-monospace, 'SF Mono', 'Cascadia Code', monospace",
  display:"Georgia, 'Times New Roman', serif",
  body:"system-ui, -apple-system, sans-serif",
  // Type scale
  fs:{ xs:"0.65rem", sm:"0.75rem", md:"0.85rem", lg:"1.05rem", xl:"1.35rem", xxl:"1.70rem" },
  // Spacing scale
  sp:{ xs:4, sm:8, md:12, lg:16, xl:24, xxl:32 },
};

const LEVEL_COLOR = {
  verified:{ base:T.green, dim:T.greenDim, mid:T.greenMid, label:"VER" },
  asserted:{ base:T.orange, dim:T.orangeDim, mid:T.orangeMid, label:"ASR" },
  assumed:{ base:T.yellow, dim:T.yellowDim, mid:T.yellowMid, label:"ASM" },
  inferred:{ base:T.blue, dim:T.blueDim, mid:T.blueMid, label:"INF" },
  extrapolated:{ base:T.crimson, dim:T.crimsonDim, mid:T.crimsonMid, label:"EXT" },
  aspirational:{ base:T.silver, dim:T.silverDim, mid:T.silverMid, label:"ASP" },
  invariant:{ base:T.purple, dim:T.purpleDim, mid:T.purpleMid, label:"INV" },
  used:{ base:T.teal, dim:T.tealDim, mid:T.tealMid, label:"USE" },
};
const lc = l => LEVEL_COLOR[l] || LEVEL_COLOR.used;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DATA â€” FAMILIES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const FAMILIES = [
  { id:"baseline", name:"Baseline", color:T.silver, description:"Simple reference methods that establish performance floors" },
  { id:"statistical", name:"Statistical", color:T.blue, description:"Classical parametric models grounded in probability theory" },
  { id:"statespace", name:"State-Space", color:T.purple, description:"Hidden state models with observation equations" },
  { id:"ml", name:"Machine Learning", color:T.orange, description:"Non-parametric supervised learners on engineered features" },
  { id:"deep", name:"Deep Learning", color:T.crimson, description:"Neural sequence models learning representations end-to-end" },
  { id:"probabilistic", name:"Probabilistic", color:T.teal, description:"Uncertainty-native methods producing full distributions" },
  { id:"decomposition", name:"Decomposition", color:T.green, description:"Signal separation into trend, seasonal, and residual" },
  { id:"pointprocess", name:"Point Process", color:T.yellow, description:"Event arrival and intensity models" },
  { id:"ensemble", name:"Ensemble/Meta", color:T.red, description:"Model combination and meta-learning strategies" },
];

const familyColor = fid => (FAMILIES.find(f => f.id === fid) || {}).color || T.text2;
const familyName = fid => (FAMILIES.find(f => f.id === fid) || {}).name || fid;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DATA â€” TECHNIQUES (35)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const TECHNIQUES = [
  // Baseline (4)
  { id:"naive", name:"Naive", family:"baseline", desc:"Last observed value repeated as forecast",
    complexity:1, inputTypes:["univariate"], outputTypes:["point_forecast"],
    assumptions:[], ownedResponsibilities:["level"], timeScales:["daily","weekly","monthly"],
    leakageRisk:"low", bestFor:["Benchmarking","Sanity checks"], pipelineRole:"model" },
  { id:"seasonal_naive", name:"Seasonal Naive", family:"baseline", desc:"Value from same season last cycle as forecast",
    complexity:1, inputTypes:["univariate"], outputTypes:["point_forecast"],
    assumptions:["seasonality_present"], ownedResponsibilities:["seasonality"], timeScales:["daily","weekly","monthly","quarterly"],
    leakageRisk:"low", bestFor:["Seasonal benchmarks","Retail"], pipelineRole:"model" },
  { id:"ewma", name:"EWMA", family:"baseline", desc:"Exponentially weighted moving average â€” recent data weighted more",
    complexity:1, inputTypes:["univariate"], outputTypes:["point_forecast","features"],
    assumptions:[], ownedResponsibilities:["level","smoothing"], timeScales:["intraday","daily","weekly"],
    leakageRisk:"low", bestFor:["Smoothing","Online tracking"], pipelineRole:"model" },
  { id:"moving_avg", name:"Moving Average", family:"baseline", desc:"Simple rolling window mean",
    complexity:1, inputTypes:["univariate"], outputTypes:["point_forecast","features"],
    assumptions:[], ownedResponsibilities:["smoothing"], timeScales:["intraday","daily","weekly","monthly"],
    leakageRisk:"low", bestFor:["Noise reduction","Trend estimation"], pipelineRole:"transform" },

  // Statistical (6)
  { id:"arima", name:"ARIMA", family:"statistical", desc:"Autoregressive integrated moving average for non-seasonal series",
    complexity:3, inputTypes:["univariate"], outputTypes:["point_forecast","intervals"],
    assumptions:["stationarity_after_diff","linearity","normal_residuals"], ownedResponsibilities:["trend","autocorrelation"],
    timeScales:["daily","weekly","monthly"], leakageRisk:"medium", bestFor:["Trended series","Macro indicators"], pipelineRole:"model" },
  { id:"sarima", name:"SARIMA", family:"statistical", desc:"Seasonal ARIMA adding periodic autoregressive and MA terms",
    complexity:3, inputTypes:["univariate"], outputTypes:["point_forecast","intervals"],
    assumptions:["stationarity_after_diff","linearity","seasonal_stationarity"], ownedResponsibilities:["trend","seasonality","autocorrelation"],
    timeScales:["daily","weekly","monthly","quarterly"], leakageRisk:"medium", bestFor:["Seasonal macro","Energy demand"], pipelineRole:"model" },
  { id:"ets", name:"ETS / Holt-Winters", family:"statistical", desc:"Error-Trend-Seasonality exponential smoothing framework",
    complexity:2, inputTypes:["univariate"], outputTypes:["point_forecast","intervals"],
    assumptions:["smooth_trend","regular_seasonality"], ownedResponsibilities:["trend","seasonality","error"],
    timeScales:["daily","weekly","monthly","quarterly"], leakageRisk:"low", bestFor:["Retail sales","Inventory planning"], pipelineRole:"model" },
  { id:"var", name:"VAR", family:"statistical", desc:"Vector autoregression for multivariate time series",
    complexity:3, inputTypes:["multivariate"], outputTypes:["point_forecast","intervals"],
    assumptions:["stationarity","linearity","no_cointegration"], ownedResponsibilities:["cross_correlation","dynamics"],
    timeScales:["daily","weekly","monthly"], leakageRisk:"medium", bestFor:["Macro systems","Cross-asset"], pipelineRole:"model" },
  { id:"garch", name:"GARCH", family:"statistical", desc:"Generalized autoregressive conditional heteroskedasticity for volatility",
    complexity:3, inputTypes:["univariate","residuals"], outputTypes:["intervals","features"],
    assumptions:["stationarity","fat_tails"], ownedResponsibilities:["volatility"],
    timeScales:["intraday","daily","weekly"], leakageRisk:"low", bestFor:["Volatility forecasting","Risk management"], pipelineRole:"model" },
  { id:"theta", name:"Theta Method", family:"statistical", desc:"Decompose into theta-lines and extrapolate",
    complexity:2, inputTypes:["univariate"], outputTypes:["point_forecast"],
    assumptions:["smooth_trend"], ownedResponsibilities:["trend"],
    timeScales:["monthly","quarterly"], leakageRisk:"low", bestFor:["M-competition","Simple trend"], pipelineRole:"model" },

  // State-Space (3)
  { id:"kalman", name:"Kalman Filter", family:"statespace", desc:"Optimal recursive state estimator under Gaussian linear assumptions",
    complexity:4, inputTypes:["univariate","multivariate"], outputTypes:["point_forecast","intervals","features"],
    assumptions:["linearity","gaussian_noise"], ownedResponsibilities:["state_estimation","filtering"],
    timeScales:["tick","intraday","daily"], leakageRisk:"low", bestFor:["Real-time tracking","Sensor fusion"], pipelineRole:"model" },
  { id:"structural_ts", name:"Structural Time Series", family:"statespace", desc:"State-space decomposition into trend, seasonal, cycle components",
    complexity:4, inputTypes:["univariate"], outputTypes:["point_forecast","intervals","decomposed"],
    assumptions:["gaussian_noise","linear_components"], ownedResponsibilities:["trend","seasonality","cycle"],
    timeScales:["daily","weekly","monthly","quarterly"], leakageRisk:"low", bestFor:["Component analysis","Causal inference"], pipelineRole:"model" },
  { id:"hmm", name:"HMM", family:"statespace", desc:"Hidden Markov model for discrete regime detection",
    complexity:4, inputTypes:["univariate","multivariate","features"], outputTypes:["regime_labels","probabilities"],
    assumptions:["markov_property","finite_states"], ownedResponsibilities:["regime"],
    timeScales:["intraday","daily","weekly"], leakageRisk:"medium", bestFor:["Regime detection","Market states"], pipelineRole:"feature" },

  // ML (4)
  { id:"gbt", name:"Gradient Boosted Trees", family:"ml", desc:"Ensemble of sequential decision trees optimizing a loss function",
    complexity:3, inputTypes:["features"], outputTypes:["point_forecast","probabilities"],
    assumptions:["feature_engineering_done"], ownedResponsibilities:[],
    timeScales:["intraday","daily","weekly","monthly"], leakageRisk:"high", bestFor:["Tabular features","Non-linear patterns"], pipelineRole:"model" },
  { id:"rf", name:"Random Forest", family:"ml", desc:"Bagged ensemble of decorrelated decision trees",
    complexity:2, inputTypes:["features"], outputTypes:["point_forecast","probabilities"],
    assumptions:["feature_engineering_done"], ownedResponsibilities:[],
    timeScales:["intraday","daily","weekly","monthly"], leakageRisk:"high", bestFor:["Feature importance","Robust prediction"], pipelineRole:"model" },
  { id:"svr", name:"SVR", family:"ml", desc:"Support vector regression with kernel-based non-linearity",
    complexity:3, inputTypes:["features"], outputTypes:["point_forecast"],
    assumptions:["feature_engineering_done","scaled_inputs"], ownedResponsibilities:[],
    timeScales:["daily","weekly","monthly"], leakageRisk:"medium", bestFor:["Small datasets","Non-linear regression"], pipelineRole:"model" },
  { id:"regime_logistic", name:"Regime-Gated Logistic", family:"ml", desc:"Logistic regression gated by upstream regime labels",
    complexity:2, inputTypes:["features","regime_labels"], outputTypes:["probabilities"],
    assumptions:["regime_labels_available"], ownedResponsibilities:["regime_conditioning"],
    timeScales:["intraday","daily","weekly"], leakageRisk:"medium", bestFor:["Regime-aware signals","Interpretable ML"], pipelineRole:"model" },

  // Deep Learning (6)
  { id:"lstm", name:"LSTM", family:"deep", desc:"Long short-term memory recurrent network for sequence modeling",
    complexity:4, inputTypes:["univariate","multivariate"], outputTypes:["point_forecast","features"],
    assumptions:["sufficient_data","gpu_available"], ownedResponsibilities:["sequence_memory"],
    timeScales:["intraday","daily","weekly"], leakageRisk:"high", bestFor:["Long sequences","Complex dynamics"], pipelineRole:"model" },
  { id:"gru", name:"GRU", family:"deep", desc:"Gated recurrent unit â€” lighter alternative to LSTM",
    complexity:3, inputTypes:["univariate","multivariate"], outputTypes:["point_forecast","features"],
    assumptions:["sufficient_data"], ownedResponsibilities:["sequence_memory"],
    timeScales:["intraday","daily","weekly"], leakageRisk:"high", bestFor:["Medium sequences","Faster training"], pipelineRole:"model" },
  { id:"transformer", name:"Transformer", family:"deep", desc:"Self-attention mechanism for parallel sequence processing",
    complexity:5, inputTypes:["univariate","multivariate"], outputTypes:["point_forecast","features"],
    assumptions:["large_data","gpu_available"], ownedResponsibilities:["attention","representation"],
    timeScales:["intraday","daily","weekly","monthly"], leakageRisk:"high", bestFor:["Multi-horizon","Large datasets"], pipelineRole:"model" },
  { id:"nbeats", name:"N-BEATS", family:"deep", desc:"Neural basis expansion for interpretable time series forecasting",
    complexity:4, inputTypes:["univariate"], outputTypes:["point_forecast","decomposed"],
    assumptions:["sufficient_data"], ownedResponsibilities:["trend","seasonality"],
    timeScales:["daily","weekly","monthly"], leakageRisk:"high", bestFor:["Interpretable DL","Point forecasts"], pipelineRole:"model" },
  { id:"tft", name:"TFT", family:"deep", desc:"Temporal Fusion Transformer with variable selection and multi-horizon output",
    complexity:5, inputTypes:["multivariate"], outputTypes:["point_forecast","intervals"],
    assumptions:["large_data","gpu_available","static_covariates"], ownedResponsibilities:["attention","feature_selection"],
    timeScales:["daily","weekly","monthly"], leakageRisk:"high", bestFor:["Multi-horizon","Mixed covariates"], pipelineRole:"model" },
  { id:"deepar", name:"DeepAR", family:"deep", desc:"Autoregressive RNN producing full predictive distributions",
    complexity:4, inputTypes:["univariate","multivariate"], outputTypes:["distribution"],
    assumptions:["sufficient_data","parametric_likelihood"], ownedResponsibilities:["uncertainty"],
    timeScales:["daily","weekly","monthly"], leakageRisk:"high", bestFor:["Probabilistic forecasts","Inventory"], pipelineRole:"model" },

  // Probabilistic (4)
  { id:"bsts", name:"Bayesian Structural TS", family:"probabilistic", desc:"Bayesian inference over structural time series components",
    complexity:4, inputTypes:["univariate"], outputTypes:["distribution","intervals","decomposed"],
    assumptions:["prior_specification","gaussian_likelihood"], ownedResponsibilities:["trend","seasonality","uncertainty"],
    timeScales:["daily","weekly","monthly","quarterly"], leakageRisk:"low", bestFor:["Causal impact","Uncertainty quantification"], pipelineRole:"model" },
  { id:"gp", name:"Gaussian Process", family:"probabilistic", desc:"Non-parametric Bayesian regression with kernel-defined prior",
    complexity:5, inputTypes:["features"], outputTypes:["distribution","intervals"],
    assumptions:["kernel_choice","small_to_medium_data"], ownedResponsibilities:["uncertainty"],
    timeScales:["daily","weekly","monthly"], leakageRisk:"low", bestFor:["Small data","Uncertainty bounds"], pipelineRole:"model" },
  { id:"quantile_reg", name:"Quantile Regression", family:"probabilistic", desc:"Estimate conditional quantiles for prediction intervals",
    complexity:2, inputTypes:["features"], outputTypes:["intervals"],
    assumptions:["feature_engineering_done"], ownedResponsibilities:["quantile_estimation"],
    timeScales:["daily","weekly","monthly"], leakageRisk:"medium", bestFor:["Interval forecasts","Risk quantiles"], pipelineRole:"calibration" },
  { id:"conformal", name:"Conformal Prediction", family:"probabilistic", desc:"Distribution-free prediction intervals with coverage guarantees",
    complexity:2, inputTypes:["point_forecast","features"], outputTypes:["intervals"],
    assumptions:["exchangeability"], ownedResponsibilities:["coverage"],
    timeScales:["daily","weekly","monthly"], leakageRisk:"low", bestFor:["Coverage guarantees","Model-agnostic intervals"], pipelineRole:"calibration" },

  // Decomposition (3)
  { id:"stl", name:"STL", family:"decomposition", desc:"Seasonal-Trend decomposition using LOESS",
    complexity:2, inputTypes:["univariate"], outputTypes:["decomposed","residuals"],
    assumptions:["additive_or_multiplicative"], ownedResponsibilities:["trend","seasonality"],
    timeScales:["daily","weekly","monthly"], leakageRisk:"low", bestFor:["Preprocessing","Anomaly detection"], pipelineRole:"transform" },
  { id:"x13", name:"X-13 ARIMA-SEATS", family:"decomposition", desc:"Census Bureau seasonal adjustment with calendar effects",
    complexity:3, inputTypes:["univariate"], outputTypes:["decomposed","features"],
    assumptions:["monthly_or_quarterly","calendar_effects"], ownedResponsibilities:["seasonality","calendar"],
    timeScales:["monthly","quarterly"], leakageRisk:"low", bestFor:["Official statistics","Seasonal adjustment"], pipelineRole:"transform" },
  { id:"prophet", name:"Prophet", family:"decomposition", desc:"Additive regression with trend, seasonality, and holiday components",
    complexity:2, inputTypes:["univariate"], outputTypes:["point_forecast","intervals","decomposed"],
    assumptions:["additive_components","known_holidays"], ownedResponsibilities:["trend","seasonality","holidays"],
    timeScales:["daily","weekly","monthly"], leakageRisk:"low", bestFor:["Business forecasting","Quick prototyping"], pipelineRole:"model" },

  // Point Process (2)
  { id:"hawkes", name:"Hawkes Process", family:"pointprocess", desc:"Self-exciting point process where events increase future event probability",
    complexity:4, inputTypes:["events"], outputTypes:["point_forecast","features"],
    assumptions:["self_excitation","stationarity"], ownedResponsibilities:["self_excitation","intensity"],
    timeScales:["tick","intraday","daily"], leakageRisk:"low", bestFor:["Order flow","News cascades"], pipelineRole:"model" },
  { id:"cox", name:"Cox Process", family:"pointprocess", desc:"Doubly stochastic Poisson process with random intensity",
    complexity:5, inputTypes:["events","features"], outputTypes:["point_forecast","distribution"],
    assumptions:["conditional_poisson","intensity_model"], ownedResponsibilities:["intensity"],
    timeScales:["intraday","daily","weekly"], leakageRisk:"medium", bestFor:["Event modeling","Spatial-temporal"], pipelineRole:"model" },

  // Ensemble/Meta (3)
  { id:"late_fusion", name:"Late Fusion", family:"ensemble", desc:"Combine final predictions from multiple models via weighted average",
    complexity:1, inputTypes:["point_forecast"], outputTypes:["point_forecast"],
    assumptions:["diverse_models"], ownedResponsibilities:["combination"],
    timeScales:["intraday","daily","weekly","monthly"], leakageRisk:"medium", bestFor:["Model combination","Variance reduction"], pipelineRole:"decision" },
  { id:"stacking", name:"Stacking", family:"ensemble", desc:"Train meta-learner on base model predictions",
    complexity:3, inputTypes:["point_forecast","features"], outputTypes:["point_forecast"],
    assumptions:["diverse_models","sufficient_data"], ownedResponsibilities:["meta_learning"],
    timeScales:["daily","weekly","monthly"], leakageRisk:"high", bestFor:["Complex ensembles","Competition winning"], pipelineRole:"decision" },
  { id:"model_avg", name:"Model Averaging", family:"ensemble", desc:"Bayesian or frequentist averaging across model space",
    complexity:2, inputTypes:["point_forecast"], outputTypes:["point_forecast","intervals"],
    assumptions:["model_set_defined"], ownedResponsibilities:["combination","model_uncertainty"],
    timeScales:["daily","weekly","monthly"], leakageRisk:"low", bestFor:["Robust forecasts","Uncertainty from model selection"], pipelineRole:"decision" },
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DATA â€” 12 COMPOSABILITY PRINCIPLES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const PRINCIPLES = [
  { id:1, name:"Output-Input Typing", category:"structural",
    description:"Chain techniques only when A's output type is in B's accepted input types. Type mismatches silently corrupt pipelines.",
    rule:"outputTypes(A) âˆ© inputTypes(B) â‰  âˆ…",
    safeExamples:["STL (â†’decomposed) â†’ ARIMA (univariateâœ“)","HMM (â†’regime_labels) â†’ Regime-Gated Logistic (regime_labelsâœ“)"],
    unsafeExamples:["GARCH (â†’intervals) â†’ Random Forest (needs features)","Hawkes (â†’point_forecast) â†’ STL (needs univariate raw)"] },
  { id:2, name:"Single Responsibility", category:"structural",
    description:"Each technique should own exactly one transformation responsibility. Two techniques owning the same responsibility create ambiguous attribution.",
    rule:"ownedResp(A) âˆ© ownedResp(B) = âˆ…",
    safeExamples:["STL (owns trend+seasonal) â†’ GARCH (owns volatility)","HMM (owns regime) â†’ GBT (owns nothing specific)"],
    unsafeExamples:["SARIMA (owns trend+seasonal) â†’ ETS (owns trend+seasonal)","Prophet (owns trend) â†’ N-BEATS (owns trend)"] },
  { id:3, name:"Temporal Ordering", category:"causal",
    description:"Never pass future information to a model expecting only past data. Calibration and decision steps must follow model outputs, not precede them.",
    rule:"pipelineRole ordering: transform â†’ feature â†’ model â†’ calibration â†’ decision",
    safeExamples:["STL (transform) â†’ GBT (model) â†’ Conformal (calibration)","Moving Average (transform) â†’ LSTM (model) â†’ Late Fusion (decision)"],
    unsafeExamples:["Conformal (calibration) â†’ ARIMA (model)","Stacking (decision) â†’ GBT (model)"] },
  { id:4, name:"Scale Alignment", category:"structural",
    description:"Techniques in a pipeline must operate at compatible time scales. Mixing intraday features with monthly models produces nonsensical results.",
    rule:"timeScales(A) âˆ© timeScales(B) â‰  âˆ…",
    safeExamples:["EWMA (intraday/daily) â†’ GBT (intraday/daily)","SARIMA (monthly) â†’ Conformal (monthly)"],
    unsafeExamples:["Hawkes (tick) â†’ Theta (monthly)","Kalman (tick) â†’ X-13 (monthly/quarterly)"] },
  { id:5, name:"Stationarity Handoff", category:"statistical",
    description:"Non-stationary data must be made stationary before models that assume stationarity. Decomposition or differencing should precede such models.",
    rule:"If B assumes stationarity, A must output stationary data",
    safeExamples:["STL residuals â†’ ARIMA (stationary residuals)","Differencing â†’ VAR (stationary multivariate)"],
    unsafeExamples:["Raw trending series â†’ VAR (assumes stationarity)","Non-stationary prices â†’ GARCH (assumes stationarity)"] },
  { id:6, name:"Uncertainty Propagation", category:"statistical",
    description:"Probabilistic outputs should not be collapsed to point estimates mid-pipeline. Doing so discards calibrated uncertainty.",
    rule:"If A outputs distribution/intervals, B should accept them or the collapse should be explicit",
    safeExamples:["DeepAR (â†’distribution) â†’ Conformal (calibration)","BSTS (â†’intervals) â†’ Model Averaging (â†’intervals)"],
    unsafeExamples:["GP (â†’distribution) â†’ mean() â†’ GBT (loses uncertainty)","Quantile Regression (â†’intervals) â†’ point collapse â†’ Late Fusion"] },
  { id:7, name:"Regime Awareness", category:"causal",
    description:"Regime-dependent models must receive regime labels from an upstream detector. Self-detected regimes risk look-ahead bias.",
    rule:"If B requires regime_labels, A must produce them",
    safeExamples:["HMM (â†’regime_labels) â†’ Regime-Gated Logistic","Structural TS (â†’decomposed) â†’ regime classification â†’ GBT"],
    unsafeExamples:["Regime-Gated Logistic without upstream HMM","Manual regime assignment using future knowledge"] },
  { id:8, name:"Evaluation Isolation", category:"evaluation",
    description:"Test-set evaluation must happen outside the pipeline's training window. Any technique that touches the test set during training invalidates the evaluation.",
    rule:"No technique in the pipeline may access test-period data during fitting",
    safeExamples:["Walk-forward validation with expanding window","Nested cross-validation for hyperparameter selection"],
    unsafeExamples:["Scaling features using full dataset statistics","Selecting ARIMA order using AIC on combined train+test"] },
  { id:9, name:"Feature Leakage Prevention", category:"evaluation",
    description:"Engineered features must not encode target information from the evaluation period. Lag features, rolling stats, and lookbacks must respect temporal boundaries.",
    rule:"All features at time t derived only from data at times â‰¤ t",
    safeExamples:["Rolling mean with strict lookback window","Lag features with gap between feature and target"],
    unsafeExamples:["Future returns leaked via incorrect join","Rolling statistics computed on full series including future"] },
  { id:10, name:"Ablation Identifiability", category:"evaluation",
    description:"Every component in a pipeline must be independently removable for ablation testing. If removing one component breaks the pipeline structurally, the design is too coupled.",
    rule:"âˆ€ technique T in pipeline: pipeline \\ {T} still executes (possibly with degraded accuracy)",
    safeExamples:["Removing HMM â†’ Logistic falls back to unconditional","Removing STL â†’ ARIMA receives raw series (valid, less clean)"],
    unsafeExamples:["Removing feature extractor breaks model input dimensions","Tight coupling where calibration requires specific model internals"] },
  { id:11, name:"Complexity Gradient", category:"design",
    description:"Simpler models should precede complex ones in evaluation order. Always establish a baseline before adding complexity â€” the marginal value of complexity must be demonstrated.",
    rule:"Evaluate: baseline â†’ statistical â†’ ML â†’ DL, justify each step",
    safeExamples:["Naive â†’ ARIMA â†’ GBT â†’ LSTM ladder","EWMA baseline before Transformer deployment"],
    unsafeExamples:["Deploying Transformer without comparing to ARIMA","Stacking ensemble without individual model evaluation"] },
  { id:12, name:"Ensemble Independence", category:"design",
    description:"Ensemble members should have diverse error profiles. Combining models with correlated errors provides minimal variance reduction.",
    rule:"Corr(errors(A), errors(B)) should be low across ensemble members",
    safeExamples:["ARIMA + GBT + LSTM (different model families)","Statistical + ML + DL diverse ensemble"],
    unsafeExamples:["GBT + RF + XGBoost (all tree-based, correlated errors)","Three ARIMA variants with different orders"] },
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DATA â€” 22 OPERATORS (6 categories)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const OPERATORS = [
  // Level (4)
  { id:"L_mean", name:"Running Mean", category:"level", description:"Exponentially weighted running mean of the signal", formula:"Î¼_t = Î±Â·x_t + (1-Î±)Â·Î¼_{t-1}" },
  { id:"L_median", name:"Running Median", category:"level", description:"Rolling median over a fixed window for robust level estimation", formula:"med_t = median(x_{t-w}...x_t)" },
  { id:"L_quantile", name:"Quantile Tracker", category:"level", description:"Tracks arbitrary quantile of the streaming distribution", formula:"q_t^Ï„ = q_{t-1}^Ï„ + Î±Â·(ðŸ™[x_t â‰¤ q] - Ï„)" },
  { id:"L_zscore", name:"Z-Score", category:"level", description:"Standardized deviation from running mean in units of running std", formula:"z_t = (x_t - Î¼_t) / Ïƒ_t" },

  // Dynamic (4)
  { id:"D_velocity", name:"Velocity", category:"dynamic", description:"First discrete derivative â€” rate of change per unit time", formula:"v_t = x_t - x_{t-1}" },
  { id:"D_acceleration", name:"Acceleration", category:"dynamic", description:"Second derivative â€” rate of change of velocity", formula:"a_t = v_t - v_{t-1}" },
  { id:"D_momentum", name:"Momentum", category:"dynamic", description:"Exponentially weighted directional persistence", formula:"m_t = Î²Â·m_{t-1} + (1-Î²)Â·v_t" },
  { id:"D_volatility", name:"Volatility", category:"dynamic", description:"Rolling standard deviation capturing dispersion", formula:"Ïƒ_t = sqrt(EMA(v_tÂ², Î±))" },

  // Structure (4)
  { id:"S_autocorr", name:"Autocorrelation", category:"structure", description:"Lagged self-correlation measuring memory structure", formula:"Ï_k = Corr(x_t, x_{t-k})" },
  { id:"S_entropy", name:"Sample Entropy", category:"structure", description:"Regularity/complexity measure â€” low entropy = predictable", formula:"SampEn(m,r) = -ln(A/B)" },
  { id:"S_fractal", name:"Fractal Dimension", category:"structure", description:"Self-similarity measure across scales via box-counting", formula:"D = lim(log N(Îµ) / log(1/Îµ))" },
  { id:"S_cluster", name:"Cluster Membership", category:"structure", description:"Assigns current state to nearest behavioral cluster centroid", formula:"c_t = argmin_k ||s_t - Î¼_k||" },

  // Event (4)
  { id:"E_spike", name:"Spike Detector", category:"event", description:"Flags observations exceeding threshold in z-score space", formula:"spike_t = ðŸ™[|z_t| > Ï„]" },
  { id:"E_regime", name:"Regime Change", category:"event", description:"Detects structural breaks via change-point statistics", formula:"CP_t = max_s CUSUM(x_{s..t})" },
  { id:"E_anomaly", name:"Anomaly Flag", category:"event", description:"Multi-criteria anomaly detection combining level, volatility, and structure", formula:"anom_t = ðŸ™[score_t > Î¸]" },
  { id:"E_catalyst", name:"Catalyst Indicator", category:"event", description:"Binary indicator when a catalytic process fires", formula:"cat_t = ðŸ™[trigger(t)]" },

  // Stability (3)
  { id:"ST_lyapunov", name:"Lyapunov Exponent", category:"stability", description:"Measures rate of divergence of nearby trajectories â€” positive = chaos", formula:"Î» = lim (1/t) Î£ ln|f'(x_i)|" },
  { id:"ST_hurst", name:"Hurst Exponent", category:"stability", description:"Long-range dependence: H>0.5 trending, H<0.5 mean-reverting, H=0.5 random walk", formula:"E[R(n)/S(n)] = CÂ·n^H" },
  { id:"ST_stationarity", name:"Stationarity Test", category:"stability", description:"Augmented Dickey-Fuller test statistic for unit root detection", formula:"ADF = Î”x_t = Î± + Î²t + Î³x_{t-1} + Î£Î´_iÎ”x_{t-i}" },

  // Cross-Stream (3)
  { id:"X_correlation", name:"Cross-Correlation", category:"crossstream", description:"Pairwise Pearson correlation between streams over rolling window", formula:"Ï_{AB} = Cov(A,B) / (Ïƒ_AÂ·Ïƒ_B)" },
  { id:"X_granger", name:"Granger Causality", category:"crossstream", description:"Tests if stream A's history improves prediction of stream B", formula:"F-test: restricted vs unrestricted VAR" },
  { id:"X_coherence", name:"Spectral Coherence", category:"crossstream", description:"Frequency-domain correlation between two streams", formula:"C_{AB}(f) = |S_{AB}(f)|Â² / (S_A(f)Â·S_B(f))" },
];

const OP_CATEGORIES = [
  { id:"level", name:"Level", color:T.blue, desc:"Signal level estimation operators" },
  { id:"dynamic", name:"Dynamic", color:T.orange, desc:"Rate of change and momentum operators" },
  { id:"structure", name:"Structure", color:T.purple, desc:"Memory, complexity, and topology operators" },
  { id:"event", name:"Event", color:T.crimson, desc:"Discrete event detection operators" },
  { id:"stability", name:"Stability", color:T.green, desc:"Convergence and long-range behavior operators" },
  { id:"crossstream", name:"Cross-Stream", color:T.teal, desc:"Inter-stream relationship operators" },
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DATA â€” ARCHETYPES (6)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const ARCHETYPES = [
  { id:"trending", name:"Trending", description:"Persistent directional movement with occasional reversals",
    streams:["GDP growth","Secular stock trends","Population"],
    recommendedChain:["stl","arima","conformal"], antiPatterns:["Applying mean-reversion models","Ignoring structural breaks"] },
  { id:"mean_reverting", name:"Mean-Reverting", description:"Oscillates around a stable level with bounded excursions",
    streams:["Interest rate spreads","Pairs trading residuals","Temperature anomalies"],
    recommendedChain:["ewma","var","quantile_reg"], antiPatterns:["Using trend-following models","Ignoring half-life estimation"] },
  { id:"seasonal", name:"Seasonal", description:"Regular periodic patterns driven by calendar or physical cycles",
    streams:["Retail sales","Energy demand","Agricultural yields"],
    recommendedChain:["stl","sarima","conformal"], antiPatterns:["Ignoring holiday effects","Using non-seasonal models"] },
  { id:"regime_switching", name:"Regime-Switching", description:"Alternates between distinct statistical states",
    streams:["Bull/bear markets","Volatility regimes","Economic expansion/recession"],
    recommendedChain:["hmm","regime_logistic","late_fusion"], antiPatterns:["Assuming single regime","Ignoring transition dynamics"] },
  { id:"event_driven", name:"Event-Driven", description:"Dominated by discrete events with rapid response and decay",
    streams:["Earnings announcements","Policy decisions","Natural disasters"],
    recommendedChain:["hawkes","gbt","model_avg"], antiPatterns:["Smoothing away event spikes","Ignoring event clustering"] },
  { id:"high_freq_noise", name:"High-Frequency Noise", description:"Nearly white noise at observation scale â€” weak signal-to-noise",
    streams:["Tick-level returns","High-frequency sensor noise","Social media sentiment"],
    recommendedChain:["moving_avg","kalman","gp"], antiPatterns:["Overfitting to noise","Deep learning on insufficient signal"] },
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DATA â€” CLR SCHEMA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const CLR_SCHEMA = [
  { name:"ts", type:"int64", desc:"Unix epoch milliseconds â€” snapshot timestamp" },
  { name:"stream_id", type:"string", desc:"Source stream identifier (e.g., 'SPY_OHLCV')" },
  { name:"archetype", type:"enum", desc:"Detected behavioral archetype of the stream" },
  { name:"window", type:"int32", desc:"Lookback window size in observations" },
  { name:"operators", type:"map<str,f64>", desc:"Operator ID â†’ computed value at this snapshot" },
  { name:"regime", type:"string", desc:"Current detected regime label" },
  { name:"regime_conf", type:"float64", desc:"Confidence in regime assignment [0,1]" },
  { name:"flags", type:"string[]", desc:"Active anomaly/event flag identifiers" },
  { name:"hash", type:"bytes32", desc:"Content hash for deduplication and integrity" },
  { name:"meta", type:"map<str,any>", desc:"Optional extensible metadata" },
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DATA â€” TECHNIQUE DETAILS (strengths, weaknesses, connections)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const TECHNIQUE_DETAILS = {
  naive: {
    strengths:["Zero parameters â€” impossible to overfit","O(1) computation, always available","Universal baseline for any frequency"],
    weaknesses:["No trend, seasonality, or volatility capture","No prediction intervals","Equivalent to random walk assumption"],
    synergiesWith:["conformal","late_fusion"],conflictsWith:[],relatedTo:["seasonal_naive","ewma","moving_avg"],relevantOps:["L_mean"] },
  seasonal_naive: {
    strengths:["Captures seasonal patterns with zero tuning","Strong baseline for stable periodicity","Handles multiple seasonal periods"],
    weaknesses:["Assumes perfect periodicity","Cannot adapt to trend shifts","Breaks with evolving seasonality"],
    synergiesWith:["conformal","late_fusion"],conflictsWith:[],relatedTo:["naive","sarima","ets"],relevantOps:["L_mean","S_autocorr"] },
  ewma: {
    strengths:["Single parameter Î±, adaptive to level shifts","Memory-efficient O(1) streaming update","Low latency, suitable for real-time systems"],
    weaknesses:["Cannot model seasonality","Lags during sharp moves","No native prediction intervals"],
    synergiesWith:["garch","gbt","hmm","late_fusion"],conflictsWith:[],relatedTo:["moving_avg","kalman","naive"],relevantOps:["L_mean","D_momentum"] },
  moving_avg: {
    strengths:["Non-parametric smoothing, no distribution assumptions","Effective high-frequency noise removal","Easy to explain and audit"],
    weaknesses:["Lag proportional to window size","No extrapolation capability","Edge effects at series boundaries"],
    synergiesWith:["arima","gbt","garch","var"],conflictsWith:[],relatedTo:["ewma","stl","kalman"],relevantOps:["L_mean","L_median"] },
  arima: {
    strengths:["Solid Box-Jenkins theoretical foundation","Handles non-stationarity via differencing","Native prediction intervals from MLE"],
    weaknesses:["Linearity assumption limits expressiveness","Manual order selection (p,d,q) unless auto","Poor with structural breaks and regime changes"],
    synergiesWith:["stl","garch","conformal","moving_avg"],conflictsWith:["sarima","ets","theta"],relatedTo:["sarima","ets","theta","var"],relevantOps:["S_autocorr","ST_stationarity","D_velocity"] },
  sarima: {
    strengths:["Joint trend + seasonal + autocorrelation modeling","Well-studied inference properties","Works well on monthly/quarterly economic data"],
    weaknesses:["Combinatorial order selection (p,d,q)(P,D,Q)m","Assumes fixed seasonal period","Cannot model regime changes"],
    synergiesWith:["conformal","garch","stl"],conflictsWith:["arima","ets","prophet","nbeats"],relatedTo:["arima","ets","x13","seasonal_naive"],relevantOps:["S_autocorr","ST_stationarity"] },
  ets: {
    strengths:["Automatic model selection via AIC/BIC","Handles multiplicative seasonality","Interpretable error/trend/seasonal components"],
    weaknesses:["Limited to 30 pre-specified state-space forms","Cannot include exogenous regressors","Numerical issues with long seasonal periods"],
    synergiesWith:["garch","conformal"],conflictsWith:["sarima","prophet","structural_ts"],relatedTo:["arima","theta","sarima"],relevantOps:["L_mean","D_momentum"] },
  var: {
    strengths:["Captures cross-variable dynamics jointly","Granger causality testable from coefficients","Impulse response functions for policy analysis"],
    weaknesses:["Curse of dimensionality with many variables","Requires all series to be stationary","Cannot handle non-linear interactions"],
    synergiesWith:["stl","hmm","quantile_reg","moving_avg"],conflictsWith:[],relatedTo:["arima","garch"],relevantOps:["X_correlation","X_granger","ST_stationarity"] },
  garch: {
    strengths:["Purpose-built for volatility clustering","Captures fat tails and leverage effects","Feeds directly into risk metrics (VaR, ES)"],
    weaknesses:["Assumes specific parametric residual distribution","Cannot model mean (trend/seasonality)","Sensitive to outliers during estimation"],
    synergiesWith:["arima","ewma","stl","quantile_reg","moving_avg"],conflictsWith:[],relatedTo:["kalman","var","ewma"],relevantOps:["D_volatility","L_zscore","ST_stationarity"] },
  theta: {
    strengths:["Simple yet surprisingly competitive (M3 competition winner)","Only two theta-lines to extrapolate","Robust to overfitting on short series"],
    weaknesses:["No native seasonality handling","Theoretically equivalent to SES with drift","Limited extensibility"],
    synergiesWith:["conformal"],conflictsWith:["arima"],relatedTo:["arima","ets","ewma"],relevantOps:["L_mean","D_velocity"] },
  kalman: {
    strengths:["Optimal estimator under Gaussian-linear assumptions","Recursive O(n) with constant memory","Handles missing data and irregular timestamps natively"],
    weaknesses:["Requires explicit linear state-space specification","Sensitive to model misspecification","Gaussian assumption limits tail modeling"],
    synergiesWith:["hmm","gbt","conformal"],conflictsWith:[],relatedTo:["structural_ts","ewma"],relevantOps:["L_mean","D_velocity","D_volatility"] },
  structural_ts: {
    strengths:["Interpretable component decomposition via state-space","Handles irregular seasonality and missing data","Bayesian variants provide full uncertainty"],
    weaknesses:["Specification requires domain knowledge","Computationally heavier than ARIMA","Risk of overparameterization"],
    synergiesWith:["garch","conformal","hmm"],conflictsWith:["stl","prophet","bsts"],relatedTo:["bsts","stl","kalman"],relevantOps:["L_mean","S_autocorr"] },
  hmm: {
    strengths:["Discovers latent regime structure from data","Provides soft regime probabilities for downstream use","Handles non-stationarity via regime switching"],
    weaknesses:["Number of states must be pre-specified","EM convergence to local optima","Look-ahead risk if not properly windowed"],
    synergiesWith:["regime_logistic","gbt","kalman","late_fusion","var"],conflictsWith:[],relatedTo:["garch","structural_ts"],relevantOps:["S_cluster","E_regime"] },
  gbt: {
    strengths:["Handles arbitrary non-linear feature interactions","Built-in feature importance ranking","Robust to irrelevant and collinear features"],
    weaknesses:["Requires careful temporal feature engineering","High leakage risk without proper walk-forward CV","Cannot extrapolate beyond training data range"],
    synergiesWith:["stl","hmm","ewma","conformal","late_fusion"],conflictsWith:["rf"],relatedTo:["rf","svr","regime_logistic"],relevantOps:["L_mean","D_velocity","D_volatility","S_autocorr"] },
  rf: {
    strengths:["Parallelizable training, inherently lower variance","Built-in OOB error estimate, no separate validation","Handles mixed feature types without encoding"],
    weaknesses:["Cannot extrapolate, same limitation as all trees","Usually less accurate than boosting on tabular data","Large memory footprint with many trees"],
    synergiesWith:["stl","hmm","conformal"],conflictsWith:["gbt"],relatedTo:["gbt","svr"],relevantOps:["L_mean","D_velocity"] },
  svr: {
    strengths:["Kernel trick enables non-linearity without feature engineering","Effective in high-dimensional sparse feature spaces","Robust to overfitting via margin regularization"],
    weaknesses:["Scales poorly O(nÂ²) to O(nÂ³) with dataset size","Requires careful feature scaling","No native probabilistic output"],
    synergiesWith:["stl","conformal"],conflictsWith:[],relatedTo:["gbt","rf","gp"],relevantOps:["L_mean","D_velocity"] },
  regime_logistic: {
    strengths:["Interpretable coefficients per regime","Low parameter count, reduces overfitting","Explicit regime conditioning for auditability"],
    weaknesses:["Requires upstream regime labels","Linear within each regime","Cannot discover new or transitional regimes"],
    synergiesWith:["hmm","ewma","late_fusion"],conflictsWith:[],relatedTo:["gbt","hmm"],relevantOps:["S_cluster","E_regime"] },
  lstm: {
    strengths:["Learns long-range temporal dependencies via cell state","End-to-end feature learning from raw sequences","Flexible architecture for multivariate and multi-step"],
    weaknesses:["Requires large training data (>10k observations)","Sequential computation prevents parallelization","Prone to overfitting on small financial datasets"],
    synergiesWith:["stl","conformal","hmm","late_fusion"],conflictsWith:["gru"],relatedTo:["gru","transformer","deepar"],relevantOps:["D_momentum","S_autocorr"] },
  gru: {
    strengths:["Fewer parameters than LSTM, 30-40% faster training","Comparable accuracy on sequences < 200 steps","Simpler gradient flow reduces vanishing gradient issues"],
    weaknesses:["Same large-data requirements as LSTM","Less capacity for very long-range dependencies","Same overfitting risks on small datasets"],
    synergiesWith:["stl","conformal"],conflictsWith:["lstm"],relatedTo:["lstm","transformer"],relevantOps:["D_momentum","S_autocorr"] },
  transformer: {
    strengths:["Parallel computation over sequence (vs sequential RNN)","Self-attention discovers relevant lags automatically","State-of-the-art on large multivariate datasets"],
    weaknesses:["O(nÂ²) memory in sequence length","Needs very large training data to outperform ARIMA","Positional encoding design affects performance significantly"],
    synergiesWith:["stl","conformal"],conflictsWith:["tft"],relatedTo:["tft","nbeats","lstm"],relevantOps:["S_autocorr","D_momentum"] },
  nbeats: {
    strengths:["Interpretable trend/seasonal decomposition learned from data","No feature engineering required â€” pure univariate","Competitive with ensemble methods on M4 benchmark"],
    weaknesses:["Univariate only in base form, no exogenous inputs","Requires sufficient history for training","Block architecture limits flexibility"],
    synergiesWith:["conformal","garch"],conflictsWith:["stl","prophet"],relatedTo:["transformer","lstm","stl"],relevantOps:["L_mean","S_autocorr"] },
  tft: {
    strengths:["Variable importance via interpretable attention gates","Multi-horizon output in single forward pass","Handles static, known-future, and time-varying covariates"],
    weaknesses:["Complex architecture, difficult to debug and modify","Requires large training data to leverage full capacity","Slow inference on CPU, needs GPU for production"],
    synergiesWith:["stl","conformal"],conflictsWith:["transformer"],relatedTo:["transformer","deepar"],relevantOps:["S_autocorr","X_correlation"] },
  deepar: {
    strengths:["Full predictive distribution output (not just intervals)","Handles related time series jointly via shared parameters","No quantile crossing issues â€” produces coherent distributions"],
    weaknesses:["Parametric likelihood assumption may be misspecified","Requires sufficient training data per series","Slow sampling at inference time"],
    synergiesWith:["stl","hmm"],conflictsWith:[],relatedTo:["tft","bsts","lstm"],relevantOps:["D_volatility","S_autocorr"] },
  bsts: {
    strengths:["Full posterior over all structural components","Spike-and-slab variable selection for regressors","Google CausalImpact built directly on this framework"],
    weaknesses:["MCMC sampling is slow (minutes to hours)","Prior sensitivity requires Bayesian expertise","Scaling to hundreds of series is impractical"],
    synergiesWith:["garch","hmm"],conflictsWith:["structural_ts","prophet"],relatedTo:["structural_ts","gp","deepar"],relevantOps:["L_mean","S_autocorr","ST_stationarity"] },
  gp: {
    strengths:["Full uncertainty quantification from Bayesian posterior","Non-parametric â€” adapts model complexity to data","Kernel encodes inductive bias explicitly and transparently"],
    weaknesses:["O(nÂ³) training limits to ~10k data points","Kernel selection and hyperparameter tuning is an art","Posteriors can be overconfident far from training data"],
    synergiesWith:["stl","conformal"],conflictsWith:[],relatedTo:["bsts","svr"],relevantOps:["S_autocorr","ST_hurst"] },
  quantile_reg: {
    strengths:["Direct interval estimation without distributional assumptions","Reveals heteroskedasticity via crossing quantiles","Computationally efficient via linear programming"],
    weaknesses:["No coherent distribution â€” quantiles may cross","Requires feature engineering like any regression","Single quantile estimated per optimization"],
    synergiesWith:["gbt","var","arima","garch"],conflictsWith:["conformal"],relatedTo:["conformal","gp"],relevantOps:["L_quantile","L_zscore"] },
  conformal: {
    strengths:["Distribution-free finite-sample coverage guarantee","Model-agnostic â€” wraps any point predictor","Adaptive to non-stationarity via ACI variants"],
    weaknesses:["Requires exchangeability (relaxed in ACI)","Intervals may be wide if base model is poor","No parametric distribution, just intervals"],
    synergiesWith:["arima","gbt","lstm","transformer","prophet","ets","kalman","nbeats","tft","naive","rf","svr","theta"],conflictsWith:["quantile_reg"],relatedTo:["quantile_reg","model_avg"],relevantOps:["L_zscore","E_anomaly"] },
  stl: {
    strengths:["Robust to outliers via LOESS fitting","Separates signal into clean interpretable components","Residuals are approximately stationary â€” ideal for downstream models"],
    weaknesses:["Requires at least 2 full seasonal cycles","Additive only in base form, must log-transform for multiplicative","Single seasonal period â€” cannot handle dual seasonality natively"],
    synergiesWith:["arima","gbt","lstm","garch","var","gru","transformer","rf","svr","conformal","tft"],conflictsWith:["x13"],relatedTo:["x13","prophet","structural_ts"],relevantOps:["L_mean","S_autocorr","ST_stationarity"] },
  x13: {
    strengths:["Gold standard for seasonal adjustment (US Census Bureau)","Handles trading day, holiday, and outlier effects automatically","Produces publication-quality seasonally adjusted series"],
    weaknesses:["Designed for monthly/quarterly data only","Complex configuration with steep learning curve","Batch processing â€” not suited for streaming applications"],
    synergiesWith:["arima","gbt"],conflictsWith:["stl"],relatedTo:["stl","prophet","sarima"],relevantOps:["L_mean","S_autocorr"] },
  prophet: {
    strengths:["Handles holidays and special events with user-specified dates","Intuitive additive component model accessible to non-experts","Fast fitting enables interactive exploration of specifications"],
    weaknesses:["Additive linear trends can overshoot at long horizons","Less accurate than ARIMA on regular stationary series","Uncertainty intervals are often miscalibrated"],
    synergiesWith:["conformal","garch"],conflictsWith:["stl","nbeats","bsts","sarima"],relatedTo:["stl","bsts","ets"],relevantOps:["L_mean","S_autocorr"] },
  hawkes: {
    strengths:["Models event self-excitation and temporal clustering","Captures contagion and cascade dynamics analytically","Intensity function is interpretable and has closed-form mean"],
    weaknesses:["Assumes stationary base intensity","Parametric kernel limits flexibility (exponential/power-law)","Estimation difficult with very sparse event streams"],
    synergiesWith:["gbt","hmm","model_avg"],conflictsWith:["cox"],relatedTo:["cox"],relevantOps:["E_spike","E_catalyst","D_velocity"] },
  cox: {
    strengths:["Flexible random intensity driven by external covariates","Richer than Hawkes when external drivers are known","Full posterior on intensity with Bayesian MCMC methods"],
    weaknesses:["Requires explicit intensity model specification","Computationally expensive MCMC or variational inference","Less interpretable than Hawkes, more of a black box"],
    synergiesWith:["gbt","hmm"],conflictsWith:["hawkes"],relatedTo:["hawkes","gp"],relevantOps:["E_spike","E_catalyst","D_volatility"] },
  late_fusion: {
    strengths:["Simplest robust model combination â€” weighted average","No additional overfitting risk beyond base models","Weights can be updated online without full retraining"],
    weaknesses:["Requires diverse base models to be effective","Cannot learn non-linear interactions between model predictions","Optimal weights drift â€” requires periodic recalibration"],
    synergiesWith:["arima","gbt","lstm","hmm","regime_logistic"],conflictsWith:["stacking","model_avg"],relatedTo:["model_avg","stacking"],relevantOps:[] },
  stacking: {
    strengths:["Meta-learner captures non-linear model complementarities","Highest theoretical ceiling for model combination","Can use model predictions alongside raw features"],
    weaknesses:["High leakage risk â€” requires strict nested cross-validation","Computationally expensive: train all base models + meta-learner","Overfitting risk if base model errors are correlated"],
    synergiesWith:["gbt","lstm","arima"],conflictsWith:["late_fusion","model_avg"],relatedTo:["late_fusion","model_avg"],relevantOps:[] },
  model_avg: {
    strengths:["Bayesian model averaging provides calibrated model uncertainty","Robust to single model failure or misspecification","BIC/AIC weights have theoretical optimality properties"],
    weaknesses:["Assumes true model is in the candidate set (M-closed)","Weights tend to concentrate on single best model","Cannot improve beyond best model's systematic errors"],
    synergiesWith:["arima","gbt","bsts","hawkes"],conflictsWith:["late_fusion","stacking"],relatedTo:["late_fusion","stacking"],relevantOps:[] },
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HILBERT SPACE CAUSAL FRAMEWORK
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const HILBERT_CONCEPTS = [
  { id:"projection", name:"Orthogonal Projection", symbol:"P_H", color:T.blue,
    description:"Prediction as projection onto subspace of past information",
    hilbertMeaning:"Best predictor minimizes LÂ² distance to subspace â€” Var(X_{t+1}|H)",
    causalRole:"Granger causality = comparing projections onto nested subspaces H_X âŠ‚ H_{X,Y}",
    techniques:["naive","seasonal_naive","ewma","moving_avg","arima","sarima","ets","theta","kalman","quantile_reg","conformal"] },
  { id:"orthogonality", name:"Orthogonality = Independence", symbol:"X âŠ¥ Y â†” C_XY=0", color:T.green,
    description:"Statistical independence manifests as orthogonality of RKHS embeddings",
    hilbertMeaning:"C_XY = E[Ï†(X)âŠ—Ïˆ(Y)] = 0 iff X âŠ¥ Y when embedded in characteristic RKHS",
    causalRole:"HSIC / kernel conditional independence tests â€” conditioning annihilates the operator",
    techniques:["hmm","var","bsts","gp","regime_logistic"] },
  { id:"rkhs_lifting", name:"RKHS Lifting", symbol:"Ï†(x) âˆˆ H", color:T.orange,
    description:"Map nonlinear relationships to linear ones in infinite-dimensional Hilbert space",
    hilbertMeaning:"Kernel trick: k(x,y) = âŸ¨Ï†(x),Ï†(y)âŸ© replaces explicit infinite-dim feature maps",
    causalRole:"Kernel Granger causality detects nonlinear causal links invisible to linear methods",
    techniques:["gp","svr","gbt","rf","lstm","gru","transformer","nbeats","tft","deepar"] },
  { id:"tensor_product", name:"Tensor Factorization", symbol:"Hâ‚ âŠ— Hâ‚‚", color:T.crimson,
    description:"Multimodal signals live in tensor products of per-modality Hilbert spaces",
    hilbertMeaning:"Causality = whether projection onto one tensor factor reduces residual energy",
    causalRole:"Cross-modal causal inference via operator-valued kernels K: Hâ‚ â†’ Hâ‚‚",
    techniques:["var","tft","late_fusion","stacking","model_avg","regime_logistic"] },
  { id:"spectral", name:"Spectral Decomposition", symbol:"S_XY(Ï‰)", color:T.purple,
    description:"Time-delay causality as directional frequency flow via cross-spectrum operators",
    hilbertMeaning:"Spectral theorem decomposes covariance operators â€” eigenfunctions = frequency modes",
    causalRole:"Transfer entropy approximations, directed coherence, neural connectivity inference",
    techniques:["stl","x13","garch","sarima","prophet","nbeats","structural_ts","bsts"] },
  { id:"cross_covariance", name:"Cross-Covariance Operator", symbol:"C_XY = E[Ï†(X)âŠ—Ïˆ(Y)]", color:T.teal,
    description:"Operator encoding all dependencies between embedded signals",
    hilbertMeaning:"â€–C_XYâ€–_HS measures total dependence; C_XY=0 â†” independence in RKHS",
    causalRole:"HSIC statistic, kernel conditional independence, operator-valued regression",
    techniques:["var","gp","hmm","hawkes","cox","kalman","ewma"] },
];

const HILBERT_MAPPING = {
  naive:{ concept:"projection", interpretation:"Constant projection: P_H(X_{t+1}) = X_t â€” degenerate subspace" },
  seasonal_naive:{ concept:"projection", interpretation:"Periodic subspace projection: copies value from same phase of previous cycle" },
  ewma:{ concept:"cross_covariance", interpretation:"Exponentially weighted projection â€” implicitly estimates local cross-covariance" },
  moving_avg:{ concept:"projection", interpretation:"Uniform projection onto finite-window subspace span{X_{t-w},...,X_t}" },
  arima:{ concept:"projection", interpretation:"Projection onto ARMA subspace after differencing to achieve stationarity" },
  sarima:{ concept:"projection", interpretation:"Seasonal subspace projection: H = span{Ï†_p(X), Ï†_P(X_season)}" },
  ets:{ concept:"projection", interpretation:"State-space projection decomposing into error, trend, seasonal components" },
  var:{ concept:"cross_covariance", interpretation:"Joint projection exploiting cross-covariance C_XY between series â€” Granger testable" },
  garch:{ concept:"spectral", interpretation:"2nd-moment spectral projection: models volatility as autoregressive spectrum of squared residuals" },
  theta:{ concept:"projection", interpretation:"Projection onto theta-line subspace â€” equivalent to SES with drift" },
  kalman:{ concept:"projection", interpretation:"Optimal recursive projection P_{H_t}(X_t): minimizes posterior variance at each step" },
  structural_ts:{ concept:"spectral", interpretation:"State-space spectral decomposition into trend + seasonal + cycle eigenmodes" },
  hmm:{ concept:"orthogonality", interpretation:"Regime detection via orthogonal state partitioning: P(regime|obs) factorizes" },
  gbt:{ concept:"rkhs_lifting", interpretation:"Tree ensemble â‰ˆ projection in implicit RKHS defined by leaf partition kernel" },
  rf:{ concept:"rkhs_lifting", interpretation:"Random forest kernel K(x,y) = fraction of trees placing x,y in same leaf" },
  svr:{ concept:"rkhs_lifting", interpretation:"Explicit RKHS projection: f(x) = âŸ¨w,Ï†(x)âŸ©_H with Îµ-insensitive loss" },
  regime_logistic:{ concept:"tensor_product", interpretation:"Regime âŠ— features tensor product: prediction conditioned on regime factor" },
  lstm:{ concept:"rkhs_lifting", interpretation:"Learned nonlinear lifting Ï†: sequence â†’ H via gated memory cells" },
  gru:{ concept:"rkhs_lifting", interpretation:"Gated lifting into representation space â€” simplified RKHS with reset/update" },
  transformer:{ concept:"rkhs_lifting", interpretation:"Self-attention â‰ˆ softmax kernel regression: K(q,k) = exp(qÂ·k/âˆšd)" },
  nbeats:{ concept:"spectral", interpretation:"Learned basis expansion â‰ˆ data-adaptive spectral decomposition into trend + harmonic" },
  tft:{ concept:"tensor_product", interpretation:"Variable selection via attention in covariate tensor space H_static âŠ— H_temporal" },
  deepar:{ concept:"rkhs_lifting", interpretation:"Autoregressive RNN: maps sequences to likelihood parameters via learned Ï†" },
  bsts:{ concept:"spectral", interpretation:"Bayesian spectral decomposition with spike-and-slab prior on component inclusion" },
  gp:{ concept:"rkhs_lifting", interpretation:"Exact RKHS projection: posterior mean = P_{span{k(Â·,x_i)}}(f) in kernel Hilbert space" },
  quantile_reg:{ concept:"projection", interpretation:"Asymmetric LÂ¹ projection: minimizes weighted absolute deviation per quantile" },
  conformal:{ concept:"projection", interpretation:"Nonparametric projection set with finite-sample coverage via exchangeability" },
  stl:{ concept:"spectral", interpretation:"LOESS-based spectral separation: trend (low-freq) + seasonal (periodic) + residual" },
  x13:{ concept:"spectral", interpretation:"Calendar-aware spectral decomposition with trading-day + holiday adjustment" },
  prophet:{ concept:"spectral", interpretation:"Projection onto trend + Fourier seasonal basis: f(t) = g(t) + Î£ aâ‚™sin(2Ï€nt/P)" },
  hawkes:{ concept:"cross_covariance", interpretation:"Self-excitation kernel Î¼(t) = Î¼â‚€ + Î£ Î±Â·exp(-Î²(t-táµ¢)) â€” causal intensity coupling" },
  cox:{ concept:"cross_covariance", interpretation:"Doubly stochastic intensity: random projection in event-counting Hilbert space" },
  late_fusion:{ concept:"tensor_product", interpretation:"Averaging over model tensor factors: f = Î£ wáµ¢ fáµ¢ where fáµ¢ âˆˆ Háµ¢" },
  stacking:{ concept:"tensor_product", interpretation:"Meta-learner in tensor product: g(fâ‚(x),...,fâ‚–(x)) maps Hâ‚âŠ—...âŠ—Hâ‚– â†’ R" },
  model_avg:{ concept:"tensor_product", interpretation:"Bayesian model-space averaging: E_Ï€[f] over model index factor" },
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DATA â€” KNOWN SYNERGIES (54 documented pairings)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const KNOWN_SYNERGIES = [
  { from:"stl", to:"arima", reason:"STL removes trend+seasonality, leaving stationary residuals ideal for ARIMA modeling", principles:[1,2,5] },
  { from:"stl", to:"garch", reason:"STL residuals reveal volatility clustering that GARCH is designed to capture", principles:[1,2,5] },
  { from:"stl", to:"gbt", reason:"Decomposed components (trend, seasonal, residual) become clean features for gradient boosting", principles:[1,3] },
  { from:"stl", to:"lstm", reason:"Pre-decomposition reduces non-stationarity, letting LSTM focus on complex residual dynamics", principles:[1,5] },
  { from:"stl", to:"transformer", reason:"Decomposition lets transformer attend to residual patterns without learning seasonality from scratch", principles:[1,5] },
  { from:"stl", to:"gp", reason:"Decomposed residuals are well-suited for GP regression with stationary kernels", principles:[1,5] },
  { from:"stl", to:"var", reason:"Decomposed residuals from multiple series create a stationary multivariate system for VAR", principles:[1,2,5] },
  { from:"hmm", to:"regime_logistic", reason:"HMM provides regime labels that logistic regression uses to make regime-conditional predictions", principles:[1,7] },
  { from:"hmm", to:"gbt", reason:"Regime labels from HMM become powerful categorical features for tree-based models", principles:[1,7] },
  { from:"hmm", to:"late_fusion", reason:"Regime probabilities from HMM can weight ensemble members by regime-specific accuracy", principles:[1,3] },
  { from:"hmm", to:"var", reason:"Regime-conditional VAR parameters capture state-dependent cross-variable dynamics", principles:[1,7] },
  { from:"arima", to:"conformal", reason:"ARIMA point forecasts gain distribution-free coverage guarantees from conformal prediction", principles:[1,3,6] },
  { from:"gbt", to:"conformal", reason:"ML predictions wrapped with conformal intervals achieve both accuracy and calibrated coverage", principles:[1,3,6] },
  { from:"lstm", to:"conformal", reason:"Deep learning forecasts gain rigorous finite-sample coverage guarantees", principles:[1,3,6] },
  { from:"prophet", to:"conformal", reason:"Prophet's often-miscalibrated intervals replaced with distribution-free coverage guarantees", principles:[1,3,6] },
  { from:"tft", to:"conformal", reason:"TFT multi-horizon forecasts wrapped with conformal intervals for reliable coverage", principles:[1,3,6] },
  { from:"arima", to:"garch", reason:"ARIMA for mean equation + GARCH for variance equation = complete specification", principles:[1,2] },
  { from:"ewma", to:"garch", reason:"EWMA-smoothed level estimate feeds cleanly into GARCH volatility model â€” level/vol separation", principles:[1,2] },
  { from:"ewma", to:"hmm", reason:"Smoothed features improve HMM regime detection by reducing observation noise", principles:[1,3] },
  { from:"kalman", to:"hmm", reason:"Kalman-filtered state estimates provide cleaned input for regime classification", principles:[1,3] },
  { from:"moving_avg", to:"var", reason:"Smoothed series better satisfy stationarity assumptions required by VAR", principles:[1,5] },
  { from:"moving_avg", to:"gbt", reason:"Moving average features at multiple window sizes are powerful predictors for tree models", principles:[1,3] },
  { from:"garch", to:"quantile_reg", reason:"Volatility features from GARCH inform quantile regression for heteroskedastic risk intervals", principles:[1,2] },
  { from:"hawkes", to:"gbt", reason:"Hawkes intensity features capture event clustering that tree models can exploit as features", principles:[1,3] },
  { from:"bsts", to:"model_avg", reason:"Multiple BSTS specifications averaged via posterior model probabilities for robust inference", principles:[1,12] },
  { from:"kalman", to:"gbt", reason:"Kalman-filtered state estimates create clean features for gradient boosting", principles:[1,3] },
  { from:"kalman", to:"conformal", reason:"Kalman point estimates gain distribution-free coverage guarantees", principles:[1,3,6] },
  { from:"garch", to:"hmm", reason:"Volatility features from GARCH improve regime boundary detection", principles:[1,7] },
  { from:"x13", to:"arima", reason:"Official seasonal adjustment leaves calendar-clean residuals for ARIMA", principles:[1,2,5] },
  { from:"x13", to:"gbt", reason:"Calendar-adjusted features from X-13 are clean inputs for tree models", principles:[1,3] },
  { from:"stl", to:"rf", reason:"Decomposed components become interpretable features for random forest", principles:[1,3] },
  { from:"stl", to:"nbeats", reason:"Pre-decomposed residuals let N-BEATS focus on complex patterns", principles:[1,5] },
  { from:"hmm", to:"garch", reason:"Regime-conditional GARCH captures state-dependent volatility dynamics", principles:[1,7] },
  { from:"hmm", to:"kalman", reason:"Regime labels enable switching Kalman filter for state-dependent dynamics", principles:[1,7] },
  { from:"gp", to:"conformal", reason:"GP posterior uncertainty wrapped with conformal for finite-sample coverage", principles:[1,3,6] },
  { from:"stacking", to:"conformal", reason:"Stacked ensemble predictions calibrated with conformal intervals", principles:[1,3,6] },
  { from:"deepar", to:"model_avg", reason:"Multiple DeepAR runs with different seeds averaged for robust distributions", principles:[1,12] },
  { from:"nbeats", to:"conformal", reason:"N-BEATS point forecasts gain distribution-free coverage guarantees", principles:[1,3,6] },
  { from:"rf", to:"conformal", reason:"Random forest predictions wrapped with conformal for reliable intervals", principles:[1,3,6] },
  { from:"gru", to:"conformal", reason:"GRU point forecasts calibrated with conformal prediction sets", principles:[1,3,6] },
  { from:"var", to:"garch", reason:"VAR for multivariate mean equation + GARCH for marginal variance â€” complete spec", principles:[1,2] },
  { from:"cox", to:"gbt", reason:"Cox process intensity estimates become powerful features for tree models", principles:[1,3] },
  { from:"prophet", to:"gbt", reason:"Prophet residuals + regressors create rich features for gradient boosting", principles:[1,3] },
  { from:"ewma", to:"gbt", reason:"EWMA at multiple decay rates creates informative smoothed features for trees", principles:[1,3] },
  { from:"ewma", to:"lstm", reason:"Smoothed input reduces noise, letting LSTM focus on temporal structure", principles:[1,3] },
  { from:"structural_ts", to:"conformal", reason:"Structural TS point forecasts gain coverage guarantees from conformal", principles:[1,3,6] },
  { from:"theta", to:"conformal", reason:"Theta's simple forecasts gain rigorous prediction intervals", principles:[1,3,6] },
  { from:"svr", to:"conformal", reason:"SVR regression surface wrapped with conformal coverage bands", principles:[1,3,6] },
  { from:"hmm", to:"stacking", reason:"Regime probabilities become meta-features for stacking ensemble", principles:[1,3,7] },
  { from:"stl", to:"deepar", reason:"Pre-decomposition lets DeepAR model residual dynamics with less data", principles:[1,5] },
  { from:"stl", to:"svr", reason:"Decomposed components as features reduce non-stationarity for SVR", principles:[1,5] },
  { from:"hawkes", to:"hmm", reason:"Hawkes intensity dynamics reveal event clustering for regime detection", principles:[1,7] },
  { from:"moving_avg", to:"kalman", reason:"Pre-smoothed observations reduce observation noise for Kalman filter", principles:[1,3] },
  { from:"moving_avg", to:"lstm", reason:"Multi-window moving averages create temporal features for LSTM", principles:[1,3] },
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DATA â€” KNOWN CONFLICTS (15 documented anti-patterns)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const KNOWN_CONFLICTS = [
  { from:"sarima", to:"ets", reason:"Both own trend+seasonality â€” impossible to attribute which component comes from which model", violation:2, severity:"fail" },
  { from:"sarima", to:"prophet", reason:"Both model trend+seasonality â€” redundant decomposition creates uninterpretable pipeline", violation:2, severity:"fail" },
  { from:"prophet", to:"nbeats", reason:"Both learn trend/seasonal decomposition â€” N-BEATS would re-decompose Prophet's output", violation:2, severity:"fail" },
  { from:"stl", to:"x13", reason:"Two decomposition transforms in sequence â€” X-13 would try to decompose already-decomposed data", violation:2, severity:"fail" },
  { from:"structural_ts", to:"bsts", reason:"Nearly identical state-space decomposition approaches â€” one is completely redundant", violation:2, severity:"fail" },
  { from:"conformal", to:"arima", reason:"Calibration step before model step violates pipeline role ordering (calibrationâ†’model)", violation:3, severity:"fail" },
  { from:"stacking", to:"gbt", reason:"Decision/meta-learner before base model violates causal ordering", violation:3, severity:"fail" },
  { from:"late_fusion", to:"lstm", reason:"Ensemble decision step before model step â€” reversed pipeline direction", violation:3, severity:"fail" },
  { from:"hawkes", to:"theta", reason:"Tick-level point process chained with monthly-only method â€” incompatible time scales", violation:4, severity:"fail" },
  { from:"kalman", to:"x13", reason:"Real-time streaming filter feeding into monthly/quarterly batch method â€” scale mismatch", violation:4, severity:"fail" },
  { from:"gbt", to:"rf", reason:"Both tree-based with correlated errors â€” minimal diversity benefit if ensembled together", violation:12, severity:"warn" },
  { from:"lstm", to:"gru", reason:"Both gated RNNs with nearly identical error profiles â€” wastes compute without diversity", violation:12, severity:"warn" },
  { from:"transformer", to:"tft", reason:"Both attention-based architectures â€” high error correlation undermines combination benefit", violation:12, severity:"warn" },
  { from:"prophet", to:"stl", reason:"Prophet already decomposes internally â€” STL would re-decompose, destroying component structure", violation:2, severity:"warn" },
  { from:"nbeats", to:"stl", reason:"N-BEATS learns decomposition end-to-end â€” STL after it would re-separate already-separated components", violation:2, severity:"warn" },
  { from:"bsts", to:"ets", reason:"Both own trend+seasonality decomposition â€” redundant component modeling", violation:2, severity:"fail" },
  { from:"structural_ts", to:"stl", reason:"Both decompose into trend+seasonal â€” chaining re-decomposes already-decomposed output", violation:2, severity:"fail" },
  { from:"prophet", to:"structural_ts", reason:"Both decompose into components â€” structural TS would re-decompose Prophet's decomposition", violation:2, severity:"fail" },
  { from:"nbeats", to:"ets", reason:"N-BEATS learns its own decomposition â€” ETS would model already-decomposed output", violation:2, severity:"warn" },
  { from:"deepar", to:"gp", reason:"Both produce full predictive distributions â€” stacking uncertainties is incoherent", violation:2, severity:"warn" },
  { from:"deepar", to:"quantile_reg", reason:"Both produce distributional output â€” redundant uncertainty quantification", violation:2, severity:"warn" },
  { from:"rf", to:"svr", reason:"Both single-output regressors with similar error profiles â€” minimal diversity gain", violation:12, severity:"warn" },
  { from:"model_avg", to:"stacking", reason:"Both ensemble combination methods at same pipeline level â€” cannot stack a stack", violation:3, severity:"fail" },
  { from:"model_avg", to:"late_fusion", reason:"Two ensemble aggregation steps in sequence â€” second would trivially average one model", violation:3, severity:"fail" },
  { from:"x13", to:"stl", reason:"Both seasonal decomposition methods â€” X-13 output is already decomposed", violation:2, severity:"fail" },
  { from:"hawkes", to:"cox", reason:"Both model event arrival intensity â€” redundant point process specification", violation:2, severity:"fail" },
  { from:"bsts", to:"prophet", reason:"Both decompose into trend+seasonality with Bayesian/MAP estimation â€” fully redundant", violation:2, severity:"fail" },
  { from:"arima", to:"theta", reason:"Theta is equivalent to SES with drift â€” conflicts with ARIMA's trend specification", violation:2, severity:"warn" },
  { from:"late_fusion", to:"stacking", reason:"Both are meta-learner steps â€” one combination method is sufficient", violation:3, severity:"fail" },
  { from:"gru", to:"lstm", reason:"Both gated RNNs with nearly identical architectures â€” insufficient diversity", violation:12, severity:"warn" },
  { from:"ets", to:"structural_ts", reason:"Both state-space models owning trend+seasonality â€” redundant component estimation", violation:2, severity:"fail" },
  { from:"gp", to:"bsts", reason:"Both probabilistic models with full posteriors â€” stacking posteriors lacks coherence", violation:2, severity:"warn" },
  { from:"quantile_reg", to:"conformal", reason:"Both calibration-step methods â€” redundant interval estimation", violation:2, severity:"warn" },
  { from:"sarima", to:"nbeats", reason:"Both model trend+seasonality â€” N-BEATS would re-learn what SARIMA already captured", violation:2, severity:"fail" },
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DATA â€” CANONICAL PIPELINES (12 recommended chains)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const CANONICAL_PIPELINES = [
  { id:"quick_baseline", name:"Quick Baseline", description:"Minimal viable forecast â€” establish the floor before adding complexity",
    steps:["naive","conformal"], archetype:"any", complexity:1, useCase:"First benchmark for any new series" },
  { id:"seasonal_forecast", name:"Seasonal Forecasting", description:"Classical decomposition â†’ seasonal model â†’ calibrated intervals",
    steps:["stl","sarima","conformal"], archetype:"seasonal", complexity:3, useCase:"Retail sales, energy demand, quarterly financials" },
  { id:"regime_aware_ml", name:"Regime-Aware ML", description:"Detect hidden regimes â†’ predict conditional on regime â†’ combine",
    steps:["hmm","regime_logistic","late_fusion"], archetype:"regime_switching", complexity:3, useCase:"Trading signals across bull/bear markets" },
  { id:"volatility_pipeline", name:"Volatility Pipeline", description:"Separate level from volatility â†’ model each â†’ risk quantiles",
    steps:["stl","garch","quantile_reg"], archetype:"regime_switching", complexity:3, useCase:"Risk management, VaR and ES estimation" },
  { id:"deep_sequence", name:"Deep Sequence", description:"Decompose â†’ model residuals with LSTM â†’ conformal coverage",
    steps:["stl","lstm","conformal"], archetype:"trending", complexity:4, useCase:"Complex non-linear dynamics with coverage guarantees" },
  { id:"bayesian_stack", name:"Bayesian Full-Stack", description:"Bayesian structural model with posterior model averaging",
    steps:["bsts","model_avg"], archetype:"trending", complexity:4, useCase:"Causal impact analysis, macro forecasting" },
  { id:"event_cascade", name:"Event Cascade", description:"Model self-excitation â†’ extract features â†’ robust combination",
    steps:["hawkes","gbt","model_avg"], archetype:"event_driven", complexity:4, useCase:"News cascades, order flow, social contagion" },
  { id:"cross_asset", name:"Cross-Asset System", description:"Smooth â†’ multivariate dynamics â†’ heteroskedastic risk intervals",
    steps:["moving_avg","var","quantile_reg"], archetype:"mean_reverting", complexity:3, useCase:"Multi-asset portfolio, macro indicators" },
  { id:"ml_ensemble", name:"ML Competition Pipeline", description:"Decompose â†’ diverse ML â†’ stack with meta-learner",
    steps:["stl","gbt","stacking"], archetype:"seasonal", complexity:4, useCase:"Forecasting competitions, maximum accuracy" },
  { id:"robust_diverse", name:"Robust Diverse Ensemble", description:"Multi-family models combined for variance reduction",
    steps:["moving_avg","arima","late_fusion"], archetype:"any", complexity:2, useCase:"Production deployment, robust to model failure" },
  { id:"attention_forecast", name:"Attention Forecasting", description:"Decompose â†’ transformer â†’ conformal calibration",
    steps:["stl","transformer","conformal"], archetype:"trending", complexity:5, useCase:"Large datasets with complex multi-horizon patterns" },
  { id:"noise_filter", name:"Noise Filtering", description:"Smooth â†’ state estimation â†’ non-parametric uncertainty",
    steps:["moving_avg","kalman","gp"], archetype:"high_freq_noise", complexity:4, useCase:"Sensor data, noisy high-frequency signals" },
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COMPOSABILITY ENGINE (enhanced with synergy/conflict data)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const ROLE_ORDER = { transform:0, feature:1, model:2, calibration:3, decision:4 };

// Build fast lookup tables
const _synergyMap = {};
KNOWN_SYNERGIES.forEach(s => { _synergyMap[`${s.from}|${s.to}`] = s; });
const _conflictMap = {};
KNOWN_CONFLICTS.forEach(c => { _conflictMap[`${c.from}|${c.to}`] = c; });

function checkComposition(techA, techB) {
  const checks = [];
  const key = `${techA.id}|${techB.id}`;
  const synergy = _synergyMap[key];
  const conflict = _conflictMap[key];

  // 1. Semantic compatibility â€” does B accept A's output type?
  const typeOverlap = techA.outputTypes.some(t => techB.inputTypes.includes(t));
  // Also check if decomposed output feeds univariate consumer (common pattern)
  const implicitCompat = techA.outputTypes.includes("decomposed") && techB.inputTypes.includes("univariate");
  const semanticOk = typeOverlap || implicitCompat;
  checks.push({ name:"Semantic Compatibility", pass:semanticOk,
    severity: semanticOk ? "ok" : "fail",
    detail: semanticOk
      ? (implicitCompat && !typeOverlap)
        ? `decomposed components feed as univariate (implicit)`
        : `${techA.outputTypes.filter(t=>techB.inputTypes.includes(t)).join(", ")} accepted`
      : `${techA.name} outputs [${techA.outputTypes}] but ${techB.name} needs [${techB.inputTypes}]` });

  // 2. Ownership â€” do they own the same responsibility?
  const shared = techA.ownedResponsibilities.filter(r => techB.ownedResponsibilities.includes(r));
  checks.push({ name:"Ownership", pass: shared.length === 0,
    severity: shared.length === 0 ? "ok" : shared.length > 1 ? "fail" : "warn",
    detail: shared.length === 0 ? "No responsibility overlap" : `Both own: ${shared.join(", ")}` });

  // 3. Time honesty â€” does pipeline role ordering hold?
  const orderA = ROLE_ORDER[techA.pipelineRole] ?? 2;
  const orderB = ROLE_ORDER[techB.pipelineRole] ?? 2;
  const timeOk = orderA <= orderB;
  checks.push({ name:"Time Honesty", pass:timeOk,
    severity: timeOk ? "ok" : "fail",
    detail: timeOk ? `${techA.pipelineRole} â†’ ${techB.pipelineRole} preserves causal order`
      : `${techA.pipelineRole} â†’ ${techB.pipelineRole} violates pipeline ordering` });

  // 4. Scale compatibility â€” are time scales reconciled?
  const scaleOverlap = techA.timeScales.some(s => techB.timeScales.includes(s));
  const sharedScales = techA.timeScales.filter(s => techB.timeScales.includes(s));
  checks.push({ name:"Scale Compatibility", pass:scaleOverlap,
    severity: scaleOverlap ? "ok" : "warn",
    detail: scaleOverlap ? `Shared: ${sharedScales.join(", ")}` : `Mismatch: [${techA.timeScales}] vs [${techB.timeScales}]` });

  // 5. Evaluation integrity â€” does chaining force snooping?
  const bothHigh = techA.leakageRisk === "high" && techB.leakageRisk === "high";
  checks.push({ name:"Evaluation Integrity", pass:!bothHigh,
    severity: bothHigh ? "warn" : "ok",
    detail: bothHigh ? "Both high leakage risk â€” nested CV required" : "Evaluation isolation maintainable" });

  // 6. Identifiability â€” can you still ablate?
  const sameModel = techA.pipelineRole === "model" && techB.pipelineRole === "model";
  checks.push({ name:"Identifiability", pass:!sameModel,
    severity: sameModel ? "warn" : "ok",
    detail: sameModel ? "Two models in sequence â€” ablation requires care" : "Components independently testable" });

  // 7. Known synergy boost
  if (synergy) {
    checks.push({ name:"Known Synergy", pass:true, severity:"ok",
      detail: `âœ¦ ${synergy.reason} (principles ${synergy.principles.join(",")})` });
  }

  // 8. Known conflict penalty
  if (conflict) {
    checks.push({ name:"Known Conflict", pass:false, severity:conflict.severity,
      detail: `âœ— ${conflict.reason} (violates principle ${conflict.violation})` });
  }

  const total = checks.length;
  const score = checks.reduce((s,c) => s + (c.severity === "ok" ? 1 : c.severity === "warn" ? 0.5 : 0), 0) / total;
  return { score, checks, synergy: !!synergy, conflict: !!conflict };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FEED INFRASTRUCTURE â€” generators, detection, recommendations
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function gaussianRandom() {
  let u = 0, v = 0;
  while (u === 0) u = Math.random();
  while (v === 0) v = Math.random();
  return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
}

function generateRandomWalk(n=365, drift=0.001, vol=0.02) {
  const data = [100];
  for (let i = 1; i < n; i++) data.push(data[i-1] * (1 + drift + vol * gaussianRandom()));
  return data;
}

function generateSeasonal(n=365, period=7, amplitude=10, trend=0.05, noiseStd=2) {
  return Array.from({length:n}, (_, i) =>
    50 + trend * i + amplitude * Math.sin(2 * Math.PI * i / period) + noiseStd * gaussianRandom()
  );
}

function generateRegimeSwitching(n=500, p01=0.02, p10=0.03) {
  let regime = 0;
  const data = [100];
  for (let i = 1; i < n; i++) {
    if (regime === 0 && Math.random() < p01) regime = 1;
    else if (regime === 1 && Math.random() < p10) regime = 0;
    const vol = regime === 0 ? 0.008 : 0.035;
    const drift = regime === 0 ? 0.0005 : -0.001;
    data.push(data[i-1] * (1 + drift + vol * gaussianRandom()));
  }
  return data;
}

function generateMeanReverting(n=365, mean=100, speed=0.05, vol=3) {
  const data = [mean + (Math.random() - 0.5) * 20];
  for (let i = 1; i < n; i++) data.push(data[i-1] + speed * (mean - data[i-1]) + vol * gaussianRandom());
  return data;
}

function generateEventDriven(n=365, baseRate=0.1, excitement=0.3, decay=0.95) {
  const intensity = [baseRate];
  const events = [];
  const data = [0];
  for (let i = 1; i < n; i++) {
    if (Math.random() < intensity[i-1]) {
      events.push(i);
      data.push(data[i-1] + 1 + Math.random() * 3);
    } else {
      data.push(data[i-1] * 0.995);
    }
    let lambda = baseRate;
    events.forEach(e => { lambda += excitement * Math.pow(decay, i - e); });
    intensity.push(Math.min(lambda, 0.95));
  }
  return data;
}

function generateHighFreqNoise(n=1000, signalFreq=0.01, snr=0.3) {
  return Array.from({length:n}, (_, i) =>
    snr * Math.sin(2 * Math.PI * signalFreq * i) + (1 - snr) * gaussianRandom()
  );
}

function generateMultiSeasonal(n=730, periods=[7,30,365], amps=[5,8,15], trend=0.02, noise=2) {
  return Array.from({length:n}, (_, i) => {
    let v = 40 + trend * i;
    periods.forEach((p,j) => { v += (amps[j]||5) * Math.sin(2 * Math.PI * i / p); });
    return v + noise * gaussianRandom();
  });
}

function generateLevelShift(n=365, shiftAt=180, shiftSize=20, vol=2) {
  return Array.from({length:n}, (_, i) =>
    50 + (i >= shiftAt ? shiftSize : 0) + vol * gaussianRandom()
  );
}

// â”€â”€â”€ Characteristic Detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function detectCharacteristics(data) {
  const n = data.length;
  if (n < 10) return { error:"Too few data points", n };

  const mean = data.reduce((s,v) => s + v, 0) / n;
  const std = Math.sqrt(data.reduce((s,v) => s + (v - mean) ** 2, 0) / n);

  // Linear regression slope
  const xMean = (n - 1) / 2;
  let num = 0, den = 0;
  for (let i = 0; i < n; i++) { num += (i - xMean) * (data[i] - mean); den += (i - xMean) ** 2; }
  const slope = den > 0 ? num / den : 0;
  const trendStrength = Math.abs(slope * n / (std + 1e-10));
  const hasTrend = trendStrength > 0.5;

  // Autocorrelation function
  function autocorr(lag) {
    let nm = 0, dn = 0;
    for (let i = 0; i < n; i++) dn += (data[i] - mean) ** 2;
    for (let i = lag; i < n; i++) nm += (data[i] - mean) * (data[i - lag] - mean);
    return dn > 0 ? nm / dn : 0;
  }

  // Check seasonal periods
  const seasonalLags = [4, 5, 7, 12, 24, 30, 52, 60, 90, 168, 365].filter(l => l < n / 3);
  const acfs = seasonalLags.map(l => ({ lag: l, acf: autocorr(l) }));
  const bestSeasonal = acfs.reduce((a, b) => Math.abs(b.acf) > Math.abs(a.acf) ? b : a, { lag: 0, acf: 0 });
  const hasSeasonality = Math.abs(bestSeasonal.acf) > 0.25;

  // Stationarity proxy (split-half)
  const half = Math.floor(n / 2);
  const mean1 = data.slice(0, half).reduce((s, v) => s + v, 0) / half;
  const mean2 = data.slice(half).reduce((s, v) => s + v, 0) / (n - half);
  const var1 = data.slice(0, half).reduce((s, v) => s + (v - mean1) ** 2, 0) / half;
  const var2 = data.slice(half).reduce((s, v) => s + (v - mean2) ** 2, 0) / (n - half);
  const meanShift = Math.abs(mean2 - mean1) / (std + 1e-10);
  const varRatio = Math.max(var1, var2) / (Math.min(var1, var2) + 1e-10);
  const isStationary = meanShift < 0.5 && varRatio < 2;

  // Volatility clustering (squared return autocorrelation)
  const returns = [];
  for (let i = 1; i < n; i++) returns.push(data[i] - data[i - 1]);
  const retMean = returns.reduce((s, v) => s + v, 0) / returns.length;
  const retStd = Math.sqrt(returns.reduce((s, v) => s + (v - retMean) ** 2, 0) / returns.length);
  const sqReturns = returns.map(r => r * r);
  const sqMean = sqReturns.reduce((s, v) => s + v, 0) / sqReturns.length;
  let vcNum = 0, vcDen = 0;
  for (let i = 0; i < sqReturns.length; i++) vcDen += (sqReturns[i] - sqMean) ** 2;
  for (let i = 1; i < sqReturns.length; i++) vcNum += (sqReturns[i] - sqMean) * (sqReturns[i - 1] - sqMean);
  const volAutocorr = vcDen > 0 ? vcNum / vcDen : 0;
  const hasVolClustering = volAutocorr > 0.15;

  // Noise level
  const noiseRatio = std / (Math.abs(mean) + 1e-10);
  const noiseLevel = noiseRatio > 0.5 ? "high" : noiseRatio > 0.1 ? "medium" : "low";

  // Skewness & kurtosis
  const skew = data.reduce((s, v) => s + ((v - mean) / (std + 1e-10)) ** 3, 0) / n;
  const kurt = data.reduce((s, v) => s + ((v - mean) / (std + 1e-10)) ** 4, 0) / n - 3;

  // Lag-1 autocorrelation (persistence)
  const lag1 = autocorr(1);

  // Min, max, range
  const min = Math.min(...data);
  const max = Math.max(...data);

  return {
    n, mean, std, min, max, slope,
    hasTrend, trendStrength, trendDirection: slope > 0 ? "up" : "down",
    hasSeasonality, seasonalPeriod: bestSeasonal.lag, seasonalStrength: Math.abs(bestSeasonal.acf),
    isStationary, meanShift, varRatio,
    hasVolClustering, volAutocorr,
    noiseLevel, noiseRatio,
    skewness: skew, kurtosis: kurt,
    lag1Autocorr: lag1,
    allAcfs: acfs,
    retMean, retStd,
  };
}

// â”€â”€â”€ Technique & Pipeline Recommendation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function recommendTechniques(chars) {
  const recs = [];
  recs.push({ id: "naive", reason: "Universal baseline", priority: 1 });
  recs.push({ id: "conformal", reason: "Distribution-free prediction intervals", priority: 2 });

  if (chars.hasSeasonality) {
    recs.push({ id: "seasonal_naive", reason: `Seasonal pattern (periodâ‰ˆ${chars.seasonalPeriod}, acf=${chars.seasonalStrength.toFixed(2)})`, priority: 1 });
    recs.push({ id: "stl", reason: "Decompose seasonal structure before modeling", priority: 2 });
    recs.push({ id: "sarima", reason: "Seasonal ARIMA for periodic series", priority: 2 });
    recs.push({ id: "ets", reason: "ETS handles seasonal components natively", priority: 2 });
    recs.push({ id: "prophet", reason: "Multiple seasonalities + holidays", priority: 3 });
    recs.push({ id: "x13", reason: "Official seasonal adjustment with calendar effects", priority: 3 });
  }

  if (chars.hasTrend) {
    recs.push({ id: "arima", reason: `Trend detected (slope=${chars.slope.toFixed(4)}, strength=${chars.trendStrength.toFixed(2)})`, priority: 2 });
    recs.push({ id: "theta", reason: "Theta excels at trended short series", priority: 2 });
    if (!chars.hasSeasonality) recs.push({ id: "ets", reason: "ETS trend component", priority: 2 });
    recs.push({ id: "structural_ts", reason: "State-space trend decomposition", priority: 3 });
  }

  if (chars.hasVolClustering) {
    recs.push({ id: "garch", reason: `Volatility clustering (vol_acf=${chars.volAutocorr.toFixed(2)})`, priority: 2 });
    recs.push({ id: "ewma", reason: "Adaptive level tracking for volatile series", priority: 2 });
    recs.push({ id: "hmm", reason: "Regime detection for volatility states", priority: 3 });
    recs.push({ id: "quantile_reg", reason: "Quantile estimation for heteroskedastic risk", priority: 3 });
  }

  if (!chars.isStationary) {
    recs.push({ id: "stl", reason: `Non-stationary (mean_shift=${chars.meanShift.toFixed(2)}, var_ratio=${chars.varRatio.toFixed(2)})`, priority: 2 });
    recs.push({ id: "kalman", reason: "Kalman filter for non-stationary state tracking", priority: 3 });
  }

  if (chars.isStationary && !chars.hasTrend && !chars.hasSeasonality) {
    recs.push({ id: "arima", reason: "Stationary ARIMA (low d) for autocorrelated residuals", priority: 2 });
    recs.push({ id: "var", reason: "VAR if multivariate context available", priority: 3 });
    recs.push({ id: "gp", reason: "GP regression with stationary kernel", priority: 3 });
  }

  if (chars.n > 500) {
    recs.push({ id: "lstm", reason: `Sufficient data (n=${chars.n}) for sequence learning`, priority: 3 });
    recs.push({ id: "transformer", reason: "Attention for long-range dependencies", priority: 3 });
    recs.push({ id: "tft", reason: "TFT with variable selection", priority: 3 });
    recs.push({ id: "nbeats", reason: "N-BEATS interpretable deep forecasting", priority: 3 });
    recs.push({ id: "deepar", reason: "Probabilistic deep autoregression", priority: 3 });
  } else if (chars.n > 200) {
    recs.push({ id: "gbt", reason: `Moderate data (n=${chars.n}) â€” tree models feasible`, priority: 3 });
    recs.push({ id: "rf", reason: "Random forest with lag features", priority: 3 });
  }

  if (chars.noiseLevel === "high") {
    recs.push({ id: "moving_avg", reason: `High noise (ratio=${chars.noiseRatio.toFixed(2)}) â€” smoothing recommended`, priority: 2 });
    recs.push({ id: "kalman", reason: "Kalman filtering for noisy observations", priority: 3 });
    recs.push({ id: "gp", reason: "GP posterior mean is a denoiser", priority: 3 });
  }

  if (Math.abs(chars.kurtosis) > 3) {
    recs.push({ id: "garch", reason: `Heavy tails (kurtosis=${chars.kurtosis.toFixed(1)})`, priority: 3 });
    recs.push({ id: "quantile_reg", reason: "Quantile regression for fat-tailed distributions", priority: 3 });
  }

  if (chars.lag1Autocorr > 0.8) {
    recs.push({ id: "ewma", reason: `High persistence (lag1_acf=${chars.lag1Autocorr.toFixed(2)})`, priority: 2 });
  }

  // Deduplicate by id, keeping highest priority
  const seen = {};
  return recs.filter(r => { if (seen[r.id]) return false; seen[r.id] = true; return true; })
    .sort((a, b) => a.priority - b.priority);
}

function recommendPipelines(chars) {
  return CANONICAL_PIPELINES.filter(p => {
    if (p.archetype === "any") return true;
    if (p.archetype === "seasonal" && chars.hasSeasonality) return true;
    if (p.archetype === "trending" && chars.hasTrend) return true;
    if (p.archetype === "regime_switching" && chars.hasVolClustering) return true;
    if (p.archetype === "mean_reverting" && chars.isStationary && !chars.hasTrend) return true;
    if (p.archetype === "high_freq_noise" && chars.noiseLevel === "high") return true;
    if (p.archetype === "event_driven" && !chars.isStationary && !chars.hasTrend) return true;
    return false;
  });
}

// â”€â”€â”€ Feed Definitions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FEED MANAGER â€” caching, rate limiting, circuit breakers, metering
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const FeedManager = (() => {
  const cache = new Map();       // url -> { data, timestamp, ttl }
  const metrics = new Map();     // url -> { hits, misses, errors, totalMs, lastFetch, bytesTotal }
  const breakers = new Map();    // url -> { failures, state:'closed'|'open'|'half-open', openedAt }
  const queue = [];              // pending fetch queue
  let inflight = 0;
  const MAX_CONCURRENT = 3;
  const DEFAULT_TTL = 5 * 60 * 1000;  // 5 min cache
  const BREAKER_THRESHOLD = 3;        // failures before open
  const BREAKER_COOLDOWN = 60 * 1000; // 1 min before half-open
  const RATE_WINDOW = 10 * 1000;      // 10s rate window
  const MAX_REQUESTS_PER_WINDOW = 6;
  const recentRequests = [];           // timestamps of recent requests
  const listeners = new Set();         // state change listeners

  function emit() { listeners.forEach(fn => { try{fn()}catch(e){} }); }

  function getMetrics(url) {
    if (!metrics.has(url)) metrics.set(url, { hits:0, misses:0, errors:0, totalMs:0, lastFetch:null, bytesTotal:0, lastLatency:0 });
    return metrics.get(url);
  }

  function getBreaker(url) {
    if (!breakers.has(url)) breakers.set(url, { failures:0, state:"closed", openedAt:0 });
    return breakers.get(url);
  }

  function checkRateLimit() {
    const now = Date.now();
    while (recentRequests.length > 0 && now - recentRequests[0] > RATE_WINDOW) recentRequests.shift();
    return recentRequests.length < MAX_REQUESTS_PER_WINDOW;
  }

  function processQueue() {
    while (queue.length > 0 && inflight < MAX_CONCURRENT && checkRateLimit()) {
      const { url, feed, resolve, reject } = queue.shift();
      inflight++;
      recentRequests.push(Date.now());
      doFetch(url, feed).then(resolve).catch(reject).finally(() => { inflight--; processQueue(); });
    }
    emit();
  }

  async function doFetch(url, feed) {
    const m = getMetrics(url);
    const b = getBreaker(url);
    const t0 = performance.now();

    // Circuit breaker check
    if (b.state === "open") {
      if (Date.now() - b.openedAt > BREAKER_COOLDOWN) {
        b.state = "half-open";
      } else {
        m.errors++;
        emit();
        throw new Error(`Circuit open for ${feed.name} â€” too many failures. Retry in ${Math.ceil((BREAKER_COOLDOWN - (Date.now() - b.openedAt))/1000)}s`);
      }
    }

    try {
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), 15000);
      const resp = await fetch(url, { signal: controller.signal });
      clearTimeout(timeout);
      if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
      const text = await resp.text();
      const json = JSON.parse(text);
      const parsed = feed.parse(json);
      const values = parsed.values.filter(v => v != null && isFinite(v));
      if (values.length < 10) throw new Error(`Only ${values.length} valid points (need â‰¥10)`);

      const latency = performance.now() - t0;
      m.misses++;
      m.totalMs += latency;
      m.lastFetch = Date.now();
      m.lastLatency = latency;
      m.bytesTotal += text.length;

      // Success â€” reset breaker
      b.failures = 0;
      b.state = "closed";

      // Cache the result
      const result = { values, name: parsed.name || feed.name, raw: json };
      cache.set(url, { data: result, timestamp: Date.now(), ttl: DEFAULT_TTL });
      emit();
      return result;
    } catch (e) {
      const latency = performance.now() - t0;
      m.errors++;
      m.totalMs += latency;
      m.lastLatency = latency;
      b.failures++;
      if (b.failures >= BREAKER_THRESHOLD) {
        b.state = "open";
        b.openedAt = Date.now();
      }
      emit();
      throw e;
    }
  }

  return {
    // Main fetch method â€” checks cache, rate limit, circuit breaker, queues
    async fetch(feed, { forceFresh = false } = {}) {
      const url = feed.url;
      const m = getMetrics(url);

      // Check cache
      if (!forceFresh && cache.has(url)) {
        const cached = cache.get(url);
        if (Date.now() - cached.timestamp < cached.ttl) {
          m.hits++;
          emit();
          return { ...cached.data, fromCache: true, age: Date.now() - cached.timestamp };
        }
      }

      // Queue the fetch
      return new Promise((resolve, reject) => {
        queue.push({ url, feed, resolve, reject });
        processQueue();
      });
    },

    // Get cache entry without fetching
    getCached(feed) {
      const entry = cache.get(feed.url);
      if (entry && Date.now() - entry.timestamp < entry.ttl) return { ...entry.data, age: Date.now() - entry.timestamp };
      return null;
    },

    // Invalidate cache for a feed
    invalidate(feed) { cache.delete(feed.url); emit(); },

    // Get diagnostic snapshot
    getDiagnostics() {
      const diag = { feeds: [], totals: { hits:0, misses:0, errors:0, cached:0, avgLatency:0 }, inflight, queued: queue.length };
      let totalLatency = 0, totalFetches = 0;
      for (const [url, m] of metrics) {
        const b = getBreaker(url);
        const isCached = cache.has(url) && Date.now() - cache.get(url).timestamp < cache.get(url).ttl;
        const feedName = LIVE_FEEDS.find(f => f.url === url)?.name || url.slice(0,40);
        diag.feeds.push({
          name: feedName, url,
          hits: m.hits, misses: m.misses, errors: m.errors,
          lastLatency: m.lastLatency, avgLatency: (m.misses+m.errors)>0 ? m.totalMs/(m.misses+m.errors) : 0,
          bytesTotal: m.bytesTotal, lastFetch: m.lastFetch,
          cached: isCached, cacheAge: isCached ? Date.now() - cache.get(url).timestamp : null,
          breaker: b.state, failures: b.failures,
        });
        diag.totals.hits += m.hits;
        diag.totals.misses += m.misses;
        diag.totals.errors += m.errors;
        if (isCached) diag.totals.cached++;
        totalLatency += m.totalMs;
        totalFetches += m.misses + m.errors;
      }
      diag.totals.avgLatency = totalFetches > 0 ? totalLatency / totalFetches : 0;
      diag.rateWindow = { recent: recentRequests.filter(t => Date.now()-t < RATE_WINDOW).length, max: MAX_REQUESTS_PER_WINDOW };
      return diag;
    },

    // Subscribe to state changes
    subscribe(fn) { listeners.add(fn); return () => listeners.delete(fn); },

    // Prefetch a batch of feeds
    async prefetch(feeds) {
      return Promise.allSettled(feeds.map(f => this.fetch(f)));
    },

    // Config
    config: { MAX_CONCURRENT, DEFAULT_TTL, BREAKER_THRESHOLD, BREAKER_COOLDOWN, RATE_WINDOW, MAX_REQUESTS_PER_WINDOW },
  };
})();

const LIVE_FEEDS = [
  { id:"weather_berlin", name:"Berlin Temperature", category:"weather", archetype:"seasonal",
    description:"Hourly temperature (past 90 days) â€” strong daily + seasonal cycles",
    url:"https://api.open-meteo.com/v1/forecast?latitude=52.52&longitude=13.41&hourly=temperature_2m&past_days=90&forecast_days=0",
    parse: d => ({ values: d.hourly.temperature_2m.filter(v => v !== null), name:"Berlin Â°C" }) },
  { id:"weather_nyc", name:"NYC Temperature", category:"weather", archetype:"seasonal",
    description:"Hourly temperature (past 90 days) â€” continental seasonal pattern",
    url:"https://api.open-meteo.com/v1/forecast?latitude=40.71&longitude=-74.01&hourly=temperature_2m&past_days=90&forecast_days=0",
    parse: d => ({ values: d.hourly.temperature_2m.filter(v => v !== null), name:"NYC Â°C" }) },
  { id:"weather_tokyo", name:"Tokyo Temperature", category:"weather", archetype:"seasonal",
    description:"Hourly temperature (past 90 days) â€” maritime seasonal with typhoon noise",
    url:"https://api.open-meteo.com/v1/forecast?latitude=35.68&longitude=139.69&hourly=temperature_2m&past_days=90&forecast_days=0",
    parse: d => ({ values: d.hourly.temperature_2m.filter(v => v !== null), name:"Tokyo Â°C" }) },
  { id:"weather_sydney", name:"Sydney Temperature", category:"weather", archetype:"seasonal",
    description:"Hourly temperature (past 90 days) â€” southern hemisphere, inverse seasonality",
    url:"https://api.open-meteo.com/v1/forecast?latitude=-33.87&longitude=151.21&hourly=temperature_2m&past_days=90&forecast_days=0",
    parse: d => ({ values: d.hourly.temperature_2m.filter(v => v !== null), name:"Sydney Â°C" }) },
  { id:"weather_wind_berlin", name:"Berlin Wind Speed", category:"weather", archetype:"high_freq_noise",
    description:"Hourly wind speed (past 90 days) â€” noisy, bursty, non-negative",
    url:"https://api.open-meteo.com/v1/forecast?latitude=52.52&longitude=13.41&hourly=wind_speed_10m&past_days=90&forecast_days=0",
    parse: d => ({ values: d.hourly.wind_speed_10m.filter(v => v !== null), name:"Berlin Wind km/h" }) },
  { id:"weather_rain_london", name:"London Precipitation", category:"weather", archetype:"event_driven",
    description:"Hourly precipitation (past 90 days) â€” intermittent, zero-inflated",
    url:"https://api.open-meteo.com/v1/forecast?latitude=51.51&longitude=-0.13&hourly=precipitation&past_days=90&forecast_days=0",
    parse: d => ({ values: d.hourly.precipitation.filter(v => v !== null), name:"London Rain mm" }) },
  { id:"weather_humidity_mumbai", name:"Mumbai Humidity", category:"weather", archetype:"seasonal",
    description:"Hourly relative humidity (past 90 days) â€” monsoon seasonality",
    url:"https://api.open-meteo.com/v1/forecast?latitude=19.08&longitude=72.88&hourly=relative_humidity_2m&past_days=90&forecast_days=0",
    parse: d => ({ values: d.hourly.relative_humidity_2m.filter(v => v !== null), name:"Mumbai RH %" }) },
  { id:"weather_pressure_iceland", name:"Reykjavik Pressure", category:"weather", archetype:"mean_reverting",
    description:"Hourly surface pressure (past 90 days) â€” mean-reverting with weather systems",
    url:"https://api.open-meteo.com/v1/forecast?latitude=64.15&longitude=-21.95&hourly=surface_pressure&past_days=90&forecast_days=0",
    parse: d => ({ values: d.hourly.surface_pressure.filter(v => v !== null), name:"Reykjavik hPa" }) },
  { id:"bitcoin", name:"Bitcoin / USD", category:"crypto", archetype:"regime_switching",
    description:"90-day price history â€” volatility clustering, regime shifts, fat tails",
    url:"https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=usd&days=90",
    parse: d => ({ values: d.prices.map(p => p[1]), name:"BTC/USD" }) },
  { id:"ethereum", name:"Ethereum / USD", category:"crypto", archetype:"regime_switching",
    description:"90-day price history â€” correlated with BTC, high volatility",
    url:"https://api.coingecko.com/api/v3/coins/ethereum/market_chart?vs_currency=usd&days=90",
    parse: d => ({ values: d.prices.map(p => p[1]), name:"ETH/USD" }) },
  { id:"solana", name:"Solana / USD", category:"crypto", archetype:"regime_switching",
    description:"90-day price history â€” high beta, frequent regime switches",
    url:"https://api.coingecko.com/api/v3/coins/solana/market_chart?vs_currency=usd&days=90",
    parse: d => ({ values: d.prices.map(p => p[1]), name:"SOL/USD" }) },
];

const SYNTHETIC_FEEDS = [
  { id:"syn_trending", name:"Trending Walk", archetype:"trending",
    description:"Random walk with positive drift â€” tests trend detection and extrapolation",
    generate: () => generateRandomWalk(365, 0.002, 0.015) },
  { id:"syn_seasonal", name:"Weekly Seasonal", archetype:"seasonal",
    description:"Clear 7-day cycle + trend + noise â€” tests decomposition and seasonal models",
    generate: () => generateSeasonal(365, 7, 12, 0.03, 2) },
  { id:"syn_multi_seasonal", name:"Multi-Seasonal", archetype:"seasonal",
    description:"Daily (7) + monthly (30) + annual (365) cycles â€” tests Prophet, TFT, multi-period models",
    generate: () => generateMultiSeasonal(730) },
  { id:"syn_regime", name:"Regime Switching", archetype:"regime_switching",
    description:"Two-state HMM with different volatility â€” tests HMM, GARCH, regime-gated methods",
    generate: () => generateRegimeSwitching(500, 0.02, 0.03) },
  { id:"syn_meanrev", name:"Mean Reverting", archetype:"mean_reverting",
    description:"Ornstein-Uhlenbeck process â€” tests stationary models, VAR, spread trading",
    generate: () => generateMeanReverting(365, 100, 0.05, 3) },
  { id:"syn_events", name:"Event Cascade", archetype:"event_driven",
    description:"Self-exciting point process (Hawkes-like) â€” tests Hawkes, Cox, event-driven pipelines",
    generate: () => generateEventDriven(365, 0.1, 0.3, 0.95) },
  { id:"syn_noisy", name:"Noisy Signal", archetype:"high_freq_noise",
    description:"Weak sinusoid buried in Gaussian noise â€” tests Kalman, GP, smoothing methods",
    generate: () => generateHighFreqNoise(1000, 0.01, 0.3) },
  { id:"syn_level_shift", name:"Level Shift", archetype:"trending",
    description:"Abrupt structural break mid-series â€” tests adaptivity and change detection",
    generate: () => generateLevelShift(365, 180, 25, 2) },
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SIMULATION ENGINE â€” simplified technique transforms
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function simulateStep(techId, data) {
  const n = data.length;
  if (n < 3) return { values: data, label: "pass-through" };
  switch (techId) {
    case 'moving_avg': {
      const w = Math.max(2, Math.min(7, Math.floor(n / 20)));
      return { values: data.map((_, i) => {
        const lo = Math.max(0, i - w), hi = Math.min(n - 1, i + w);
        let s = 0; for (let j = lo; j <= hi; j++) s += data[j];
        return s / (hi - lo + 1);
      }), label: `MA(${2 * w + 1}) smoothed` };
    }
    case 'ewma': {
      const a = 0.15, r = [data[0]];
      for (let i = 1; i < n; i++) r.push(a * data[i] + (1 - a) * r[i - 1]);
      return { values: r, label: "EWMA(Î±=0.15)" };
    }
    case 'stl': case 'x13': {
      const w = Math.max(3, Math.min(14, Math.floor(n / 8)));
      const trend = data.map((_, i) => {
        const lo = Math.max(0, i - w), hi = Math.min(n - 1, i + w);
        let s = 0; for (let j = lo; j <= hi; j++) s += data[j];
        return s / (hi - lo + 1);
      });
      return { values: data.map((v, i) => v - trend[i]), label: "Residuals (trend removed)", trend };
    }
    case 'arima': case 'sarima': case 'theta': {
      return { values: data.slice(1).map((v, i) => v - data[i]), label: "Î” first-differenced" };
    }
    case 'garch': {
      const ret = data.slice(1).map((v, i) => v - data[i]);
      const sq = ret.map(r => r * r);
      const a = 0.06, vol = [Math.sqrt(sq[0])];
      for (let i = 1; i < sq.length; i++) vol.push(Math.sqrt(a * sq[i] + (1 - a) * vol[i - 1] * vol[i - 1]));
      return { values: vol, label: "Ïƒ GARCH volatility" };
    }
    case 'var': {
      const a = 0.2, r = [data[0]];
      for (let i = 1; i < n; i++) r.push(a * data[i] + (1 - a) * r[i - 1]);
      return { values: r, label: "VAR fitted" };
    }
    case 'kalman': {
      let x = data[0], P = 1; const Q = 0.01, R = 1, out = [x];
      for (let i = 1; i < n; i++) {
        const Pp = P + Q, K = Pp / (Pp + R);
        x = x + K * (data[i] - x); P = (1 - K) * Pp; out.push(x);
      }
      return { values: out, label: "Kalman filtered" };
    }
    case 'structural_ts': case 'bsts': case 'prophet': {
      const w = Math.max(5, Math.min(20, Math.floor(n / 10)));
      const trend = data.map((_, i) => {
        const lo = Math.max(0, i - w), hi = Math.min(n - 1, i + w);
        let s = 0; for (let j = lo; j <= hi; j++) s += data[j];
        return s / (hi - lo + 1);
      });
      return { values: trend, label: "Structural trend estimate" };
    }
    case 'hmm': {
      const w = Math.max(5, Math.min(30, Math.floor(n / 10)));
      const vol = data.map((_, i) => {
        const lo = Math.max(0, i - w), sl = data.slice(lo, i + 1);
        const m = sl.reduce((s, v) => s + v, 0) / sl.length;
        return Math.sqrt(sl.reduce((s, v) => s + (v - m) ** 2, 0) / sl.length);
      });
      const med = [...vol].sort((a, b) => a - b)[Math.floor(vol.length / 2)];
      return { values: vol.map(v => v > med * 1.2 ? 1 : 0), label: "Regime (0=calm 1=volatile)" };
    }
    case 'conformal': {
      const mean = data.reduce((s, v) => s + v, 0) / n;
      const std = Math.sqrt(data.reduce((s, v) => s + (v - mean) ** 2, 0) / n);
      return { values: data, label: `Â±${(std * 1.96).toFixed(2)} conformal band`, band: std * 1.96 };
    }
    case 'quantile_reg': {
      const w = Math.max(5, Math.min(30, Math.floor(n / 8)));
      const lo = data.map((_, i) => {
        const sl = [...data.slice(Math.max(0, i - w), i + 1)].sort((a, b) => a - b);
        return sl[Math.floor(sl.length * 0.1)];
      });
      const hi = data.map((_, i) => {
        const sl = [...data.slice(Math.max(0, i - w), i + 1)].sort((a, b) => a - b);
        return sl[Math.floor(sl.length * 0.9)];
      });
      return { values: data, label: "Q10â€“Q90 risk bands", bands: { lo, hi } };
    }
    case 'late_fusion': case 'model_avg': case 'stacking': {
      const a = 0.2, r = [data[0]];
      for (let i = 1; i < n; i++) r.push(a * data[i] + (1 - a) * r[i - 1]);
      return { values: data.map((v, i) => (v + r[i]) / 2), label: "Ensemble combination" };
    }
    default: {
      const a = 0.25, r = [data[0]];
      for (let i = 1; i < n; i++) r.push(a * data[i] + (1 - a) * r[i - 1]);
      return { values: r, label: `${techId} output (smoothed)` };
    }
  }
}

function percolatePipeline(rawData, steps) {
  const stages = [{ techId: '_input', values: rawData, label: 'Raw Feed' }];
  let current = [...rawData];
  steps.forEach(stepId => {
    const result = simulateStep(stepId, current);
    stages.push({ techId: stepId, values: result.values, label: result.label, band: result.band, bands: result.bands, trend: result.trend });
    current = result.values.filter(v => typeof v === 'number' && isFinite(v));
    if (current.length < 3) current = rawData; // fallback
  });
  return stages;
}

// â”€â”€â”€ Path Discovery â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function findSynergyPaths(startId, maxDepth = 5) {
  const paths = [];
  const startTech = TECHNIQUES.find(t => t.id === startId);
  if (!startTech) return paths;
  function dfs(currentId, path, currentRole) {
    if (path.length >= 2) paths.push([...path]);
    if (path.length >= maxDepth) return;
    KNOWN_SYNERGIES.forEach(s => {
      if (s.from === currentId) {
        const t = TECHNIQUES.find(x => x.id === s.to);
        if (!t || path.includes(s.to)) return;
        const role = ROLE_ORDER[t.pipelineRole] ?? 2;
        if (role >= currentRole) dfs(s.to, [...path, s.to], role);
      }
    });
  }
  dfs(startId, [startId], ROLE_ORDER[startTech.pipelineRole] ?? 2);
  return paths.map(p => {
    let total = 0, pairs = 0;
    for (let i = 0; i < p.length - 1; i++) {
      const a = TECHNIQUES.find(t => t.id === p[i]), b = TECHNIQUES.find(t => t.id === p[i + 1]);
      if (a && b) { total += checkComposition(a, b).score; pairs++; }
    }
    return { steps: p, score: pairs > 0 ? total / pairs : 0, length: p.length };
  }).sort((a, b) => b.score - a.score || b.length - a.length);
}

// â”€â”€â”€ Graph Layout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const GRAPH_COL_DEFS = [
  { x: 55, label: "TRANSFORM" },
  { x: 175, label: "FEATURE" },
  { x: 305, label: "BASE / STAT" },
  { x: 450, label: "STATE / ML" },
  { x: 600, label: "DEEP / PROB" },
  { x: 775, label: "CALIBRATE" },
  { x: 935, label: "DECIDE" },
];

const NODE_COL = {
  moving_avg:0, stl:0, x13:0,
  hmm:1,
  naive:2, seasonal_naive:2, ewma:2, arima:2, sarima:2, ets:2, var:2, garch:2, theta:2,
  kalman:3, structural_ts:3, prophet:3, gbt:3, rf:3, svr:3, regime_logistic:3, hawkes:3, cox:3,
  lstm:4, gru:4, transformer:4, nbeats:4, tft:4, deepar:4, bsts:4, gp:4,
  quantile_reg:5, conformal:5,
  late_fusion:6, stacking:6, model_avg:6,
};

function computeNodePositions(H) {
  const cols = {};
  TECHNIQUES.forEach(t => {
    const c = NODE_COL[t.id]; if (c === undefined) return;
    if (!cols[c]) cols[c] = [];
    cols[c].push(t);
  });
  const pos = {};
  Object.entries(cols).forEach(([c, techs]) => {
    const ci = parseInt(c);
    const x = GRAPH_COL_DEFS[ci].x;
    const sp = Math.min(56, (H - 80) / (techs.length + 1));
    const startY = (H - sp * (techs.length - 1)) / 2;
    techs.forEach((t, i) => { pos[t.id] = { x, y: startY + i * sp }; });
  });
  return pos;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CAUSAL INFERENCE ENGINE â€” Granger + Kernel + HSIC
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function grangerTest(x, y, lags = 5) {
  const n = Math.min(x.length, y.length) - lags;
  if (n < lags * 3) return { reduction: 0, fStat: 0, detail: "Insufficient data" };
  const target = [], featR = [], featU = [];
  for (let t = lags; t < lags + n; t++) {
    target.push(x[t]);
    const xL = [], xyL = [];
    for (let l = 1; l <= lags; l++) { xL.push(x[t - l]); xyL.push(x[t - l]); }
    for (let l = 1; l <= lags; l++) { xyL.push(y[t - l]); }
    featR.push(xL); featU.push(xyL);
  }
  function olsRSS(tgt, feat) {
    const m = tgt.length, p = feat[0].length;
    const A = Array.from({ length: p }, () => new Array(p + 1).fill(0));
    for (let i = 0; i < m; i++) for (let j = 0; j < p; j++) {
      A[j][p] += feat[i][j] * tgt[i];
      for (let k = j; k < p; k++) { A[j][k] += feat[i][j] * feat[i][k]; if (k > j) A[k][j] = A[j][k]; }
    }
    for (let j = 0; j < p; j++) A[j][j] += 1e-6;
    for (let i = 0; i < p; i++) {
      let mx = i; for (let j = i + 1; j < p; j++) if (Math.abs(A[j][i]) > Math.abs(A[mx][i])) mx = j;
      [A[i], A[mx]] = [A[mx], A[i]]; if (Math.abs(A[i][i]) < 1e-12) continue;
      for (let j = i + 1; j < p; j++) { const f = A[j][i] / A[i][i]; for (let k = i; k <= p; k++) A[j][k] -= f * A[i][k]; }
    }
    const beta = new Array(p).fill(0);
    for (let i = p - 1; i >= 0; i--) { beta[i] = A[i][p]; for (let j = i + 1; j < p; j++) beta[i] -= A[i][j] * beta[j]; beta[i] /= A[i][i] || 1; }
    let rss = 0;
    for (let i = 0; i < m; i++) { let pred = 0; for (let j = 0; j < p; j++) pred += feat[i][j] * beta[j]; rss += (tgt[i] - pred) ** 2; }
    return rss / m;
  }
  const rssR = olsRSS(target, featR), rssU = olsRSS(target, featU);
  const reduction = rssR > 0 ? 1 - rssU / rssR : 0;
  const fStat = lags > 0 ? ((rssR - rssU) / lags) / (rssU / Math.max(1, n - 2 * lags - 1)) : 0;
  return { reduction, fStat, rssR, rssU, n };
}

function kernelGrangerTest(x, y, lags = 5) {
  const n = Math.min(x.length, y.length) - lags;
  const maxN = Math.min(n, 150);
  const step = Math.max(1, Math.floor(n / maxN));
  const target = [], featX = [], featXY = [];
  for (let t = lags; t < lags + n; t += step) {
    target.push(x[t]);
    const xL = [], xyL = [];
    for (let l = 1; l <= lags; l++) { xL.push(x[t - l]); xyL.push(x[t - l]); }
    for (let l = 1; l <= lags; l++) { xyL.push(y[t - l]); }
    featX.push(xL); featXY.push(xyL);
  }
  // Median heuristic for bandwidth
  const dists = [];
  for (let i = 0; i < Math.min(80, featX.length); i++)
    for (let j = i + 1; j < Math.min(80, featX.length); j++) {
      let d = 0; for (let k = 0; k < featX[i].length; k++) d += (featX[i][k] - featX[j][k]) ** 2;
      dists.push(Math.sqrt(d));
    }
  dists.sort((a, b) => a - b);
  const sigma = dists[Math.floor(dists.length / 2)] || 1;
  const m = target.length, lam = 1e-3;

  function krr(feats) {
    const K = Array.from({ length: m }, (_, i) => {
      const row = new Array(m);
      for (let j = 0; j < m; j++) {
        let sq = 0; for (let d = 0; d < feats[i].length; d++) sq += (feats[i][d] - feats[j][d]) ** 2;
        row[j] = Math.exp(-sq / (2 * sigma * sigma)) + (i === j ? lam : 0);
      }
      return row;
    });
    const A = K.map((row, i) => [...row, target[i]]);
    for (let i = 0; i < m; i++) {
      let mx = i; for (let j = i + 1; j < m; j++) if (Math.abs(A[j][i]) > Math.abs(A[mx][i])) mx = j;
      [A[i], A[mx]] = [A[mx], A[i]]; if (Math.abs(A[i][i]) < 1e-12) continue;
      for (let j = i + 1; j < m; j++) { const f = A[j][i] / A[i][i]; for (let k = i; k <= m; k++) A[j][k] -= f * A[i][k]; }
    }
    const alpha = new Array(m).fill(0);
    for (let i = m - 1; i >= 0; i--) { alpha[i] = A[i][m]; for (let j = i + 1; j < m; j++) alpha[i] -= A[i][j] * alpha[j]; alpha[i] /= A[i][i] || 1; }
    let rss = 0;
    for (let i = 0; i < m; i++) {
      let pred = 0;
      for (let j = 0; j < m; j++) {
        let sq = 0; for (let d = 0; d < feats[i].length; d++) sq += (feats[i][d] - feats[j][d]) ** 2;
        pred += alpha[j] * Math.exp(-sq / (2 * sigma * sigma));
      }
      rss += (target[i] - pred) ** 2;
    }
    return rss / m;
  }
  const rssR = krr(featX), rssU = krr(featXY);
  const reduction = rssR > 0 ? 1 - rssU / rssR : 0;
  return { reduction, rssR, rssU, n: m, sigma };
}

function hsicTest(x, y) {
  const n = Math.min(x.length, y.length, 200);
  const xs = x.slice(0, n), ys = y.slice(0, n);
  const dists = [];
  for (let i = 0; i < Math.min(60, n); i++)
    for (let j = i + 1; j < Math.min(60, n); j++) dists.push(Math.abs(xs[i] - xs[j]));
  dists.sort((a, b) => a - b);
  const sigma = dists[Math.floor(dists.length / 2)] || 1;
  const s2 = 2 * sigma * sigma;
  let trKL = 0, totalK = 0, totalL = 0;
  const Kcol = new Array(n).fill(0), Lcol = new Array(n).fill(0);
  for (let i = 0; i < n; i++) for (let j = 0; j < n; j++) {
    const kij = Math.exp(-(xs[i] - xs[j]) ** 2 / s2);
    const lij = Math.exp(-(ys[i] - ys[j]) ** 2 / s2);
    trKL += kij * lij; totalK += kij; totalL += lij; Kcol[j] += kij; Lcol[j] += lij;
  }
  let sumKL1 = 0;
  for (let j = 0; j < n; j++) sumKL1 += Kcol[j] * Lcol[j];
  const hsic = (1 / (n * n)) * (trKL - (2 / n) * sumKL1 + (1 / (n * n)) * totalK * totalL);
  return { hsic, n, sigma };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REUSED COMPONENTS (from init)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function Chip({ level, children, style: sx, onClick }) {
  const c = level ? lc(level) : null;
  return (
    <span onClick={onClick} style={{
      display:"inline-flex", alignItems:"center", gap:"0.35em",
      fontFamily:T.mono, fontSize:T.fs.xs, fontWeight:500,
      padding:"0.25em 0.65em", borderRadius:T.rSm,
      border:`1px solid ${c ? `${c.base}44` : T.border1}`,
      background: c ? c.dim : T.bg2, color: c ? c.base : T.text1,
      whiteSpace:"nowrap", cursor: onClick ? "pointer" : "default", ...sx,
    }}>
      {c && <span style={{ width:6, height:6, borderRadius:"50%", background:c.base, boxShadow:`0 0 6px ${c.base}`, flexShrink:0 }} />}
      {children || (level ? c.label : "")}
    </span>
  );
}

function Badge({ children, color = T.crimson }) {
  return (
    <span style={{
      display:"inline-flex", alignItems:"center", justifyContent:"center",
      minWidth:20, height:20, fontFamily:T.mono, fontSize:T.fs.xs,
      fontWeight:600, padding:"0 5px", borderRadius:T.rPill,
      background:color, color: [T.yellow,T.teal,T.green].includes(color) ? "#0a1a10" : "#fff",
    }}>{children}</span>
  );
}

function StatusDot({ color, pulse, size = 8 }) {
  return (
    <span style={{ width:size, height:size, borderRadius:"50%", background:color, display:"inline-block", position:"relative", flexShrink:0 }}>
      {pulse && <span style={{ position:"absolute", inset:-3, borderRadius:"50%", border:`1px solid ${color}`, animation:"statusPulse 2s ease-in-out infinite" }} />}
    </span>
  );
}

function Sparkline({ data, width = 200, height = 40, color = T.blue, showRange = false, showMean = false, filled = false, interactive = false, label = "" }) {
  const [hover, setHover] = useState(null);
  if (!data || data.length < 2) return null;
  const min = Math.min(...data);
  const max = Math.max(...data);
  const range = max - min || 1;
  const toX = i => (i / (data.length - 1)) * width;
  const toY = v => height - ((v - min) / range) * (height - 4) - 2;
  const pts = data.map((v, i) => `${toX(i)},${toY(v)}`);
  const line = pts.join(" ");
  const meanVal = data.reduce((s, v) => s + v, 0) / data.length;
  const meanY = toY(meanVal);

  const handleMouse = interactive ? (e) => {
    const rect = e.currentTarget.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const idx = Math.round((x / width) * (data.length - 1));
    if (idx >= 0 && idx < data.length) setHover({ idx, x: toX(idx), y: toY(data[idx]), val: data[idx] });
  } : undefined;

  return (
    <svg width={width} height={height} style={{ display:"block", cursor: interactive ? "crosshair" : "default" }}
      onMouseMove={handleMouse} onMouseLeave={interactive ? () => setHover(null) : undefined}
      role={label ? "img" : undefined} aria-label={label || undefined}>
      {filled && <path d={`M0,${height} ${pts.map(p => `L${p}`).join(" ")} L${width},${height} Z`}
        fill={`${color}15`} />}
      <polyline points={line} fill="none" stroke={color} strokeWidth={1.2} />
      {showMean && <line x1={0} y1={meanY} x2={width} y2={meanY} stroke={T.text3} strokeWidth={0.5} strokeDasharray="3,3" />}
      {showRange && (
        <React.Fragment>
          <text x={width - 2} y={9} textAnchor="end" style={{ fontFamily:T.mono, fontSize:8, fill:T.text3 }}>{max.toFixed(1)}</text>
          <text x={width - 2} y={height - 2} textAnchor="end" style={{ fontFamily:T.mono, fontSize:8, fill:T.text3 }}>{min.toFixed(1)}</text>
        </React.Fragment>
      )}
      {hover && (
        <React.Fragment>
          <line x1={hover.x} y1={0} x2={hover.x} y2={height} stroke={T.text3} strokeWidth={0.5} strokeDasharray="2,2" />
          <circle cx={hover.x} cy={hover.y} r={3} fill={color} stroke={T.bg0} strokeWidth={1.5} />
          <rect x={Math.min(hover.x + 4, width - 60)} y={Math.max(2, hover.y - 16)} width={56} height={14} rx={2} fill={T.bg3} stroke={T.border1} strokeWidth={0.5} />
          <text x={Math.min(hover.x + 8, width - 56)} y={Math.max(12, hover.y - 5)} style={{ fontFamily:T.mono, fontSize:9, fill:T.text0 }}>
            [{hover.idx}] {hover.val.toFixed(2)}
          </text>
        </React.Fragment>
      )}
    </svg>
  );
}

function AcfChart({ acfs, width = 240, height = 60, threshold = 0.25 }) {
  if (!acfs || acfs.length === 0) return null;
  const maxAcf = Math.max(...acfs.map(a => Math.abs(a.acf)), 0.5);
  const barW = Math.min(20, (width - 20) / acfs.length - 2);
  const midY = height / 2;
  return (
    <svg width={width} height={height} style={{ display: "block" }}>
      <line x1={0} y1={midY} x2={width} y2={midY} stroke={T.border1} strokeWidth={0.5} />
      <line x1={0} y1={midY - (threshold / maxAcf) * midY} x2={width} y2={midY - (threshold / maxAcf) * midY}
        stroke={T.crimson} strokeWidth={0.5} strokeDasharray="3,2" />
      <line x1={0} y1={midY + (threshold / maxAcf) * midY} x2={width} y2={midY + (threshold / maxAcf) * midY}
        stroke={T.crimson} strokeWidth={0.5} strokeDasharray="3,2" />
      {acfs.map((a, i) => {
        const x = 10 + i * (barW + 2);
        const h = (a.acf / maxAcf) * midY;
        const c = Math.abs(a.acf) > threshold ? T.blue : T.text3;
        return (
          <React.Fragment key={a.lag}>
            <rect x={x} y={h > 0 ? midY - h : midY} width={barW} height={Math.abs(h)} fill={c} rx={1} />
            <text x={x + barW / 2} y={height - 1} textAnchor="middle" style={{ fontFamily: T.mono, fontSize: 7, fill: T.text3 }}>{a.lag}</text>
          </React.Fragment>
        );
      })}
    </svg>
  );
}

function ProgressBar({ value, color, thick }) {
  return (
    <div style={{ width:"100%", height: thick ? 10 : 6, background:T.bg3, borderRadius:T.rPill, overflow:"hidden" }}>
      <div style={{ height:"100%", width:`${Math.min(100,value*100)}%`, background:color, borderRadius:T.rPill, transition:"width 0.6s cubic-bezier(0.22,1,0.36,1)" }} />
    </div>
  );
}

function MetricCard({ label, value, unit, delta, deltaDir, color }) {
  return (
    <div style={{ background:T.bg1, border:`1px solid ${T.border0}`, borderRadius:T.rMd, padding:16 }}>
      <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, textTransform:"uppercase", letterSpacing:"0.14em", color:T.text3, marginBottom:6 }}>{label}</div>
      <div style={{ fontFamily:T.display, fontWeight:700, fontSize:"1.6rem", color:color||T.text0, lineHeight:1 }}>
        {value}{unit && <span style={{ fontSize:T.fs.sm, fontWeight:400 }}>{unit}</span>}
      </div>
      {delta && <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, marginTop:6, color: deltaDir==="up"?T.green:deltaDir==="down"?T.crimson:T.text3 }}>{delta}</div>}
    </div>
  );
}

function Section({ title, count, color, children, style:sx }) {
  return (
    <div style={{ background:T.bg1, border:`1px solid ${T.border0}`, borderRadius:T.rMd, overflow:"hidden", ...sx }}>
      {color && <div style={{ height:3, width:"100%", background:color }} />}
      <div style={{ padding:"14px 16px" }}>
        <div style={{ display:"flex", justifyContent:"space-between", alignItems:"center", marginBottom:14, paddingBottom:10, borderBottom:`1px solid ${T.border0}` }}>
          <span style={{ fontFamily:T.display, fontWeight:700, fontSize:T.fs.lg, color:T.text0 }}>{title}</span>
          {count !== undefined && <Badge color={color||T.teal}>{count}</Badge>}
        </div>
        {children}
      </div>
    </div>
  );
}

function Segmented({ options, active, onChange }) {
  return (
    <div style={{ display:"inline-flex", background:T.bg2, border:`1px solid ${T.border0}`, borderRadius:T.rMd, padding:2, gap:2, flexWrap:"wrap" }}>
      {options.map(o => (
        <button key={o.key} onClick={() => onChange(o.key)} style={{
          fontFamily:T.mono, fontSize:T.fs.xs, padding:"0.3em 0.7em",
          borderRadius:T.rSm, border:"none", cursor:"pointer",
          background: active===o.key ? T.bg4 : "transparent",
          color: active===o.key ? T.text0 : T.text3,
        }}>{o.label}</button>
      ))}
    </div>
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NEW COMPONENTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function TabBar({ tabs, active, onChange }) {
  const handleKeyDown = useCallback((e, idx) => {
    let next = idx;
    if (e.key === "ArrowRight") next = (idx + 1) % tabs.length;
    else if (e.key === "ArrowLeft") next = (idx - 1 + tabs.length) % tabs.length;
    else if (e.key === "Home") next = 0;
    else if (e.key === "End") next = tabs.length - 1;
    else return;
    e.preventDefault();
    onChange(tabs[next].key);
    e.currentTarget.parentElement.children[next]?.focus();
  }, [tabs, onChange]);

  return (
    <div role="tablist" aria-label="Navigation tabs" style={{ display:"flex", gap:2, background:T.bg2, border:`1px solid ${T.border0}`, borderRadius:T.rMd, padding:3, marginBottom:24, overflowX:"auto" }}>
      {tabs.map((t, idx) => (
        <button key={t.key} role="tab" aria-selected={active===t.key} tabIndex={active===t.key ? 0 : -1}
          onClick={() => onChange(t.key)} onKeyDown={e => handleKeyDown(e, idx)}
          style={{
            flex:1, fontFamily:T.mono, fontSize:T.fs.sm, fontWeight: active===t.key ? 600 : 400,
            padding:"10px 12px", borderRadius:T.rSm, border:"none", cursor:"pointer",
            background: active===t.key ? T.bg4 : "transparent",
            color: active===t.key ? T.text0 : T.text3,
            transition:"all 0.2s ease",
            borderBottom: active===t.key ? `3px solid ${t.color || T.teal}` : "3px solid transparent",
            minWidth:"fit-content", whiteSpace:"nowrap",
          }}>{t.label}</button>
      ))}
    </div>
  );
}

function TechCard({ tech, expanded, onToggle }) {
  const fc = familyColor(tech.family);
  const [hovered, setHovered] = useState(false);
  const roleColors = { transform:T.green, feature:T.blue, model:T.orange, calibration:T.purple, decision:T.red };
  const riskColors = { low:T.green, medium:T.yellow, high:T.crimson };
  return (
    <div aria-expanded={expanded} style={{ background: hovered ? T.bg3 : T.bg2, border:`1px solid ${expanded ? fc+"44" : T.border0}`, borderRadius:T.rMd, overflow:"hidden", transition:"background 150ms, border-color 150ms" }}
      onMouseEnter={() => setHovered(true)} onMouseLeave={() => setHovered(false)}>
      <div style={{ height:2, background:fc }} />
      <div onClick={onToggle} role="button" tabIndex={0} aria-label={`${tech.name} â€” ${expanded?"collapse":"expand"}`}
        onKeyDown={e => { if(e.key==="Enter"||e.key===" "){e.preventDefault();onToggle();} }}
        style={{ padding:"12px 14px", cursor:"pointer" }}>
        <div style={{ display:"flex", alignItems:"center", gap:8, marginBottom:4 }}>
          <StatusDot color={fc} size={7} />
          <span style={{ fontFamily:T.display, fontWeight:700, fontSize:T.fs.md, color:T.text0, flex:1 }}>{tech.name}</span>
          <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, padding:"0.15em 0.5em", borderRadius:T.rSm,
            background:`${fc}22`, color:fc, border:`1px solid ${fc}33` }}>{familyName(tech.family)}</span>
          <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3, transform:expanded?"rotate(90deg)":"rotate(0)",transition:"transform 0.2s" }}>â–¸</span>
        </div>
        <div style={{ fontFamily:T.body, fontSize:T.fs.sm, color:T.text2, marginLeft:15 }}>{tech.desc}</div>
        <div style={{ display:"flex", gap:4, marginTop:8, marginLeft:15, flexWrap:"wrap" }}>
          <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, padding:"0.12em 0.4em", borderRadius:T.rSm,
            background:(roleColors[tech.pipelineRole]||T.text3)+"22", color:roleColors[tech.pipelineRole]||T.text3 }}>{tech.pipelineRole}</span>
          <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, padding:"0.12em 0.4em", borderRadius:T.rSm,
            background:(riskColors[tech.leakageRisk]||T.text3)+"22", color:riskColors[tech.leakageRisk]||T.text3 }}>leak: {tech.leakageRisk}</span>
          {Array.from({length:5}).map((_,i) => (
            <span key={i} style={{ width:6, height:6, borderRadius:"50%", background: i < tech.complexity ? fc : T.bg4, marginTop:3 }} />
          ))}
        </div>
      </div>
      <div style={{ maxHeight:expanded?2000:0, overflow:"hidden", transition:"max-height 0.4s ease" }}>
        <div style={{ padding:"0 14px 14px", borderTop:`1px solid ${T.border0}` }}>
          <div style={{ display:"grid", gridTemplateColumns:"1fr 1fr", gap:10, marginTop:10 }}>
            <div>
              <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:4 }}>Inputs</div>
              <div style={{ display:"flex", gap:3, flexWrap:"wrap" }}>{tech.inputTypes.map(t => <Chip key={t} style={{ fontSize:T.fs.xs }}>{t}</Chip>)}</div>
            </div>
            <div>
              <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:4 }}>Outputs</div>
              <div style={{ display:"flex", gap:3, flexWrap:"wrap" }}>{tech.outputTypes.map(t => <Chip key={t} style={{ fontSize:T.fs.xs }}>{t}</Chip>)}</div>
            </div>
            <div>
              <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:4 }}>Assumptions</div>
              <div style={{ display:"flex", gap:3, flexWrap:"wrap" }}>
                {tech.assumptions.length ? tech.assumptions.map(a => <Chip key={a} style={{ fontSize:T.fs.xs }}>{a.replace(/_/g," ")}</Chip>) : <span style={{fontFamily:T.mono,fontSize:T.fs.xs,color:T.text3}}>none</span>}
              </div>
            </div>
            <div>
              <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:4 }}>Owns</div>
              <div style={{ display:"flex", gap:3, flexWrap:"wrap" }}>
                {tech.ownedResponsibilities.length ? tech.ownedResponsibilities.map(r => <Chip key={r} style={{ fontSize:T.fs.xs, background:T.purpleDim, color:T.purple, border:`1px solid ${T.purple}33` }}>{r.replace(/_/g," ")}</Chip>) : <span style={{fontFamily:T.mono,fontSize:T.fs.xs,color:T.text3}}>none</span>}
              </div>
            </div>
            <div>
              <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:4 }}>Time Scales</div>
              <div style={{ display:"flex", gap:3, flexWrap:"wrap" }}>{tech.timeScales.map(s => <Chip key={s} style={{ fontSize:T.fs.xs }}>{s}</Chip>)}</div>
            </div>
            <div>
              <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:4 }}>Best For</div>
              <div style={{ display:"flex", gap:3, flexWrap:"wrap" }}>{tech.bestFor.map(b => <Chip key={b} style={{ fontSize:T.fs.xs, background:T.greenDim, color:T.green, border:`1px solid ${T.green}33` }}>{b}</Chip>)}</div>
            </div>
          </div>
          {/* â”€â”€â”€ TECHNIQUE_DETAILS enrichment â”€â”€â”€ */}
          {(() => {
            const d = TECHNIQUE_DETAILS[tech.id];
            if (!d) return null;
            const techName = id => (TECHNIQUES.find(t => t.id === id) || {}).name || id;
            const techColor = id => familyColor((TECHNIQUES.find(t => t.id === id) || {}).family);
            const opName = id => (OPERATORS.find(o => o.id === id) || {}).id || id;
            return (
              <div style={{ marginTop:12, paddingTop:10, borderTop:`1px dashed ${T.border0}` }}>
                {/* Strengths */}
                <div style={{ marginBottom:10 }}>
                  <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.green, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:5 }}>Strengths</div>
                  {d.strengths.map((s,i) => (
                    <div key={i} style={{ display:"flex", gap:6, alignItems:"flex-start", padding:"2px 0" }}>
                      <StatusDot color={T.green} size={5} />
                      <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text1 }}>{s}</span>
                    </div>
                  ))}
                </div>
                {/* Weaknesses */}
                <div style={{ marginBottom:10 }}>
                  <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.crimson, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:5 }}>Weaknesses</div>
                  {d.weaknesses.map((w,i) => (
                    <div key={i} style={{ display:"flex", gap:6, alignItems:"flex-start", padding:"2px 0" }}>
                      <StatusDot color={T.crimson} size={5} />
                      <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text1 }}>{w}</span>
                    </div>
                  ))}
                </div>
                {/* Connections row */}
                <div style={{ display:"grid", gridTemplateColumns:"1fr 1fr 1fr", gap:10 }}>
                  {/* Synergies */}
                  <div>
                    <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.teal, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:5 }}>Synergies With</div>
                    <div style={{ display:"flex", gap:3, flexWrap:"wrap" }}>
                      {d.synergiesWith.length ? d.synergiesWith.map(id => (
                        <span key={id} style={{ fontFamily:T.mono, fontSize:T.fs.xs, padding:"0.12em 0.4em", borderRadius:T.rSm,
                          background:`${techColor(id)}15`, color:techColor(id), border:`1px solid ${techColor(id)}33`, cursor:"default" }}>
                          {techName(id)}
                        </span>
                      )) : <span style={{fontFamily:T.mono,fontSize:T.fs.xs,color:T.text3}}>none</span>}
                    </div>
                  </div>
                  {/* Conflicts */}
                  <div>
                    <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.crimson, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:5 }}>Conflicts With</div>
                    <div style={{ display:"flex", gap:3, flexWrap:"wrap" }}>
                      {d.conflictsWith.length ? d.conflictsWith.map(id => (
                        <span key={id} style={{ fontFamily:T.mono, fontSize:T.fs.xs, padding:"0.12em 0.4em", borderRadius:T.rSm,
                          background:T.crimsonDim, color:T.crimson, border:`1px solid ${T.crimson}33`, cursor:"default" }}>
                          {techName(id)}
                        </span>
                      )) : <span style={{fontFamily:T.mono,fontSize:T.fs.xs,color:T.text3}}>none</span>}
                    </div>
                  </div>
                  {/* Related */}
                  <div>
                    <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:5 }}>Related To</div>
                    <div style={{ display:"flex", gap:3, flexWrap:"wrap" }}>
                      {d.relatedTo.map(id => (
                        <span key={id} style={{ fontFamily:T.mono, fontSize:T.fs.xs, padding:"0.12em 0.4em", borderRadius:T.rSm,
                          background:T.bg4, color:T.text2, border:`1px solid ${T.border1}`, cursor:"default" }}>
                          {techName(id)}
                        </span>
                      ))}
                    </div>
                  </div>
                </div>
                {/* Relevant CLR Operators */}
                {d.relevantOps.length > 0 && (
                  <div style={{ marginTop:10 }}>
                    <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.orange, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:5 }}>CLR Operators</div>
                    <div style={{ display:"flex", gap:3, flexWrap:"wrap" }}>
                      {d.relevantOps.map(opId => {
                        const op = OPERATORS.find(o => o.id === opId);
                        const cc = op ? (OP_CATEGORIES.find(c => c.id === op.category) || {}).color || T.text3 : T.text3;
                        return (
                          <span key={opId} title={op ? op.description : opId} style={{ fontFamily:T.mono, fontSize:T.fs.xs, padding:"0.12em 0.5em", borderRadius:T.rSm,
                            background:`${cc}15`, color:cc, border:`1px solid ${cc}33`, cursor:"help" }}>
                            {opId}
                          </span>
                        );
                      })}
                    </div>
                  </div>
                )}
                {/* Canonical pipelines this technique appears in */}
                {(() => {
                  const pipes = CANONICAL_PIPELINES.filter(p => p.steps.includes(tech.id));
                  if (pipes.length === 0) return null;
                  return (
                    <div style={{ marginTop:10 }}>
                      <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.blue, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:5 }}>Appears in Pipelines</div>
                      <div style={{ display:"flex", gap:4, flexWrap:"wrap" }}>
                        {pipes.map(p => (
                          <span key={p.id} title={p.description} style={{ fontFamily:T.mono, fontSize:T.fs.xs, padding:"0.12em 0.5em", borderRadius:T.rSm,
                            background:T.blueDim, color:T.blue, border:`1px solid ${T.blue}33`, cursor:"help" }}>
                            {p.name}
                          </span>
                        ))}
                      </div>
                    </div>
                  );
                })()}
                {/* Hilbert Space Interpretation */}
                {(() => {
                  const hm = HILBERT_MAPPING[tech.id];
                  if (!hm) return null;
                  const hc = HILBERT_CONCEPTS.find(c => c.id === hm.concept);
                  if (!hc) return null;
                  return (
                    <div style={{ marginTop:10, padding:"8px 10px", background:`${hc.color}08`, borderRadius:T.rSm, border:`1px solid ${hc.color}20` }}>
                      <div style={{ display:"flex", alignItems:"center", gap:6, marginBottom:4 }}>
                        <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:hc.color, textTransform:"uppercase", letterSpacing:"0.1em" }}>Hilbert</span>
                        <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, padding:"0.1em 0.4em", borderRadius:T.rSm,
                          background:`${hc.color}18`, color:hc.color, border:`1px solid ${hc.color}33` }}>{hc.symbol}</span>
                        <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:hc.color }}>{hc.name}</span>
                      </div>
                      <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text2, fontStyle:"italic" }}>{hm.interpretation}</div>
                    </div>
                  );
                })()}
              </div>
            );
          })()}
        </div>
      </div>
    </div>
  );
}

function PrincipleCard({ p, expanded, onToggle }) {
  const catColors = { structural:T.blue, causal:T.orange, statistical:T.purple, evaluation:T.crimson, design:T.green };
  const cc = catColors[p.category] || T.teal;
  return (
    <div style={{ background:T.bg2, border:`1px solid ${T.border0}`, borderRadius:T.rMd, overflow:"hidden" }}>
      <div style={{ height:2, background:cc }} />
      <div onClick={onToggle} style={{ padding:"12px 14px", cursor:"pointer" }}>
        <div style={{ display:"flex", alignItems:"center", gap:8 }}>
          <Badge color={cc}>{p.id}</Badge>
          <span style={{ fontFamily:T.display, fontWeight:700, fontSize:T.fs.md, color:T.text0, flex:1 }}>{p.name}</span>
          <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, padding:"0.15em 0.5em", borderRadius:T.rSm,
            background:`${cc}22`, color:cc }}>{p.category}</span>
          <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3, transform:expanded?"rotate(90deg)":"rotate(0)",transition:"transform 0.2s" }}>â–¸</span>
        </div>
        <div style={{ fontFamily:T.body, fontSize:T.fs.sm, color:T.text2, marginTop:6, marginLeft:28 }}>{p.description}</div>
      </div>
      <div style={{ maxHeight:expanded?500:0, overflow:"hidden", transition:"max-height 0.3s ease" }}>
        <div style={{ padding:"0 14px 14px", borderTop:`1px solid ${T.border0}` }}>
          <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text0, padding:"10px 0 8px", borderBottom:`1px dashed ${T.border0}` }}>
            <span style={{ color:T.text3 }}>Rule: </span>{p.rule}
          </div>
          <div style={{ display:"grid", gridTemplateColumns:"1fr 1fr", gap:12, marginTop:10 }}>
            <div>
              <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.green, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:6 }}>Safe Examples</div>
              {p.safeExamples.map((e,i) => (
                <div key={i} style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text1, padding:"4px 0", display:"flex", gap:6, alignItems:"flex-start" }}>
                  <StatusDot color={T.green} size={5} /><span>{e}</span>
                </div>
              ))}
            </div>
            <div>
              <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.crimson, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:6 }}>Unsafe Examples</div>
              {p.unsafeExamples.map((e,i) => (
                <div key={i} style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text1, padding:"4px 0", display:"flex", gap:6, alignItems:"flex-start" }}>
                  <StatusDot color={T.crimson} size={5} /><span>{e}</span>
                </div>
              ))}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TAB 1: TECHNIQUES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function TechniquesTab() {
  const [search, setSearch] = useState("");
  const [familyFilter, setFamilyFilter] = useState("all");
  const [expanded, setExpanded] = useState(() => new Set(TECHNIQUES.length > 0 ? [TECHNIQUES[0].id] : []));

  const filtered = useMemo(() => {
    return TECHNIQUES.filter(t => {
      if (familyFilter !== "all" && t.family !== familyFilter) return false;
      if (search && !t.name.toLowerCase().includes(search.toLowerCase()) && !t.desc.toLowerCase().includes(search.toLowerCase())) return false;
      return true;
    });
  }, [search, familyFilter]);

  const toggle = useCallback(id => setExpanded(p => { const n = new Set(p); n.has(id)?n.delete(id):n.add(id); return n; }), []);

  return (
    <div>
      <div style={{ display:"flex", gap:10, marginBottom:16, alignItems:"center", flexWrap:"wrap" }}>
        <input value={search} onChange={e => setSearch(e.target.value)} placeholder="Search techniques..."
          style={{ fontFamily:T.mono, fontSize:T.fs.sm, padding:"8px 12px", borderRadius:T.rMd,
            border:`1px solid ${T.border1}`, background:T.bg2, color:T.text0, outline:"none", flex:"1 1 200px", minWidth:150 }} />
        <Segmented
          options={[{key:"all",label:"All"},...FAMILIES.map(f=>({key:f.id,label:f.name}))]}
          active={familyFilter} onChange={setFamilyFilter} />
      </div>
      <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3, marginBottom:12 }}>
        {filtered.length} technique{filtered.length!==1?"s":""} Â· {new Set(filtered.map(t=>t.family)).size} families
      </div>
      <div style={{ display:"grid", gridTemplateColumns:"repeat(auto-fill, minmax(380px, 1fr))", gap:8 }}>
        {filtered.map(t => <TechCard key={t.id} tech={t} expanded={expanded.has(t.id)} onToggle={() => toggle(t.id)} />)}
      </div>
    </div>
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TAB 2: PIPELINE COMPOSER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function ComposerTab() {
  // Smart default: pre-load Quick Baseline pipeline
  const [pipeline, setPipeline] = useState(() => {
    const qb = CANONICAL_PIPELINES.find(p => p.id === "quick_baseline");
    return qb ? [...qb.steps] : [];
  });
  const [familyFilter, setFamilyFilter] = useState("all");

  const addTech = useCallback(id => {
    setPipeline(p => [...p, id]);
  }, []);
  const removeTech = useCallback(idx => {
    setPipeline(p => p.filter((_,i) => i !== idx));
  }, []);
  const clearPipeline = useCallback(() => setPipeline([]), []);

  const pairChecks = useMemo(() => {
    const results = [];
    for (let i = 0; i < pipeline.length - 1; i++) {
      const a = TECHNIQUES.find(t => t.id === pipeline[i]);
      const b = TECHNIQUES.find(t => t.id === pipeline[i+1]);
      if (a && b) results.push({ from:a, to:b, ...checkComposition(a, b) });
    }
    return results;
  }, [pipeline]);

  const overallScore = pairChecks.length > 0
    ? pairChecks.reduce((s,c) => s + c.score, 0) / pairChecks.length : 0;
  const scoreColor = overallScore > 0.8 ? T.green : overallScore > 0.5 ? T.yellow : T.crimson;

  const palette = useMemo(() => {
    if (familyFilter === "all") return TECHNIQUES;
    return TECHNIQUES.filter(t => t.family === familyFilter);
  }, [familyFilter]);

  return (
    <div>
      {/* Pipeline display */}
      <Section title="Pipeline" count={pipeline.length} color={scoreColor}>
        {pipeline.length === 0 ? (
          <div style={{ fontFamily:T.mono, fontSize:T.fs.sm, color:T.text3, padding:"20px 0", textAlign:"center" }}>
            Click techniques below to build a pipeline
          </div>
        ) : (
          <div>
            <div style={{ display:"flex", alignItems:"center", gap:0, overflowX:"auto", padding:"8px 0" }}>
              {pipeline.map((id, idx) => {
                const tech = TECHNIQUES.find(t => t.id === id);
                if (!tech) return null;
                const fc = familyColor(tech.family);
                return (
                  <React.Fragment key={idx}>
                    <div style={{ display:"flex", flexDirection:"column", alignItems:"center", minWidth:100, position:"relative" }}>
                      <div style={{
                        background:T.bg3, border:`1px solid ${fc}55`, borderRadius:T.rMd, padding:"8px 12px",
                        textAlign:"center", minWidth:90, position:"relative",
                      }}>
                        <button onClick={() => removeTech(idx)} style={{
                          position:"absolute", top:-6, right:-6, width:16, height:16, borderRadius:"50%",
                          background:T.crimson, color:"#fff", border:"none", cursor:"pointer",
                          fontFamily:T.mono, fontSize:T.fs.xs, display:"flex", alignItems:"center", justifyContent:"center",
                        }}>x</button>
                        <div style={{ width:6, height:6, borderRadius:"50%", background:fc, margin:"0 auto 4px" }} />
                        <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text0, fontWeight:600 }}>{tech.name}</div>
                        <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3 }}>{tech.pipelineRole}</div>
                      </div>
                    </div>
                    {idx < pipeline.length - 1 && (
                      <div style={{ display:"flex", flexDirection:"column", alignItems:"center", minWidth:30 }}>
                        {pairChecks[idx] && (
                          <React.Fragment>
                            <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color: pairChecks[idx].score>0.8?T.green:pairChecks[idx].score>0.5?T.yellow:T.crimson, marginBottom:2 }}>
                              {(pairChecks[idx].score*100).toFixed(0)}%
                            </div>
                            <div style={{ width:20, height:2, background: pairChecks[idx].score>0.8?T.green:pairChecks[idx].score>0.5?T.yellow:T.crimson }} />
                            <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color: pairChecks[idx].score>0.8?T.green:pairChecks[idx].score>0.5?T.yellow:T.crimson }}>â†’</span>
                          </React.Fragment>
                        )}
                      </div>
                    )}
                  </React.Fragment>
                );
              })}
            </div>
            {pipeline.length >= 2 && (
              <div style={{ display:"flex", alignItems:"center", gap:10, marginTop:12, paddingTop:10, borderTop:`1px solid ${T.border0}` }}>
                <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3 }}>Overall Score</span>
                <div style={{ flex:1 }}><ProgressBar value={overallScore} color={scoreColor} thick /></div>
                <span style={{ fontFamily:T.display, fontWeight:700, fontSize:"1.1rem", color:scoreColor }}>{(overallScore*100).toFixed(0)}%</span>
              </div>
            )}
            <div style={{ textAlign:"right", marginTop:8 }}>
              <button onClick={clearPipeline} style={{ fontFamily:T.mono, fontSize:T.fs.xs, padding:"4px 10px",
                borderRadius:T.rSm, border:`1px solid ${T.border1}`, background:T.bg3, color:T.text2, cursor:"pointer" }}>Clear</button>
            </div>
          </div>
        )}
      </Section>

      {/* Pair checks detail */}
      {pairChecks.length > 0 && (
        <Section title="Composition Checks" count={pairChecks.reduce((s,p) => s + p.checks.filter(c=>!c.pass).length, 0)} color={T.orange} style={{ marginTop:12 }}>
          {pairChecks.map((pair, idx) => (
            <div key={idx} style={{ marginBottom:12, paddingBottom:12, borderBottom: idx < pairChecks.length-1 ? `1px solid ${T.border0}` : "none" }}>
              <div style={{ fontFamily:T.mono, fontSize:T.fs.sm, color:T.text0, marginBottom:8 }}>
                <span style={{ color:familyColor(pair.from.family) }}>{pair.from.name}</span>
                <span style={{ color:T.text3 }}> â†’ </span>
                <span style={{ color:familyColor(pair.to.family) }}>{pair.to.name}</span>
                <span style={{ marginLeft:8, color: pair.score>0.8?T.green:pair.score>0.5?T.yellow:T.crimson }}>
                  ({(pair.score*100).toFixed(0)}%)
                </span>
              </div>
              <div style={{ display:"grid", gridTemplateColumns:"repeat(auto-fill, minmax(280px, 1fr))", gap:6 }}>
                {pair.checks.map((c, ci) => (
                  <div key={ci} style={{ display:"flex", alignItems:"flex-start", gap:6, padding:"4px 8px",
                    borderRadius:T.rSm, background: c.severity==="ok"?T.greenDim:c.severity==="warn"?T.yellowDim:T.crimsonDim }}>
                    <StatusDot color={c.severity==="ok"?T.green:c.severity==="warn"?T.yellow:T.crimson} size={6} />
                    <div>
                      <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, fontWeight:600, color:T.text0 }}>{c.name}</div>
                      <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text2 }}>{c.detail}</div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          ))}
        </Section>
      )}

      {/* Pipeline Simulation Preview */}
      {pipeline.length >= 1 && (
        <Section title="Simulation Preview" color={T.teal} style={{ marginTop:12 }}>
          {(() => {
            const synData = generateSeasonal(200, 7, 10, 0.05, 2);
            let current = synData;
            const stages = [{ label:"Input: Weekly Seasonal", data:current, color:T.text2 }];
            for (const id of pipeline) {
              const tech = TECHNIQUES.find(t => t.id === id);
              if (!tech) continue;
              const result = simulateStep(id, current);
              stages.push({ label:`${tech.name}: ${result.label}`, data:result.values, color:familyColor(tech.family) });
              current = result.values;
            }
            return (
              <div style={{ display:"flex", flexDirection:"column", gap:6 }}>
                <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3, marginBottom:4 }}>
                  Simulated on synthetic weekly seasonal signal (n=200)
                </div>
                {stages.map((s,i) => (
                  <div key={i} style={{ display:"flex", alignItems:"center", gap:10, padding:"4px 8px", background:T.bg2, borderRadius:T.rSm, borderLeft:`3px solid ${s.color}` }}>
                    <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:s.color, minWidth:180, flexShrink:0 }}>{s.label}</span>
                    <Sparkline data={s.data.slice(0, 200)} width={400} height={28} color={s.color} showRange />
                  </div>
                ))}
              </div>
            );
          })()}
        </Section>
      )}

      {/* Canonical Pipelines */}
      <Section title="Canonical Pipelines" count={CANONICAL_PIPELINES.length} color={T.blue} style={{ marginTop:12 }}>
        <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3, marginBottom:10 }}>
          Click a pipeline to load it into the composer
        </div>
        <div style={{ display:"grid", gridTemplateColumns:"repeat(auto-fill, minmax(320px, 1fr))", gap:8 }}>
          {CANONICAL_PIPELINES.map(cp => (
            <button key={cp.id} onClick={() => setPipeline(cp.steps)} style={{
              background:T.bg2, border:`1px solid ${T.border0}`, borderRadius:T.rMd, padding:"10px 12px",
              cursor:"pointer", textAlign:"left", borderLeft:`3px solid ${T.blue}`, display:"block", width:"100%",
            }}>
              <div style={{ display:"flex", alignItems:"center", gap:6, marginBottom:4 }}>
                <span style={{ fontFamily:T.display, fontWeight:700, fontSize:T.fs.sm, color:T.text0, flex:1 }}>{cp.name}</span>
                <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, padding:"0.12em 0.4em", borderRadius:T.rSm,
                  background:T.bg4, color:T.text3 }}>complexity {cp.complexity}</span>
              </div>
              <div style={{ fontFamily:T.body, fontSize:T.fs.xs, color:T.text2, marginBottom:6 }}>{cp.description}</div>
              <div style={{ display:"flex", gap:3, alignItems:"center", flexWrap:"wrap", marginBottom:4 }}>
                {cp.steps.map((sid, i) => {
                  const t = TECHNIQUES.find(x => x.id === sid);
                  const fc = t ? familyColor(t.family) : T.text3;
                  return (
                    <React.Fragment key={sid}>
                      {i > 0 && <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3 }}>â†’</span>}
                      <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, padding:"0.1em 0.4em", borderRadius:T.rSm,
                        background:`${fc}18`, color:fc, border:`1px solid ${fc}33` }}>
                        {t ? t.name : sid}
                      </span>
                    </React.Fragment>
                  );
                })}
              </div>
              <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3 }}>
                <span style={{ color:T.teal }}>{cp.archetype}</span> Â· {cp.useCase}
              </div>
            </button>
          ))}
        </div>
      </Section>

      {/* Technique palette */}
      <div style={{ marginTop:12 }}>
        <div style={{ display:"flex", gap:8, alignItems:"center", marginBottom:10, flexWrap:"wrap" }}>
          <span style={{ fontFamily:T.display, fontWeight:700, fontSize:T.fs.md, color:T.text0 }}>Add Technique</span>
          <Segmented options={[{key:"all",label:"All"},...FAMILIES.map(f=>({key:f.id,label:f.name}))]}
            active={familyFilter} onChange={setFamilyFilter} />
        </div>
        <div style={{ display:"grid", gridTemplateColumns:"repeat(auto-fill, minmax(180px, 1fr))", gap:6 }}>
          {palette.map(t => {
            const fc = familyColor(t.family);
            return (
              <button key={t.id} onClick={() => addTech(t.id)} style={{
                background:T.bg2, border:`1px solid ${T.border0}`, borderRadius:T.rSm,
                padding:"8px 10px", cursor:"pointer", textAlign:"left", borderTop:`2px solid ${fc}`,
              }}>
                <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text0, fontWeight:500 }}>{t.name}</div>
                <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3, marginTop:2 }}>{t.pipelineRole} Â· {t.family}</div>
              </button>
            );
          })}
        </div>
      </div>
    </div>
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TAB 3: COMPATIBILITY MATRIX
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function MatrixTab() {
  const [hover, setHover] = useState(null);
  const [pinned, setPinned] = useState(null);
  const [familyFilter, setFamilyFilter] = useState("all");

  const techs = useMemo(() => {
    if (familyFilter === "all") return TECHNIQUES;
    return TECHNIQUES.filter(t => t.family === familyFilter);
  }, [familyFilter]);

  const matrix = useMemo(() => {
    const m = {};
    for (const a of techs) {
      for (const b of techs) {
        if (a.id === b.id) { m[`${a.id}|${b.id}`] = { score:1, checks:[] }; continue; }
        m[`${a.id}|${b.id}`] = checkComposition(a, b);
      }
    }
    return m;
  }, [techs]);

  const cellSize = Math.max(14, Math.min(24, Math.floor(700 / techs.length)));
  const labelW = 110;
  const w = labelW + techs.length * cellSize + 10;
  const h = labelW + techs.length * cellSize + 10;

  const active = pinned || hover;
  const hoverData = active ? matrix[`${active.a}|${active.b}`] : null;
  const hoverA = active ? TECHNIQUES.find(t=>t.id===active.a) : null;
  const hoverB = active ? TECHNIQUES.find(t=>t.id===active.b) : null;

  return (
    <div>
      <div style={{ display:"flex", gap:10, marginBottom:16, alignItems:"center", flexWrap:"wrap" }}>
        <Segmented options={[{key:"all",label:"All (35)"},...FAMILIES.map(f=>({key:f.id,label:f.name}))]}
          active={familyFilter} onChange={setFamilyFilter} />
        <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3 }}>
          {techs.length}Ã—{techs.length} = {techs.length*techs.length} cells Â· Hover or click to pin{pinned && <button onClick={() => setPinned(null)} style={{fontFamily:T.mono,fontSize:T.fs.xs,marginLeft:8,padding:"2px 6px",borderRadius:T.rSm,border:`1px solid ${T.border1}`,background:T.bg3,color:T.text2,cursor:"pointer"}}>Unpin</button>}
        </span>
      </div>

      <div style={{ display:"flex", gap:16, alignItems:"flex-start", flexWrap:"wrap" }}>
        <div style={{ overflowX:"auto", flex:"1 1 auto" }}>
          <svg viewBox={`0 0 ${w} ${h}`} style={{ width:Math.min(w, 900), height:Math.min(h, 900), display:"block" }}>
            {/* Column labels */}
            {techs.map((t, i) => (
              <text key={`cl-${t.id}`} x={labelW + i*cellSize + cellSize/2} y={labelW - 4}
                textAnchor="end" fill={familyColor(t.family)} fontSize={Math.min(7, cellSize*0.4)} fontFamily={T.mono}
                transform={`rotate(-65, ${labelW + i*cellSize + cellSize/2}, ${labelW - 4})`}>{t.name}</text>
            ))}
            {/* Row labels */}
            {techs.map((t, i) => (
              <text key={`rl-${t.id}`} x={labelW - 4} y={labelW + i*cellSize + cellSize/2 + 3}
                textAnchor="end" fill={familyColor(t.family)} fontSize={Math.min(7, cellSize*0.4)} fontFamily={T.mono}>{t.name}</text>
            ))}
            {/* Cells */}
            {techs.map((a, ai) => techs.map((b, bi) => {
              const key = `${a.id}|${b.id}`;
              const d = matrix[key];
              const s = d ? d.score : 0;
              const fill = a.id === b.id ? T.bg3 : s > 0.8 ? T.green : s > 0.6 ? `${T.green}88` : s > 0.4 ? T.yellow : s > 0.2 ? T.orange : T.crimson;
              const opacity = a.id === b.id ? 0.3 : 0.25 + s * 0.55;
              return (
                <rect key={key} x={labelW + bi*cellSize} y={labelW + ai*cellSize}
                  width={cellSize-1} height={cellSize-1} rx={1}
                  fill={fill} opacity={opacity}
                  stroke={(active && active.a===a.id && active.b===b.id) ? T.text0 : "none"} strokeWidth={1.5}
                  onMouseEnter={() => { if(!pinned) setHover({a:a.id, b:b.id}); }}
                  onMouseLeave={() => { if(!pinned) setHover(null); }}
                  onClick={() => setPinned(p => (p && p.a===a.id && p.b===b.id) ? null : {a:a.id, b:b.id})}
                  style={{ cursor:"pointer" }} />
              );
            }))}
          </svg>
        </div>

        {/* Hover detail panel */}
        <div style={{ minWidth:280, maxWidth:320, flex:"0 0 auto" }}>
          {hoverData && hoverA && hoverB ? (
            <Section title={`${hoverA.name} â†’ ${hoverB.name}`} color={hoverData.score>0.8?T.green:hoverData.score>0.5?T.yellow:T.crimson}>
              <div style={{ display:"flex", alignItems:"center", gap:8, marginBottom:10 }}>
                <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3 }}>Score</span>
                <div style={{ flex:1 }}><ProgressBar value={hoverData.score} color={hoverData.score>0.8?T.green:hoverData.score>0.5?T.yellow:T.crimson} thick /></div>
                <span style={{ fontFamily:T.display, fontWeight:700, fontSize:"1rem", color:hoverData.score>0.8?T.green:hoverData.score>0.5?T.yellow:T.crimson }}>
                  {(hoverData.score*100).toFixed(0)}%
                </span>
              </div>
              {hoverData.checks.map((c,i) => (
                <div key={i} style={{ display:"flex", alignItems:"flex-start", gap:6, padding:"5px 0",
                  borderBottom: i < hoverData.checks.length-1 ? `1px solid ${T.border0}` : "none" }}>
                  <StatusDot color={c.severity==="ok"?T.green:c.severity==="warn"?T.yellow:T.crimson} size={6} />
                  <div>
                    <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, fontWeight:600, color:T.text0 }}>{c.name}</div>
                    <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text2 }}>{c.detail}</div>
                  </div>
                </div>
              ))}
            </Section>
          ) : (
            <div style={{ background:T.bg1, border:`1px solid ${T.border0}`, borderRadius:T.rMd, padding:20, textAlign:"center" }}>
              <div style={{ fontFamily:T.mono, fontSize:T.fs.sm, color:T.text3 }}>Hover a cell to see<br/>compatibility details</div>
            </div>
          )}

          {/* Legend */}
          <div style={{ marginTop:12, background:T.bg1, border:`1px solid ${T.border0}`, borderRadius:T.rMd, padding:12 }}>
            <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:8 }}>Legend</div>
            {[{label:"> 80% Compatible",color:T.green},{label:"60-80%",color:`${T.green}88`},{label:"40-60%",color:T.yellow},{label:"20-40%",color:T.orange},{label:"< 20%",color:T.crimson}].map(l => (
              <div key={l.label} style={{ display:"flex", alignItems:"center", gap:8, padding:"2px 0" }}>
                <div style={{ width:14, height:14, borderRadius:2, background:l.color, opacity:0.7 }} />
                <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text2 }}>{l.label}</span>
              </div>
            ))}
          </div>
        </div>
      </div>
    </div>
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TAB 4: PRINCIPLES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function PrinciplesTab() {
  const [expanded, setExpanded] = useState(new Set([1]));
  const [catFilter, setCatFilter] = useState("all");
  const toggle = useCallback(id => setExpanded(p => { const n = new Set(p); n.has(id)?n.delete(id):n.add(id); return n; }), []);
  const cats = [...new Set(PRINCIPLES.map(p => p.category))];

  const filtered = catFilter === "all" ? PRINCIPLES : PRINCIPLES.filter(p => p.category === catFilter);

  return (
    <div>
      <div style={{ display:"flex", gap:10, marginBottom:16, alignItems:"center", flexWrap:"wrap" }}>
        <Segmented options={[{key:"all",label:"All (12)"},...cats.map(c => ({key:c,label:c}))]}
          active={catFilter} onChange={setCatFilter} />
        <button onClick={() => setExpanded(new Set(filtered.map(p=>p.id)))} style={{
          fontFamily:T.mono, fontSize:T.fs.xs, padding:"4px 10px", borderRadius:T.rSm,
          border:`1px solid ${T.border1}`, background:T.bg3, color:T.text2, cursor:"pointer" }}>Expand All</button>
        <button onClick={() => setExpanded(new Set())} style={{
          fontFamily:T.mono, fontSize:T.fs.xs, padding:"4px 10px", borderRadius:T.rSm,
          border:`1px solid ${T.border1}`, background:T.bg3, color:T.text2, cursor:"pointer" }}>Collapse All</button>
      </div>
      <div style={{ display:"flex", flexDirection:"column", gap:8 }}>
        {filtered.map(p => <PrincipleCard key={p.id} p={p} expanded={expanded.has(p.id)} onToggle={() => toggle(p.id)} />)}
      </div>
    </div>
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TAB 5: CONDENSED LOGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function CondensedLogsTab() {
  const [opCat, setOpCat] = useState("all");
  const [expandedArch, setExpandedArch] = useState(new Set());
  const toggleArch = useCallback(id => setExpandedArch(p => { const n = new Set(p); n.has(id)?n.delete(id):n.add(id); return n; }), []);

  const filteredOps = opCat === "all" ? OPERATORS : OPERATORS.filter(o => o.category === opCat);

  const thS = { fontFamily:T.mono, fontSize:T.fs.xs, textTransform:"uppercase", letterSpacing:"0.12em", color:T.text3, padding:"8px 10px", textAlign:"left", fontWeight:500, borderBottom:`1px solid ${T.border0}` };
  const tdS = { padding:"6px 10px", borderBottom:`1px solid ${T.border0}`, fontFamily:T.mono, fontSize:T.fs.sm, color:T.text1 };

  return (
    <div>
      {/* CLR Schema */}
      <Section title="Condensed Log Record (CLR) Schema" count={CLR_SCHEMA.length} color={T.purple}>
        <div style={{ overflowX:"auto" }}>
          <table style={{ width:"100%", borderCollapse:"collapse" }}>
            <thead style={{ background:T.bg3 }}>
              <tr>
                <th style={thS}>Field</th>
                <th style={thS}>Type</th>
                <th style={thS}>Description</th>
              </tr>
            </thead>
            <tbody>
              {CLR_SCHEMA.map(f => (
                <tr key={f.name}>
                  <td style={{ ...tdS, color:T.blue, fontWeight:600 }}>{f.name}</td>
                  <td style={{ ...tdS, color:T.purple }}>{f.type}</td>
                  <td style={{ ...tdS, color:T.text2 }}>{f.desc}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </Section>

      {/* Operators */}
      <Section title="Operator Stack" count={OPERATORS.length} color={T.orange} style={{ marginTop:12 }}>
        <div style={{ marginBottom:12 }}>
          <Segmented options={[{key:"all",label:`All (${OPERATORS.length})`},...OP_CATEGORIES.map(c => ({key:c.id,label:`${c.name} (${OPERATORS.filter(o=>o.category===c.id).length})`}))]}
            active={opCat} onChange={setOpCat} />
        </div>
        <div style={{ display:"flex", flexDirection:"column", gap:6 }}>
          {filteredOps.map(op => {
            const cc = (OP_CATEGORIES.find(c => c.id === op.category) || {}).color || T.text2;
            return (
              <div key={op.id} style={{ display:"flex", alignItems:"flex-start", gap:10, padding:"8px 10px",
                background:T.bg2, borderRadius:T.rSm, border:`1px solid ${T.border0}`, borderLeft:`3px solid ${cc}` }}>
                <div style={{ flex:1 }}>
                  <div style={{ display:"flex", alignItems:"center", gap:6, marginBottom:3 }}>
                    <span style={{ fontFamily:T.mono, fontSize:T.fs.sm, fontWeight:600, color:T.text0 }}>{op.id}</span>
                    <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, padding:"0.1em 0.4em", borderRadius:T.rSm,
                      background:`${cc}22`, color:cc }}>{op.category}</span>
                  </div>
                  <div style={{ fontFamily:T.body, fontSize:T.fs.sm, color:T.text2, marginBottom:3 }}>{op.description}</div>
                  <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.teal, background:T.tealDim, padding:"2px 6px", borderRadius:T.rSm, display:"inline-block" }}>{op.formula}</div>
                  {/* Cross-reference: which techniques use this operator */}
                  {(() => {
                    const users = TECHNIQUES.filter(t => {
                      const d = TECHNIQUE_DETAILS[t.id];
                      return d && d.relevantOps.includes(op.id);
                    });
                    if (users.length === 0) return null;
                    return (
                      <div style={{ marginTop:5, display:"flex", gap:3, flexWrap:"wrap", alignItems:"center" }}>
                        <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3, textTransform:"uppercase", letterSpacing:"0.08em" }}>Used by:</span>
                        {users.map(t => (
                          <span key={t.id} style={{ fontFamily:T.mono, fontSize:T.fs.xs, padding:"0.08em 0.35em", borderRadius:T.rSm,
                            background:`${familyColor(t.family)}12`, color:familyColor(t.family), border:`1px solid ${familyColor(t.family)}28` }}>
                            {t.name}
                          </span>
                        ))}
                      </div>
                    );
                  })()}
                </div>
              </div>
            );
          })}
        </div>
      </Section>

      {/* Archetypes */}
      <Section title="Stream Archetypes" count={ARCHETYPES.length} color={T.teal} style={{ marginTop:12 }}>
        <div style={{ display:"flex", flexDirection:"column", gap:8 }}>
          {ARCHETYPES.map(arch => {
            const isOpen = expandedArch.has(arch.id);
            return (
              <div key={arch.id} style={{ background:T.bg2, border:`1px solid ${T.border0}`, borderRadius:T.rMd, overflow:"hidden" }}>
                <div onClick={() => toggleArch(arch.id)} style={{ padding:"10px 12px", cursor:"pointer" }}>
                  <div style={{ display:"flex", alignItems:"center", gap:8 }}>
                    <StatusDot color={T.teal} size={7} />
                    <span style={{ fontFamily:T.display, fontWeight:700, fontSize:T.fs.md, color:T.text0, flex:1 }}>{arch.name}</span>
                    <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3, transform:isOpen?"rotate(90deg)":"rotate(0)",transition:"transform 0.2s" }}>â–¸</span>
                  </div>
                  <div style={{ fontFamily:T.body, fontSize:T.fs.sm, color:T.text2, marginTop:4, marginLeft:15 }}>{arch.description}</div>
                </div>
                <div style={{ maxHeight:isOpen?400:0, overflow:"hidden", transition:"max-height 0.3s ease" }}>
                  <div style={{ padding:"0 12px 12px", borderTop:`1px solid ${T.border0}` }}>
                    <div style={{ display:"grid", gridTemplateColumns:"1fr 1fr", gap:10, marginTop:10 }}>
                      <div>
                        <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:6 }}>Example Streams</div>
                        {arch.streams.map((s,i) => (
                          <div key={i} style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text1, padding:"2px 0", display:"flex", gap:4, alignItems:"center" }}>
                            <StatusDot color={T.blue} size={4} />{s}
                          </div>
                        ))}
                      </div>
                      <div>
                        <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.green, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:6 }}>Recommended Chain</div>
                        <div style={{ display:"flex", gap:4, flexWrap:"wrap" }}>
                          {arch.recommendedChain.map((tid,i) => {
                            const tech = TECHNIQUES.find(t => t.id === tid);
                            return (
                              <React.Fragment key={tid}>
                                {i > 0 && <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3 }}>â†’</span>}
                                <Chip style={{ fontSize:T.fs.xs, background:familyColor(tech?.family)+"22",
                                  color:familyColor(tech?.family), border:`1px solid ${familyColor(tech?.family)}33` }}>
                                  {tech?.name || tid}
                                </Chip>
                              </React.Fragment>
                            );
                          })}
                        </div>
                        <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.crimson, textTransform:"uppercase", letterSpacing:"0.1em", marginTop:10, marginBottom:6 }}>Anti-Patterns</div>
                        {arch.antiPatterns.map((ap,i) => (
                          <div key={i} style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text2, padding:"2px 0", display:"flex", gap:4, alignItems:"flex-start" }}>
                            <StatusDot color={T.crimson} size={4} />{ap}
                          </div>
                        ))}
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            );
          })}
        </div>
      </Section>
    </div>
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TAB 6: OBSERVATORY â€” Live Feeds + Analysis
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function ObservatoryTab() {
  const [feedData, setFeedData] = useState(null);
  const [feedName, setFeedName] = useState("");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [chars, setChars] = useState(null);
  const [techRecs, setTechRecs] = useState([]);
  const [pipeRecs, setPipeRecs] = useState([]);
  const [feedCategory, setFeedCategory] = useState("all");

  const [feedMeta, setFeedMeta] = useState(null); // {fromCache, age}
  const [feedDiag, setFeedDiag] = useState(null);

  // Subscribe to FeedManager state changes
  useEffect(() => {
    return FeedManager.subscribe(() => setFeedDiag(FeedManager.getDiagnostics()));
  }, []);

  // Smart default: auto-load first synthetic feed on mount
  useEffect(() => {
    if (!feedData && SYNTHETIC_FEEDS.length > 0) {
      loadSynthetic(SYNTHETIC_FEEDS[0]);
    }
  }, []); // eslint-disable-line react-hooks/exhaustive-deps

  const loadLiveFeed = useCallback(async (feed) => {
    setLoading(true); setError(null); setFeedData(null); setChars(null);
    setTechRecs([]); setPipeRecs([]); setFeedName(feed.name); setFeedMeta(null);
    try {
      const result = await FeedManager.fetch(feed);
      setFeedData(result.values);
      setFeedName(result.name);
      setFeedMeta({ fromCache: result.fromCache || false, age: result.age || 0 });
      const c = detectCharacteristics(result.values);
      setChars(c);
      setTechRecs(recommendTechniques(c));
      setPipeRecs(recommendPipelines(c));
    } catch (e) {
      setError(e.message);
    }
    setLoading(false);
  }, []);

  const loadSynthetic = useCallback((feed) => {
    setLoading(false); setError(null);
    setFeedName(feed.name);
    const values = feed.generate();
    setFeedData(values);
    const c = detectCharacteristics(values);
    setChars(c);
    setTechRecs(recommendTechniques(c));
    setPipeRecs(recommendPipelines(c));
  }, []);

  const feedCategories = [...new Set(LIVE_FEEDS.map(f => f.category))];
  const filteredFeeds = feedCategory === "all" ? LIVE_FEEDS : LIVE_FEEDS.filter(f => f.category === feedCategory);

  const labelS = { fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:5 };
  const statS = { fontFamily:T.mono, fontSize:T.fs.sm };

  return (
    <div>
      {/* Live Feeds */}
      <Section title="Live Data Feeds" count={LIVE_FEEDS.length} color={T.blue}>
        <div style={{ display:"flex", alignItems:"center", gap:8, marginBottom:10, flexWrap:"wrap" }}>
          <Segmented options={[{key:"all",label:`All (${LIVE_FEEDS.length})`}, ...feedCategories.map(c => ({key:c,label:`${c} (${LIVE_FEEDS.filter(f=>f.category===c).length})`}))]}
            active={feedCategory} onChange={setFeedCategory} />
          <button onClick={() => FeedManager.prefetch(LIVE_FEEDS)} style={{
            fontFamily:T.mono, fontSize:T.fs.xs, padding:"4px 10px", borderRadius:T.rSm, cursor:"pointer",
            background:T.bg3, border:`1px solid ${T.border1}`, color:T.text2,
          }}>âš¡ Prefetch All</button>
        </div>
        <div style={{ display:"grid", gridTemplateColumns:"repeat(auto-fill, minmax(260px, 1fr))", gap:6 }}>
          {filteredFeeds.map(f => (
            <button key={f.id} onClick={() => loadLiveFeed(f)} style={{
              background: feedName === f.name ? T.bg4 : T.bg2, border:`1px solid ${feedName === f.name ? T.blue : T.border0}`,
              borderRadius:T.rSm, padding:"8px 10px", cursor:"pointer", textAlign:"left", borderLeft:`3px solid ${T.blue}`,
              display:"block", width:"100%",
            }}>
              <div style={{ fontFamily:T.mono, fontSize:T.fs.sm, color:T.text0, fontWeight:600 }}>{f.name}</div>
              <div style={{ fontFamily:T.body, fontSize:T.fs.xs, color:T.text2, marginTop:2 }}>{f.description}</div>
              <div style={{ display:"flex", gap:4, marginTop:4 }}>
                <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, padding:"0.1em 0.35em", borderRadius:T.rSm,
                  background:T.bg4, color:T.text3 }}>{f.category}</span>
                <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, padding:"0.1em 0.35em", borderRadius:T.rSm,
                  background:T.tealDim, color:T.teal }}>{f.archetype}</span>
              </div>
            </button>
          ))}
        </div>
      </Section>

      {/* Synthetic Generators */}
      <Section title="Synthetic Generators" count={SYNTHETIC_FEEDS.length} color={T.green} style={{ marginTop:12 }}>
        <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3, marginBottom:8 }}>
          Generate controlled time series to test technique recommendations
        </div>
        <div style={{ display:"grid", gridTemplateColumns:"repeat(auto-fill, minmax(260px, 1fr))", gap:6 }}>
          {SYNTHETIC_FEEDS.map(f => (
            <button key={f.id} onClick={() => loadSynthetic(f)} style={{
              background: feedName === f.name ? T.bg4 : T.bg2, border:`1px solid ${feedName === f.name ? T.green : T.border0}`,
              borderRadius:T.rSm, padding:"8px 10px", cursor:"pointer", textAlign:"left", borderLeft:`3px solid ${T.green}`,
              display:"block", width:"100%",
            }}>
              <div style={{ fontFamily:T.mono, fontSize:T.fs.sm, color:T.text0, fontWeight:600 }}>{f.name}</div>
              <div style={{ fontFamily:T.body, fontSize:T.fs.xs, color:T.text2, marginTop:2 }}>{f.description}</div>
              <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, padding:"0.1em 0.35em", borderRadius:T.rSm,
                background:T.tealDim, color:T.teal, marginTop:4, display:"inline-block" }}>{f.archetype}</span>
            </button>
          ))}
        </div>
      </Section>

      {/* Feed Manager Diagnostics */}
      {feedDiag && feedDiag.feeds.length > 0 && (
        <Section title="Feed Diagnostics" count={feedDiag.feeds.length} color={T.text3} style={{ marginTop:12 }}>
          {/* Summary bar */}
          <div style={{ display:"flex", gap:12, flexWrap:"wrap", marginBottom:10 }}>
            <div style={{ display:"flex", alignItems:"center", gap:4 }}>
              <StatusDot color={T.green} size={5} />
              <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text2 }}>Cache hits: <strong style={{color:T.green}}>{feedDiag.totals.hits}</strong></span>
            </div>
            <div style={{ display:"flex", alignItems:"center", gap:4 }}>
              <StatusDot color={T.blue} size={5} />
              <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text2 }}>Fetches: <strong style={{color:T.blue}}>{feedDiag.totals.misses}</strong></span>
            </div>
            <div style={{ display:"flex", alignItems:"center", gap:4 }}>
              <StatusDot color={T.danger} size={5} />
              <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text2 }}>Errors: <strong style={{color:feedDiag.totals.errors>0?T.danger:T.text3}}>{feedDiag.totals.errors}</strong></span>
            </div>
            <div style={{ display:"flex", alignItems:"center", gap:4 }}>
              <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3 }}>Avg latency: <strong style={{color:T.text1}}>{feedDiag.totals.avgLatency.toFixed(0)}ms</strong></span>
            </div>
            <div style={{ display:"flex", alignItems:"center", gap:4 }}>
              <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3 }}>Rate: <strong style={{color:feedDiag.rateWindow.recent>=feedDiag.rateWindow.max-1?T.warning:T.text1}}>{feedDiag.rateWindow.recent}/{feedDiag.rateWindow.max}</strong>/10s</span>
            </div>
            {feedDiag.inflight > 0 && <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.blue }}><StatusDot color={T.blue} pulse size={5} /> {feedDiag.inflight} inflight</span>}
            {feedDiag.queued > 0 && <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.yellow }}>â³ {feedDiag.queued} queued</span>}
          </div>
          {/* Per-feed status */}
          <div style={{ display:"grid", gridTemplateColumns:"repeat(auto-fill, minmax(320px, 1fr))", gap:4 }}>
            {feedDiag.feeds.map(f => (
              <div key={f.url} style={{
                display:"flex", alignItems:"center", gap:8, padding:"5px 8px",
                background:T.bg2, borderRadius:T.rSm, border:`1px solid ${T.border0}`,
                borderLeft:`3px solid ${f.breaker==="open"?T.danger:f.breaker==="half-open"?T.warning:f.cached?T.green:T.border1}`,
              }}>
                <StatusDot color={f.breaker==="open"?T.danger:f.breaker==="half-open"?T.warning:f.errors>0?T.yellow:T.green} size={5} />
                <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text1, flex:1, overflow:"hidden", textOverflow:"ellipsis", whiteSpace:"nowrap" }}>{f.name}</span>
                {f.cached && <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, padding:"1px 4px", borderRadius:T.rSm, background:T.greenDim, color:T.green }}>cached {Math.round(f.cacheAge/1000)}s</span>}
                {f.breaker==="open" && <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, padding:"1px 4px", borderRadius:T.rSm, background:T.dangerDim, color:T.danger }}>OPEN</span>}
                <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3 }}>{f.lastLatency.toFixed(0)}ms</span>
                <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3 }}>{(f.bytesTotal/1024).toFixed(0)}KB</span>
              </div>
            ))}
          </div>
        </Section>
      )}

      {/* Cache indicator on loaded feed */}
      {feedMeta && feedMeta.fromCache && (
        <div style={{ margin:"8px 0", padding:"6px 10px", background:T.greenDim, border:`1px solid ${T.green}33`,
          borderRadius:T.rSm, fontFamily:T.mono, fontSize:T.fs.xs, color:T.green, display:"inline-flex", alignItems:"center", gap:6 }}>
          <StatusDot color={T.green} size={5} /> Served from cache ({Math.round(feedMeta.age/1000)}s old Â· TTL {FeedManager.config.DEFAULT_TTL/1000}s)
        </div>
      )}

      {/* Loading / Error */}
      {loading && (
        <div style={{ textAlign:"center", padding:"24px 0", fontFamily:T.mono, fontSize:T.fs.sm, color:T.blue }}>
          <StatusDot color={T.blue} pulse size={8} /> Fetching data...
        </div>
      )}
      {error && (
        <div style={{ margin:"12px 0", padding:"10px 14px", background:T.crimsonDim, border:`1px solid ${T.crimson}33`,
          borderRadius:T.rMd, fontFamily:T.mono, fontSize:T.fs.sm, color:T.crimson }}>
          Error: {error}
        </div>
      )}

      {/* Analysis Results */}
      {feedData && chars && !chars.error && (
        <div style={{ marginTop:16 }}>
          {/* Series Overview */}
          <Section title={feedName} count={chars.n} color={T.orange}>
            <div style={{ marginBottom:12 }}>
              <Sparkline data={feedData} width={Math.min(800, feedData.length)} height={80} color={T.blue} showRange filled showMean interactive label={`${feedName} time series`} />
            </div>

            {/* Detected Characteristics */}
            <div style={{ display:"grid", gridTemplateColumns:"repeat(auto-fill, minmax(180px, 1fr))", gap:8, marginBottom:12 }}>
              <div style={{ background:T.bg3, padding:"8px 10px", borderRadius:T.rSm }}>
                <div style={labelS}>Observations</div>
                <div style={statS}><span style={{ color:T.text0, fontWeight:700 }}>{chars.n}</span></div>
              </div>
              <div style={{ background:T.bg3, padding:"8px 10px", borderRadius:T.rSm }}>
                <div style={labelS}>Mean Â± Std</div>
                <div style={statS}><span style={{ color:T.text0 }}>{chars.mean.toFixed(2)}</span> <span style={{ color:T.text3 }}>Â±</span> <span style={{ color:T.yellow }}>{chars.std.toFixed(2)}</span></div>
              </div>
              <div style={{ background:T.bg3, padding:"8px 10px", borderRadius:T.rSm }}>
                <div style={labelS}>Range</div>
                <div style={statS}><span style={{ color:T.teal }}>{chars.min.toFixed(2)}</span> <span style={{ color:T.text3 }}>â†’</span> <span style={{ color:T.orange }}>{chars.max.toFixed(2)}</span></div>
              </div>
              <div style={{ background:T.bg3, padding:"8px 10px", borderRadius:T.rSm }}>
                <div style={labelS}>Trend</div>
                <div style={{ display:"flex", alignItems:"center", gap:4 }}>
                  <StatusDot color={chars.hasTrend ? T.orange : T.text3} size={6} />
                  <span style={{ ...statS, color: chars.hasTrend ? T.orange : T.text3 }}>{chars.hasTrend ? `${chars.trendDirection} (${chars.trendStrength.toFixed(2)})` : "none"}</span>
                </div>
              </div>
              <div style={{ background:T.bg3, padding:"8px 10px", borderRadius:T.rSm }}>
                <div style={labelS}>Seasonality</div>
                <div style={{ display:"flex", alignItems:"center", gap:4 }}>
                  <StatusDot color={chars.hasSeasonality ? T.green : T.text3} size={6} />
                  <span style={{ ...statS, color: chars.hasSeasonality ? T.green : T.text3 }}>{chars.hasSeasonality ? `periodâ‰ˆ${chars.seasonalPeriod} (${chars.seasonalStrength.toFixed(2)})` : "none"}</span>
                </div>
              </div>
              <div style={{ background:T.bg3, padding:"8px 10px", borderRadius:T.rSm }}>
                <div style={labelS}>Stationarity</div>
                <div style={{ display:"flex", alignItems:"center", gap:4 }}>
                  <StatusDot color={chars.isStationary ? T.green : T.crimson} size={6} />
                  <span style={{ ...statS, color: chars.isStationary ? T.green : T.crimson }}>{chars.isStationary ? "stationary" : "non-stationary"}</span>
                </div>
              </div>
              <div style={{ background:T.bg3, padding:"8px 10px", borderRadius:T.rSm }}>
                <div style={labelS}>Vol Clustering</div>
                <div style={{ display:"flex", alignItems:"center", gap:4 }}>
                  <StatusDot color={chars.hasVolClustering ? T.crimson : T.text3} size={6} />
                  <span style={{ ...statS, color: chars.hasVolClustering ? T.crimson : T.text3 }}>{chars.hasVolClustering ? `yes (${chars.volAutocorr.toFixed(2)})` : "no"}</span>
                </div>
              </div>
              <div style={{ background:T.bg3, padding:"8px 10px", borderRadius:T.rSm }}>
                <div style={labelS}>Noise Level</div>
                <span style={{ ...statS, color: chars.noiseLevel === "high" ? T.crimson : chars.noiseLevel === "medium" ? T.yellow : T.green }}>{chars.noiseLevel}</span>
              </div>
              <div style={{ background:T.bg3, padding:"8px 10px", borderRadius:T.rSm }}>
                <div style={labelS}>Lag-1 ACF</div>
                <span style={{ ...statS, color: chars.lag1Autocorr > 0.5 ? T.blue : T.text2 }}>{chars.lag1Autocorr.toFixed(3)}</span>
              </div>
              <div style={{ background:T.bg3, padding:"8px 10px", borderRadius:T.rSm }}>
                <div style={labelS}>Skewness</div>
                <span style={{ ...statS, color: Math.abs(chars.skewness) > 1 ? T.orange : T.text2 }}>{chars.skewness.toFixed(3)}</span>
              </div>
              <div style={{ background:T.bg3, padding:"8px 10px", borderRadius:T.rSm }}>
                <div style={labelS}>Excess Kurtosis</div>
                <span style={{ ...statS, color: Math.abs(chars.kurtosis) > 3 ? T.crimson : T.text2 }}>{chars.kurtosis.toFixed(3)}</span>
              </div>
              <div style={{ background:T.bg3, padding:"8px 10px", borderRadius:T.rSm }}>
                <div style={labelS}>Return Std</div>
                <span style={{ ...statS, color:T.text1 }}>{chars.retStd.toFixed(4)}</span>
              </div>
            </div>

            {/* ACF chart */}
            {chars.allAcfs && chars.allAcfs.length > 0 && (
              <div style={{ marginBottom:12 }}>
                <div style={labelS}>Autocorrelation at Candidate Lags</div>
                <AcfChart acfs={chars.allAcfs} width={360} height={60} />
              </div>
            )}
          </Section>

          {/* Technique Recommendations */}
          <Section title="Recommended Techniques" count={techRecs.length} color={T.orange} style={{ marginTop:12 }}>
            <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3, marginBottom:10 }}>
              Ranked by priority â€” based on detected series characteristics
            </div>
            <div style={{ display:"flex", flexDirection:"column", gap:4 }}>
              {techRecs.map((rec, idx) => {
                const tech = TECHNIQUES.find(t => t.id === rec.id);
                if (!tech) return null;
                const fc = familyColor(tech.family);
                const prioColors = { 1:T.green, 2:T.blue, 3:T.purple };
                const prioLabels = { 1:"essential", 2:"recommended", 3:"consider" };
                const pc = prioColors[rec.priority] || T.text3;
                return (
                  <div key={rec.id} style={{ display:"flex", alignItems:"center", gap:8, padding:"6px 10px",
                    background:T.bg2, borderRadius:T.rSm, border:`1px solid ${T.border0}`, borderLeft:`3px solid ${fc}` }}>
                    <Badge color={pc}>{idx + 1}</Badge>
                    <div style={{ flex:1 }}>
                      <div style={{ display:"flex", alignItems:"center", gap:6, marginBottom:2 }}>
                        <span style={{ fontFamily:T.mono, fontSize:T.fs.sm, fontWeight:600, color:T.text0 }}>{tech.name}</span>
                        <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, padding:"0.1em 0.35em", borderRadius:T.rSm,
                          background:`${fc}18`, color:fc }}>{tech.family}</span>
                        <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, padding:"0.1em 0.35em", borderRadius:T.rSm,
                          background:`${pc}18`, color:pc }}>{prioLabels[rec.priority]}</span>
                      </div>
                      <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text2 }}>{rec.reason}</div>
                    </div>
                    <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3 }}>{tech.pipelineRole}</span>
                  </div>
                );
              })}
            </div>
          </Section>

          {/* Pipeline Recommendations */}
          {pipeRecs.length > 0 && (
            <Section title="Matching Pipelines" count={pipeRecs.length} color={T.green} style={{ marginTop:12 }}>
              <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3, marginBottom:10 }}>
                Canonical pipelines that match this series' characteristics
              </div>
              <div style={{ display:"flex", flexDirection:"column", gap:6 }}>
                {pipeRecs.map(p => (
                  <div key={p.id} style={{ background:T.bg2, border:`1px solid ${T.border0}`, borderRadius:T.rMd,
                    padding:"10px 12px", borderLeft:`3px solid ${T.green}` }}>
                    <div style={{ display:"flex", alignItems:"center", gap:6, marginBottom:4 }}>
                      <span style={{ fontFamily:T.display, fontWeight:700, fontSize:T.fs.sm, color:T.text0, flex:1 }}>{p.name}</span>
                      <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, padding:"0.1em 0.35em", borderRadius:T.rSm,
                        background:T.bg4, color:T.text3 }}>complexity {p.complexity}</span>
                    </div>
                    <div style={{ fontFamily:T.body, fontSize:T.fs.xs, color:T.text2, marginBottom:6 }}>{p.description}</div>
                    <div style={{ display:"flex", gap:3, alignItems:"center", flexWrap:"wrap", marginBottom:4 }}>
                      {p.steps.map((sid, i) => {
                        const t = TECHNIQUES.find(x => x.id === sid);
                        const fc = t ? familyColor(t.family) : T.text3;
                        const isRec = techRecs.some(r => r.id === sid);
                        return (
                          <React.Fragment key={sid}>
                            {i > 0 && <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3 }}>â†’</span>}
                            <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, padding:"0.12em 0.45em", borderRadius:T.rSm,
                              background:`${fc}${isRec ? "28" : "12"}`, color:fc,
                              border:`1px solid ${fc}${isRec ? "55" : "28"}`, fontWeight: isRec ? 600 : 400 }}>
                              {t ? t.name : sid}{isRec ? " â˜…" : ""}
                            </span>
                          </React.Fragment>
                        );
                      })}
                    </div>
                    <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3 }}>{p.useCase}</div>
                  </div>
                ))}
              </div>
            </Section>
          )}
        </div>
      )}

      {/* Empty state */}
      {!feedData && !loading && !error && (
        <div style={{ textAlign:"center", padding:"32px 0", fontFamily:T.mono, fontSize:T.fs.sm, color:T.text3 }}>
          Select a live feed or synthetic generator above to analyze
        </div>
      )}
    </div>
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TAB 7: GRAPH â€” Technique network + path tracing + percolation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function GraphTab() {
  const GW = 1000, GH = 620;
  const nodeR = 18;
  const positions = useMemo(() => computeNodePositions(GH), []);

  const [selected, setSelected] = useState(null);
  const [hoveredNode, setHoveredNode] = useState(null);
  const [hoveredEdge, setHoveredEdge] = useState(null);
  const [showConflicts, setShowConflicts] = useState(true);
  const [paths, setPaths] = useState([]);
  const [activePath, setActivePath] = useState(null);
  const [showCanonical, setShowCanonical] = useState(null);

  // Percolation state
  const [percFeedId, setPercFeedId] = useState("syn_seasonal");
  const [percStages, setPercStages] = useState(null);
  const [percStep, setPercStep] = useState(-1);
  const [percRunning, setPercRunning] = useState(false);

  // Discover paths on node select
  useEffect(() => {
    if (selected) {
      const found = findSynergyPaths(selected, 5);
      setPaths(found.slice(0, 30));
    } else {
      setPaths([]);
    }
    setActivePath(null);
    setPercStages(null);
    setPercStep(-1);
    setPercRunning(false);
  }, [selected]);

  // Percolation timer â€” advances one step every 1.8 seconds
  useEffect(() => {
    if (!percRunning || !percStages) return;
    if (percStep >= percStages.length - 1) { setPercRunning(false); return; }
    const timer = setTimeout(() => setPercStep(s => s + 1), 1800);
    return () => clearTimeout(timer);
  }, [percRunning, percStep, percStages]);

  // Start percolation for a path
  const startPercolation = useCallback((pathSteps) => {
    const feed = SYNTHETIC_FEEDS.find(f => f.id === percFeedId);
    if (!feed) return;
    const rawData = feed.generate();
    const stages = percolatePipeline(rawData, pathSteps);
    setPercStages(stages);
    setPercStep(0);
    setPercRunning(true);
    setActivePath(pathSteps);
  }, [percFeedId]);

  // Build edge list
  const synergyEdges = useMemo(() => KNOWN_SYNERGIES.filter(s => positions[s.from] && positions[s.to]), [positions]);
  const conflictEdges = useMemo(() => KNOWN_CONFLICTS.filter(c => positions[c.from] && positions[c.to]), [positions]);

  // Determine highlighted nodes/edges
  const activePathSet = useMemo(() => new Set(activePath || []), [activePath]);
  const activeEdgeSet = useMemo(() => {
    if (!activePath) return new Set();
    const s = new Set();
    for (let i = 0; i < activePath.length - 1; i++) s.add(`${activePath[i]}|${activePath[i + 1]}`);
    return s;
  }, [activePath]);

  const selectedConnections = useMemo(() => {
    if (!selected) return { synTo: new Set(), synFrom: new Set(), confTo: new Set(), confFrom: new Set() };
    const synTo = new Set(), synFrom = new Set(), confTo = new Set(), confFrom = new Set();
    KNOWN_SYNERGIES.forEach(s => { if (s.from === selected) synTo.add(s.to); if (s.to === selected) synFrom.add(s.from); });
    KNOWN_CONFLICTS.forEach(c => { if (c.from === selected) confTo.add(c.to); if (c.to === selected) confFrom.add(c.from); });
    return { synTo, synFrom, confTo, confFrom };
  }, [selected]);

  // Canonical path overlay
  const canonicalEdgeSet = useMemo(() => {
    if (!showCanonical) return new Set();
    const cp = CANONICAL_PIPELINES.find(p => p.id === showCanonical);
    if (!cp) return new Set();
    const s = new Set();
    for (let i = 0; i < cp.steps.length - 1; i++) s.add(`${cp.steps[i]}|${cp.steps[i + 1]}`);
    return s;
  }, [showCanonical]);
  const canonicalNodeSet = useMemo(() => {
    if (!showCanonical) return new Set();
    const cp = CANONICAL_PIPELINES.find(p => p.id === showCanonical);
    return cp ? new Set(cp.steps) : new Set();
  }, [showCanonical]);

  // Get percolation sparkline for a node
  const percDataForNode = useCallback((techId) => {
    if (!percStages || percStep < 0) return null;
    const stage = percStages.find(s => s.techId === techId);
    if (!stage) return null;
    const stageIdx = percStages.indexOf(stage);
    if (stageIdx > percStep) return null; // not yet reached
    return stage;
  }, [percStages, percStep]);

  function edgePath(fromId, toId) {
    const a = positions[fromId], b = positions[toId];
    if (!a || !b) return "";
    const dx = b.x - a.x, dy = b.y - a.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const ox = (dx / dist) * nodeR, oy = (dy / dist) * nodeR;
    const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
    const bend = Math.abs(dy) > 200 ? dx * 0.15 : dy * 0.15;
    return `M${a.x + ox},${a.y + oy} Q${mx + bend},${my - Math.abs(bend) * 0.3} ${b.x - ox},${b.y - oy}`;
  }

  return (
    <div>
      {/* Controls */}
      <div style={{ display: "flex", gap: 8, alignItems: "center", flexWrap: "wrap", marginBottom: 12 }}>
        <button onClick={() => setShowConflicts(!showConflicts)} style={{
          fontFamily: T.mono, fontSize: "0.62rem", padding: "4px 10px", borderRadius: T.rSm,
          border: `1px solid ${showConflicts ? T.crimson : T.border1}`, background: showConflicts ? T.crimsonDim : T.bg3,
          color: showConflicts ? T.crimson : T.text2, cursor: "pointer"
        }}>{showConflicts ? "Hide" : "Show"} Conflicts ({conflictEdges.length})</button>
        <button onClick={() => { setSelected(null); setShowCanonical(null); setActivePath(null); setPercStages(null); }} style={{
          fontFamily: T.mono, fontSize: "0.62rem", padding: "4px 10px", borderRadius: T.rSm,
          border: `1px solid ${T.border1}`, background: T.bg3, color: T.text2, cursor: "pointer"
        }}>Reset</button>
        <span style={{ fontFamily: T.mono, fontSize: "0.58rem", color: T.text3, marginLeft: 4 }}>
          {TECHNIQUES.length} nodes Â· {synergyEdges.length} synergies Â· {conflictEdges.length} conflicts
        </span>
        {selected && <span style={{ fontFamily: T.mono, fontSize: "0.62rem", color: T.orange }}>
          Selected: {(TECHNIQUES.find(t => t.id === selected) || {}).name} Â· {paths.length} paths found
        </span>}
      </div>

      {/* SVG Graph */}
      <div style={{ background: T.bg1, border: `1px solid ${T.border0}`, borderRadius: T.rMd, overflow: "hidden", position: "relative" }}>
        <svg width={GW} height={GH} viewBox={`0 0 ${GW} ${GH}`} style={{ display: "block", width: "100%" }}>
          {/* Column labels */}
          {GRAPH_COL_DEFS.map((col, i) => (
            <text key={i} x={col.x} y={14} textAnchor="middle"
              style={{ fontFamily: T.mono, fontSize: 8, fill: T.text3, letterSpacing: "0.12em" }}>{col.label}</text>
          ))}
          {/* Column separator lines */}
          {GRAPH_COL_DEFS.map((col, i) => (
            <line key={`cl${i}`} x1={col.x} y1={22} x2={col.x} y2={GH - 10}
              stroke={T.border0} strokeWidth={0.5} strokeDasharray="2,4" />
          ))}

          {/* Synergy edges */}
          {synergyEdges.map((s, i) => {
            const key = `${s.from}|${s.to}`;
            const isActive = activeEdgeSet.has(key);
            const isCanon = canonicalEdgeSet.has(key);
            const isConnected = selected && (s.from === selected || s.to === selected);
            const dim = (selected || activePath || showCanonical) && !isActive && !isCanon && !isConnected;
            return (
              <path key={`syn${i}`} d={edgePath(s.from, s.to)}
                fill="none" stroke={isActive ? T.green : isCanon ? T.blue : T.green}
                strokeWidth={isActive || isCanon ? 2.5 : isConnected ? 1.8 : 0.8}
                strokeOpacity={dim ? 0.08 : isActive || isCanon ? 1 : isConnected ? 0.7 : 0.2}
                onMouseEnter={() => setHoveredEdge(s)}
                onMouseLeave={() => setHoveredEdge(null)}
                style={{ cursor: "pointer", transition: "stroke-opacity 0.3s" }}
                markerEnd={isActive || isCanon || isConnected ? "url(#arrowG)" : ""} />
            );
          })}

          {/* Conflict edges */}
          {showConflicts && conflictEdges.map((c, i) => {
            const isConnected = selected && (c.from === selected || c.to === selected);
            const dim = (selected || activePath || showCanonical) && !isConnected;
            return (
              <path key={`con${i}`} d={edgePath(c.from, c.to)}
                fill="none" stroke={T.crimson}
                strokeWidth={isConnected ? 1.5 : 0.6}
                strokeOpacity={dim ? 0.05 : isConnected ? 0.6 : 0.12}
                strokeDasharray="4,3"
                onMouseEnter={() => setHoveredEdge(c)}
                onMouseLeave={() => setHoveredEdge(null)}
                style={{ cursor: "pointer", transition: "stroke-opacity 0.3s" }} />
            );
          })}

          {/* Arrow markers */}
          <defs>
            <marker id="arrowG" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="6" markerHeight="6" orient="auto">
              <path d="M0,1 L9,5 L0,9" fill={T.green} />
            </marker>
            <marker id="arrowB" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="6" markerHeight="6" orient="auto">
              <path d="M0,1 L9,5 L0,9" fill={T.blue} />
            </marker>
          </defs>

          {/* Technique nodes */}
          {TECHNIQUES.map(t => {
            const p = positions[t.id];
            if (!p) return null;
            const fc = familyColor(t.family);
            const isSel = t.id === selected;
            const isHov = t.id === hoveredNode;
            const isOnPath = activePathSet.has(t.id);
            const isCanon = canonicalNodeSet.has(t.id);
            const isConn = selected && (selectedConnections.synTo.has(t.id) || selectedConnections.synFrom.has(t.id) || selectedConnections.confTo.has(t.id) || selectedConnections.confFrom.has(t.id));
            const dim = (selected || activePath || showCanonical) && !isSel && !isOnPath && !isCanon && !isConn;
            const percData = percDataForNode(t.id);
            const reached = !!percData;

            return (
              <g key={t.id}
                onClick={() => setSelected(s => s === t.id ? null : t.id)}
                onMouseEnter={() => setHoveredNode(t.id)}
                onMouseLeave={() => setHoveredNode(null)}
                style={{ cursor: "pointer" }}>
                {/* Glow ring for active path nodes */}
                {(isOnPath || isCanon) && reached && (
                  <circle cx={p.x} cy={p.y} r={nodeR + 5} fill="none" stroke={T.green}
                    strokeWidth={1} strokeOpacity={0.4}>
                    <animate attributeName="r" values={`${nodeR + 3};${nodeR + 7};${nodeR + 3}`} dur="2s" repeatCount="indefinite" />
                    <animate attributeName="stroke-opacity" values="0.5;0.15;0.5" dur="2s" repeatCount="indefinite" />
                  </circle>
                )}
                {/* Node circle */}
                <circle cx={p.x} cy={p.y} r={isSel ? nodeR + 2 : isHov ? nodeR + 1 : nodeR}
                  fill={dim ? T.bg3 : `${fc}22`}
                  stroke={isSel ? T.text0 : isOnPath || isCanon ? T.green : isConn ? fc : dim ? T.border0 : fc}
                  strokeWidth={isSel ? 2 : isOnPath || isCanon ? 2 : 1}
                  opacity={dim ? 0.3 : 1}
                  style={{ transition: "opacity 0.3s, stroke 0.3s" }} />
                {/* Label */}
                <text x={p.x} y={p.y + 1} textAnchor="middle" dominantBaseline="middle"
                  style={{ fontFamily: T.mono, fontSize: 7.5, fontWeight: isSel || isOnPath ? 700 : 500,
                    fill: dim ? T.text3 : isSel ? T.text0 : fc, pointerEvents: "none",
                    transition: "fill 0.3s" }}>
                  {t.name.length > 10 ? t.name.slice(0, 9) + "â€¦" : t.name}
                </text>
                {/* Percolation sparkline below node */}
                {reached && percData.values && percData.values.length > 3 && (
                  <g transform={`translate(${p.x - 25},${p.y + nodeR + 2})`}>
                    <rect x={-2} y={-1} width={54} height={18} rx={2} fill={T.bg0} fillOpacity={0.85} stroke={T.green} strokeWidth={0.5} />
                    {(() => {
                      const vals = percData.values.slice(0, 200);
                      const vMin = Math.min(...vals), vMax = Math.max(...vals), vR = vMax - vMin || 1;
                      const pts = vals.map((v, i) => `${(i / (vals.length - 1)) * 50},${15 - ((v - vMin) / vR) * 14}`).join(" ");
                      return <polyline points={pts} fill="none" stroke={T.green} strokeWidth={0.8} />;
                    })()}
                  </g>
                )}
              </g>
            );
          })}
        </svg>

        {/* Edge tooltip */}
        {hoveredEdge && (
          <div style={{
            position: "absolute", top: 10, right: 10, maxWidth: 320, padding: "8px 12px",
            background: T.bg3, border: `1px solid ${hoveredEdge.violation ? T.crimson : T.green}33`,
            borderRadius: T.rMd, zIndex: 10,
          }}>
            <div style={{ fontFamily: T.mono, fontSize: "0.68rem", color: T.text0, marginBottom: 4 }}>
              <span style={{ color: familyColor((TECHNIQUES.find(t => t.id === hoveredEdge.from) || {}).family) }}>
                {(TECHNIQUES.find(t => t.id === hoveredEdge.from) || {}).name}
              </span>
              <span style={{ color: T.text3 }}> â†’ </span>
              <span style={{ color: familyColor((TECHNIQUES.find(t => t.id === hoveredEdge.to) || {}).family) }}>
                {(TECHNIQUES.find(t => t.id === hoveredEdge.to) || {}).name}
              </span>
            </div>
            <div style={{ fontFamily: T.body, fontSize: "0.65rem", color: T.text2 }}>{hoveredEdge.reason}</div>
            {hoveredEdge.principles && <div style={{ fontFamily: T.mono, fontSize: "0.55rem", color: T.green, marginTop: 4 }}>Principles: {hoveredEdge.principles.join(", ")}</div>}
            {hoveredEdge.violation && <div style={{ fontFamily: T.mono, fontSize: "0.55rem", color: T.crimson, marginTop: 4 }}>Violates principle {hoveredEdge.violation} ({hoveredEdge.severity})</div>}
          </div>
        )}
      </div>

      {/* Bottom panels: paths + percolation + canonical */}
      <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: 12, marginTop: 12 }}>
        {/* Discovered paths */}
        <Section title={selected ? `Paths from ${(TECHNIQUES.find(t => t.id === selected) || {}).name}` : "Discovered Paths"} count={paths.length} color={T.green}>
          {!selected && <div style={{ fontFamily: T.mono, fontSize: "0.65rem", color: T.text3, padding: "12px 0" }}>Click a technique node to discover composition paths</div>}
          {paths.length > 0 && (
            <div style={{ marginBottom: 8 }}>
              <div style={{ fontFamily: T.mono, fontSize: "0.55rem", color: T.text3, marginBottom: 6 }}>Feed for percolation:</div>
              <div style={{ display: "flex", gap: 4, flexWrap: "wrap" }}>
                {SYNTHETIC_FEEDS.map(f => (
                  <button key={f.id} onClick={() => setPercFeedId(f.id)} style={{
                    fontFamily: T.mono, fontSize: "0.55rem", padding: "2px 6px", borderRadius: T.rSm,
                    background: percFeedId === f.id ? T.greenDim : T.bg3, border: `1px solid ${percFeedId === f.id ? T.green : T.border0}`,
                    color: percFeedId === f.id ? T.green : T.text3, cursor: "pointer"
                  }}>{f.name}</button>
                ))}
              </div>
            </div>
          )}
          <div style={{ maxHeight: 280, overflowY: "auto", display: "flex", flexDirection: "column", gap: 4 }}>
            {paths.map((p, idx) => {
              const isActive = activePath && activePath.join(",") === p.steps.join(",");
              return (
                <div key={idx} style={{
                  background: isActive ? T.bg4 : T.bg2, border: `1px solid ${isActive ? T.green : T.border0}`,
                  borderRadius: T.rSm, padding: "6px 8px", cursor: "pointer",
                }} onClick={() => { setActivePath(p.steps); setPercStages(null); setPercStep(-1); setPercRunning(false); }}>
                  <div style={{ display: "flex", alignItems: "center", gap: 4, marginBottom: 3, flexWrap: "wrap" }}>
                    {p.steps.map((sid, i) => {
                      const t = TECHNIQUES.find(x => x.id === sid);
                      return (
                        <React.Fragment key={sid}>
                          {i > 0 && <span style={{ fontFamily: T.mono, fontSize: "0.55rem", color: T.text3 }}>â†’</span>}
                          <span style={{ fontFamily: T.mono, fontSize: "0.58rem", color: familyColor(t?.family), fontWeight: 500 }}>
                            {t?.name || sid}
                          </span>
                        </React.Fragment>
                      );
                    })}
                    <span style={{ marginLeft: "auto", fontFamily: T.mono, fontSize: "0.55rem",
                      color: p.score > 0.8 ? T.green : p.score > 0.5 ? T.yellow : T.crimson }}>
                      {(p.score * 100).toFixed(0)}%
                    </span>
                  </div>
                  {isActive && (
                    <button onClick={(e) => { e.stopPropagation(); startPercolation(p.steps); }} style={{
                      fontFamily: T.mono, fontSize: "0.58rem", padding: "3px 8px", borderRadius: T.rSm, marginTop: 4,
                      background: T.greenDim, border: `1px solid ${T.green}44`, color: T.green, cursor: "pointer",
                    }}>
                      {percRunning ? `Percolating... step ${percStep}/${percStages?.length - 1 || "?"}` : "â–¶ Percolate Feed"}
                    </button>
                  )}
                </div>
              );
            })}
          </div>
        </Section>

        {/* Canonical pipelines + Percolation output */}
        <div>
          {/* Percolation results */}
          {percStages && percStep >= 0 && (
            <Section title="Percolation" count={`${percStep + 1}/${percStages.length}`} color={T.yellow} style={{ marginBottom: 12 }}>
              <div style={{ display: "flex", flexDirection: "column", gap: 6 }}>
                {percStages.slice(0, percStep + 1).map((stage, i) => {
                  const tech = TECHNIQUES.find(t => t.id === stage.techId);
                  const fc = tech ? familyColor(tech.family) : T.text3;
                  const vals = stage.values;
                  const isLatest = i === percStep;
                  return (
                    <div key={i} style={{
                      background: isLatest ? T.bg4 : T.bg2, border: `1px solid ${isLatest ? T.yellow : T.border0}`,
                      borderRadius: T.rSm, padding: "6px 8px", borderLeft: `3px solid ${fc}`,
                      opacity: isLatest ? 1 : 0.7, transition: "opacity 0.5s",
                    }}>
                      <div style={{ display: "flex", alignItems: "center", gap: 6, marginBottom: 4 }}>
                        <span style={{ fontFamily: T.mono, fontSize: "0.55rem", color: T.text3 }}>Step {i}</span>
                        <span style={{ fontFamily: T.mono, fontSize: "0.68rem", color: fc, fontWeight: 600 }}>
                          {tech ? tech.name : "Input"}
                        </span>
                        <span style={{ fontFamily: T.mono, fontSize: "0.55rem", color: T.text2, marginLeft: "auto" }}>{stage.label}</span>
                      </div>
                      {vals && vals.length > 3 && typeof vals[0] === 'number' && (
                        <Sparkline data={vals.slice(0, 300)} width={320} height={28} color={fc} showRange filled />
                      )}
                      {stage.band && (
                        <div style={{ fontFamily: T.mono, fontSize: "0.55rem", color: T.teal, marginTop: 2 }}>
                          Band: Â±{stage.band.toFixed(3)}
                        </div>
                      )}
                    </div>
                  );
                })}
              </div>
            </Section>
          )}

          {/* Canonical pipelines overlay selector */}
          <Section title="Canonical Pipelines" count={CANONICAL_PIPELINES.length} color={T.blue}>
            <div style={{ fontFamily: T.mono, fontSize: "0.58rem", color: T.text3, marginBottom: 8 }}>Click to highlight on graph</div>
            <div style={{ maxHeight: percStages ? 150 : 320, overflowY: "auto", display: "flex", flexDirection: "column", gap: 3 }}>
              {CANONICAL_PIPELINES.map(cp => (
                <button key={cp.id}
                  onClick={() => { setShowCanonical(s => s === cp.id ? null : cp.id); setActivePath(null); setSelected(null); }}
                  style={{
                    background: showCanonical === cp.id ? T.bg4 : T.bg2, border: `1px solid ${showCanonical === cp.id ? T.blue : T.border0}`,
                    borderRadius: T.rSm, padding: "5px 8px", cursor: "pointer", textAlign: "left", display: "block", width: "100%",
                  }}>
                  <div style={{ fontFamily: T.mono, fontSize: "0.65rem", color: T.text0, fontWeight: 600, marginBottom: 2 }}>{cp.name}</div>
                  <div style={{ display: "flex", gap: 3, alignItems: "center", flexWrap: "wrap" }}>
                    {cp.steps.map((sid, i) => (
                      <React.Fragment key={sid}>
                        {i > 0 && <span style={{ fontFamily: T.mono, fontSize: "0.5rem", color: T.text3 }}>â†’</span>}
                        <span style={{ fontFamily: T.mono, fontSize: "0.55rem",
                          color: familyColor((TECHNIQUES.find(x => x.id === sid) || {}).family) }}>
                          {(TECHNIQUES.find(x => x.id === sid) || {}).name || sid}
                        </span>
                      </React.Fragment>
                    ))}
                  </div>
                </button>
              ))}
            </div>
          </Section>
        </div>
      </div>
    </div>
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TAB 8: CAUSAL LAB â€” Full 10-step causal discovery machine
// with live data feeds, step-by-step numerical walkthrough
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Helper: compute explicit OLS coefficients and predictions for display
function olsDetailed(target, features) {
  const m = target.length, p = features[0].length;
  const A = Array.from({length:p}, () => new Array(p+1).fill(0));
  for (let i=0;i<m;i++) for (let j=0;j<p;j++) {
    A[j][p] += features[i][j]*target[i];
    for (let k=j;k<p;k++) { A[j][k] += features[i][j]*features[i][k]; if(k>j) A[k][j]=A[j][k]; }
  }
  for (let j=0;j<p;j++) A[j][j]+=1e-6;
  for (let i=0;i<p;i++) {
    let mx=i; for(let j=i+1;j<p;j++) if(Math.abs(A[j][i])>Math.abs(A[mx][i])) mx=j;
    [A[i],A[mx]]=[A[mx],A[i]]; if(Math.abs(A[i][i])<1e-12) continue;
    for(let j=i+1;j<p;j++){const f=A[j][i]/A[i][i];for(let k=i;k<=p;k++)A[j][k]-=f*A[i][k];}
  }
  const beta=new Array(p).fill(0);
  for(let i=p-1;i>=0;i--){beta[i]=A[i][p];for(let j=i+1;j<p;j++)beta[i]-=A[i][j]*beta[j];beta[i]/=A[i][i]||1;}
  const predictions=[], residuals=[];
  let rss=0, tss=0;
  const tgtMean = target.reduce((s,v)=>s+v,0)/m;
  for(let i=0;i<m;i++){
    let pred=0; for(let j=0;j<p;j++) pred+=features[i][j]*beta[j];
    predictions.push(pred);
    const resid = target[i]-pred;
    residuals.push(resid);
    rss += resid*resid;
    tss += (target[i]-tgtMean)**2;
  }
  return {beta, predictions, residuals, rss:rss/m, tss:tss/m, r2: tss>0 ? 1-rss/tss : 0};
}

// Helper: compute correlation between two arrays
function pearsonCorr(a, b) {
  const n = Math.min(a.length, b.length);
  const ma = a.slice(0,n).reduce((s,v)=>s+v,0)/n;
  const mb = b.slice(0,n).reduce((s,v)=>s+v,0)/n;
  let num=0, da=0, db=0;
  for(let i=0;i<n;i++){num+=(a[i]-ma)*(b[i]-mb);da+=(a[i]-ma)**2;db+=(b[i]-mb)**2;}
  return (da>0&&db>0) ? num/Math.sqrt(da*db) : 0;
}

function CausalTab() {
  const [causalType, setCausalType] = useState("linear");
  const [delay, setDelay] = useState(3);
  const [noise, setNoise] = useState(0.5);
  const [nPts, setNPts] = useState(300);
  const [signals, setSignals] = useState(null);
  const [results, setResults] = useState(null);
  const [steps, setSteps] = useState(null);
  const [running, setRunning] = useState(false);
  const [expandedConcept, setExpandedConcept] = useState(null);
  const [currentStep, setCurrentStep] = useState(-1);
  const [autoPlay, setAutoPlay] = useState(false);
  // Live feed causal mode
  const [feedMode, setFeedMode] = useState("synthetic"); // synthetic | live
  const [livePair, setLivePair] = useState(null);
  const [loadingFeed, setLoadingFeed] = useState(false);
  // Benchmarks
  const [benchResults, setBenchResults] = useState(null);
  const [benchRunning, setBenchRunning] = useState(false);

  // Auto-advance steps
  useEffect(() => {
    if (!autoPlay || !steps || currentStep >= steps.length - 1) { setAutoPlay(false); return; }
    const timer = setTimeout(() => setCurrentStep(s => s + 1), 1500);
    return () => clearTimeout(timer);
  }, [autoPlay, currentStep, steps]);

  // Smart default: auto-run default experiment on first mount
  const hasRun = useRef(false);
  useEffect(() => {
    if (!hasRun.current) {
      hasRun.current = true;
      runExperiment();
    }
  }, []); // eslint-disable-line react-hooks/exhaustive-deps

  // Load live feed pair for causal analysis â€” via FeedManager
  const loadLivePair = useCallback(async (feedA, feedB) => {
    setLoadingFeed(true);
    try {
      const [resultA, resultB] = await Promise.all([
        FeedManager.fetch(feedA),
        FeedManager.fetch(feedB),
      ]);
      const n = Math.min(resultA.values.length, resultB.values.length, 800);
      setSignals({ x: resultA.values.slice(0, n), y: resultB.values.slice(0, n) });
      setLivePair({ nameA: resultA.name, nameB: resultB.name });
      setSteps(null); setResults(null); setCurrentStep(-1);
    } catch(e) {
      console.error("Feed pair load failed:", e.message);
    }
    setLoadingFeed(false);
  }, []);

  const runExperiment = useCallback(() => {
    setRunning(true);
    setTimeout(() => {
      let x, y;
      if (feedMode === "live" && signals) {
        x = signals.x; y = signals.y;
      } else {
        const n = nPts;
        x = Array.from({length:n}, () => gaussianRandom());
        y = new Array(n).fill(0);
        if (causalType === "linear") {
          for (let t=delay;t<n;t++) y[t] = 0.7*x[t-delay] + noise*gaussianRandom();
        } else if (causalType === "nonlinear") {
          for (let t=delay;t<n;t++) y[t] = 0.6*Math.sin(2.5*x[t-delay]) + 0.3*x[t-delay]*x[t-delay] + noise*gaussianRandom();
        } else if (causalType === "none") {
          for (let t=0;t<n;t++) y[t] = gaussianRandom();
        } else if (causalType === "bidirectional") {
          for (let t=delay;t<n;t++) {
            y[t] = 0.5*x[t-delay] + noise*gaussianRandom();
            if (t>=delay*2) x[t] = x[t]*0.5 + 0.3*y[t-delay] + noise*0.5*gaussianRandom();
          }
        }
        setSignals({x, y});
      }

      const lags = Math.max(delay+2, 5);
      const n = Math.min(x.length, y.length);

      // â•â•â• Build the 10-step numerical walkthrough â•â•â•
      const stepData = [];

      // Step 0: The concrete problem
      stepData.push({
        id:0, title:"The Concrete Problem",
        math:"Observe X_t, Y_t. Does Y â†’ X?",
        desc:"We observe two signals and want to determine if knowing Y's past improves prediction of X's future.",
        color:T.text0,
        data:{ xSample:x.slice(0,80), ySample:y.slice(0,80), n }
      });

      // Step 1: Build Predictor A (X only) and Predictor B (X+Y)
      const target=[], featR=[], featU=[];
      for (let t=lags;t<n;t++) {
        target.push(x[t]);
        const xL=[], xyL=[];
        for(let l=1;l<=lags;l++){xL.push(x[t-l]); xyL.push(x[t-l]);}
        for(let l=1;l<=lags;l++){xyL.push(y[t-l]);}
        featR.push(xL); featU.push(xyL);
      }

      stepData.push({
        id:1, title:"Build Predictor Spaces",
        math:"H_X = span{X_{t-1},...,X_{t-L}}  vs  H_{X,Y} = span{X_{t-1},...,Y_{t-L}}",
        desc:`Predictor A uses only ${lags} lags of X. Predictor B uses ${lags} lags of X AND ${lags} lags of Y. If B does better, Y carries causal information.`,
        color:T.blue,
        data:{ lags, featRDims:[target.length, featR[0].length], featUDims:[target.length, featU[0].length],
               sampleR:featR.slice(0,5).map(r=>r.map(v=>v.toFixed(3))),
               sampleU:featU.slice(0,3).map(r=>r.map(v=>v.toFixed(3))) }
      });

      // Step 2: Compute projections (OLS)
      const restricted = olsDetailed(target, featR);
      const unrestricted = olsDetailed(target, featU);

      stepData.push({
        id:2, title:"Compute Best Predictions (Projections)",
        math:"XÌ‚ = P_H(X_{t+1}) â€” orthogonal projection onto past subspace",
        desc:`Restricted model (X only): RÂ²=${restricted.r2.toFixed(4)}, RSS=${restricted.rss.toFixed(4)}. Unrestricted model (X+Y): RÂ²=${unrestricted.r2.toFixed(4)}, RSS=${unrestricted.rss.toFixed(4)}.`,
        color:T.blue,
        data:{
          betaR:restricted.beta.slice(0,lags).map(v=>v.toFixed(4)),
          betaU_X:unrestricted.beta.slice(0,lags).map(v=>v.toFixed(4)),
          betaU_Y:unrestricted.beta.slice(lags).map(v=>v.toFixed(4)),
          predsR:restricted.predictions.slice(0,100),
          predsU:unrestricted.predictions.slice(0,100),
          actual:target.slice(0,100),
          rssR:restricted.rss, rssU:unrestricted.rss,
          r2R:restricted.r2, r2U:unrestricted.r2,
        }
      });

      // Step 3: Compute innovations (residuals)
      stepData.push({
        id:3, title:"Compute Innovation (Residual)",
        math:"Îµ_{t+1} = X_{t+1} âˆ’ P_H(X_{t+1}) â€” the unpredictable part",
        desc:`Residual is orthogonal to the past. It is the irreducible uncertainty. Restricted residual Ïƒ=${Math.sqrt(restricted.rss).toFixed(4)}, Unrestricted residual Ïƒ=${Math.sqrt(unrestricted.rss).toFixed(4)}.`,
        color:T.orange,
        data:{
          residR:restricted.residuals.slice(0,100),
          residU:unrestricted.residuals.slice(0,100),
          residR_std: Math.sqrt(restricted.rss),
          residU_std: Math.sqrt(unrestricted.rss),
        }
      });

      // Step 4: Test orthogonality â€” does residual correlate with Y?
      const yLagged = [];
      for (let t=lags;t<n;t++) yLagged.push(y[t-1]);
      const corrResidY = pearsonCorr(restricted.residuals, yLagged);
      const corrResidY_U = pearsonCorr(unrestricted.residuals, yLagged);

      stepData.push({
        id:4, title:"Test Orthogonality â€” Does Y Predict the Residual?",
        math:"âŸ¨Îµ^(X)_{t+1}, Y_tâŸ© â‰  0  âŸ¹  Y causes X",
        desc:`Corr(restricted residual, Y_{t-1}) = ${corrResidY.toFixed(4)}. ${Math.abs(corrResidY) > 0.05 ? "Non-zero! Y contains information about X's future." : "Near zero â€” Y adds no new information."} After adding Y to the model: Corr(unrestricted residual, Y_{t-1}) = ${corrResidY_U.toFixed(4)} (should be ~0 if model absorbed the signal).`,
        color: Math.abs(corrResidY) > 0.05 ? T.green : T.text3,
        data:{ corrResidY, corrResidY_U, isCausal: Math.abs(corrResidY) > 0.05 }
      });

      // Step 5: Reduction in residual energy â€” the causal test statistic
      const reduction = restricted.rss > 0 ? 1 - unrestricted.rss/restricted.rss : 0;
      const fStat = lags > 0 ? ((restricted.rss-unrestricted.rss)/lags)/(unrestricted.rss/Math.max(1,target.length-2*lags-1)) : 0;

      stepData.push({
        id:5, title:"Residual Energy Reduction = Granger Causality",
        math:"Yâ†’X âŸº â€–Îµ^(X,Y)â€– < â€–Îµ^(X)â€– â€” pure geometry of distances",
        desc:`Adding Y reduced prediction error by ${(reduction*100).toFixed(2)}%. F-statistic = ${fStat.toFixed(2)}. This is the classical Granger test â€” completely equivalent to comparing projection residuals in LÂ² Hilbert space.`,
        color: reduction > 0.05 ? T.green : T.text3,
        data:{ reduction, fStat, rssR:restricted.rss, rssU:unrestricted.rss }
      });

      // Step 6: Why linear fails on nonlinear data â€” motivate RKHS
      stepData.push({
        id:6, title:"Nonlinear Signals Break Linear Projections",
        math:"X_{t+1} = sin(Y_t) + YÂ²_t + Îµ â€” linear P_H cannot see this",
        desc: causalType === "nonlinear"
          ? `This experiment uses a nonlinear relationship. Linear Granger found ${(reduction*100).toFixed(1)}% reduction â€” it may miss the full causal signal. We need a bigger Hilbert space.`
          : `In this experiment the relationship is ${causalType}. Linear projection ${reduction > 0.05 ? "was sufficient" : "found nothing"}.`,
        color:T.orange,
        data:{ causalType, linearReduction: reduction }
      });

      // Step 7: RKHS lift â€” kernel Granger
      const kXY = kernelGrangerTest(x, y, lags);
      const kYX = kernelGrangerTest(y, x, lags);

      stepData.push({
        id:7, title:"Lift into RKHS â€” Kernel Granger Causality",
        math:"Ï†(x) âˆˆ H_k,  k(x,y) = exp(âˆ’â€–xâˆ’yâ€–Â²/2ÏƒÂ²) â€” RBF kernel",
        desc:`Kernel bandwidth Ïƒ=${kXY.sigma.toFixed(3)} (median heuristic). Xâ†’Y kernel reduction: ${(kXY.reduction*100).toFixed(1)}%. Yâ†’X kernel reduction: ${(kYX.reduction*100).toFixed(1)}%. Nonlinear projections in RKHS can detect causal links invisible to linear methods.`,
        color:T.orange,
        data:{ kXY, kYX }
      });

      // Step 8: HSIC â€” cross-covariance operator norm
      const hXY = hsicTest(x.slice(lags), y.slice(lags));
      const hYX = hsicTest(y.slice(lags), x.slice(lags));

      stepData.push({
        id:8, title:"Cross-Covariance Operator â€” HSIC",
        math:"â€–C_XYâ€–Â²_HS = â€–E[Ï†(X)âŠ—Ïˆ(Y)]â€–Â² â€” if 0, independent",
        desc:`HSIC(X,Y) = ${hXY.hsic.toFixed(6)}. ${hXY.hsic > 0.01 ? "Strong" : hXY.hsic > 0.001 ? "Weak" : "No"} dependence. This measures ALL dependence (linear + nonlinear) via the Hilbert-Schmidt norm of the cross-covariance operator.`,
        color: hXY.hsic > 0.001 ? T.teal : T.text3,
        data:{ hXY, hYX }
      });

      // Step 9: Time direction emerges
      stepData.push({
        id:9, title:"Time Direction Emerges Automatically",
        math:"H_{t-2} âŠ‚ H_{t-1} âŠ‚ H_t â€” nested past subspaces",
        desc:`Forward (Xâ†’Y): linear ${(reduction*100).toFixed(1)}%, kernel ${(kXY.reduction*100).toFixed(1)}%. Reverse (Yâ†’X): linear ${(grangerTest(y,x,lags).reduction*100).toFixed(1)}%, kernel ${(kYX.reduction*100).toFixed(1)}%. The asymmetry in residual reduction IS the arrow of causation â€” no direction imposed, it emerges from projecting onto past-only subspaces.`,
        color:T.purple,
        data:{ fwd:{lin:reduction, ker:kXY.reduction}, rev:{lin:grangerTest(y,x,lags).reduction, ker:kYX.reduction} }
      });

      // Step 10: Summary verdict
      const linFwd=reduction>0.05, kerFwd=kXY.reduction>0.05;
      const linRev=grangerTest(y,x,lags).reduction>0.05, kerRev=kYX.reduction>0.05;
      let verdict="";
      if(linFwd && kerFwd) verdict="Strong Xâ†’Y causation (linear + nonlinear)";
      else if(!linFwd && kerFwd) verdict="Nonlinear Xâ†’Y causation (only visible in RKHS)";
      else if(linFwd) verdict="Linear Xâ†’Y causation";
      else verdict="No Xâ†’Y causation detected";
      if(linRev||kerRev) verdict += `. Reverse Yâ†’X also present (${linRev?"linear":""}${linRev&&kerRev?"+":""}${kerRev?"kernel":""})`;

      stepData.push({
        id:10, title:"Verdict â€” Geometry of Information",
        math:"Causal discovery = which variables change the orthogonal decomposition of future information",
        desc: verdict,
        color: (linFwd||kerFwd) ? T.green : T.text3,
        data:{ verdict, linFwd, kerFwd, linRev, kerRev, hsic:hXY.hsic }
      });

      setSteps(stepData);
      setResults({
        linXY:{reduction, fStat, rssR:restricted.rss, rssU:unrestricted.rss, n:target.length},
        linYX:grangerTest(y,x,lags), kXY, kYX, hXY
      });
      setCurrentStep(0);
      setRunning(false);
    }, 80);
  }, [causalType, delay, noise, nPts, feedMode, signals]);

  // â•â•â• BENCHMARK RUNNER â•â•â•
  const runBenchmarks = useCallback(() => {
    setBenchRunning(true);
    setTimeout(() => {
      const scenarios = [
        { id:"linear", label:"Linear Xâ†’Y", gen:(n,d,Ïƒ) => {
          const x=Array.from({length:n},()=>gaussianRandom()), y=new Array(n).fill(0);
          for(let t=d;t<n;t++) y[t]=0.7*x[t-d]+Ïƒ*gaussianRandom();
          return {x,y};
        }},
        { id:"nonlinear", label:"Nonlinear Xâ†’Y", gen:(n,d,Ïƒ) => {
          const x=Array.from({length:n},()=>gaussianRandom()), y=new Array(n).fill(0);
          for(let t=d;t<n;t++) y[t]=0.6*Math.sin(2.5*x[t-d])+0.3*x[t-d]*x[t-d]+Ïƒ*gaussianRandom();
          return {x,y};
        }},
        { id:"none", label:"Independent", gen:(n,d,Ïƒ) => ({
          x:Array.from({length:n},()=>gaussianRandom()),
          y:Array.from({length:n},()=>gaussianRandom())
        })},
        { id:"bidirectional", label:"Xâ†”Y Mutual", gen:(n,d,Ïƒ) => {
          const x=Array.from({length:n},()=>gaussianRandom()), y=new Array(n).fill(0);
          for(let t=d;t<n;t++){y[t]=0.5*x[t-d]+Ïƒ*gaussianRandom();if(t>=d*2)x[t]=x[t]*0.5+0.3*y[t-d]+Ïƒ*0.5*gaussianRandom();}
          return {x,y};
        }},
      ];
      const noiseLevels = [0.3, 0.5, 1.0, 1.5];
      const sampleSizes = [150, 300, 500];
      const nTrials = 3;
      const lag = 3, lags = 5;
      const results = [];

      for (const sc of scenarios) {
        for (const Ïƒ of noiseLevels) {
          for (const n of sampleSizes) {
            let linDet=0, kerDet=0, hsicDet=0, linTime=0, kerTime=0, hsicTime=0;
            for (let trial=0; trial<nTrials; trial++) {
              const {x,y} = sc.gen(n, lag, Ïƒ);
              const t0 = performance.now();
              const gt = grangerTest(x,y,lags);
              linTime += performance.now()-t0;
              const t1 = performance.now();
              const kt = kernelGrangerTest(x,y,lags);
              kerTime += performance.now()-t1;
              const t2 = performance.now();
              const ht = hsicTest(x.slice(lags),y.slice(lags));
              hsicTime += performance.now()-t2;
              if(gt.reduction>0.05) linDet++;
              if(kt.reduction>0.05) kerDet++;
              if(ht.hsic>0.001) hsicDet++;
            }
            results.push({
              scenario:sc.id, label:sc.label, noise:Ïƒ, n,
              linRate:linDet/nTrials, kerRate:kerDet/nTrials, hsicRate:hsicDet/nTrials,
              linMs:(linTime/nTrials).toFixed(1), kerMs:(kerTime/nTrials).toFixed(1), hsicMs:(hsicTime/nTrials).toFixed(1),
            });
          }
        }
      }
      setBenchResults(results);
      setBenchRunning(false);
    }, 50);
  }, []);

  const labelS = { fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:5 };
  const statS = { fontFamily:T.mono, fontSize:T.fs.sm };

  // Pairs for live feed causal analysis
  const livePairs = [
    { label:"Berlin Temp â†’ NYC Temp", a:LIVE_FEEDS[0], b:LIVE_FEEDS[1] },
    { label:"BTC â†’ ETH (crypto coupling)", a:LIVE_FEEDS[8], b:LIVE_FEEDS[9] },
    { label:"BTC â†’ SOL", a:LIVE_FEEDS[8], b:LIVE_FEEDS[10] },
    { label:"ETH â†’ SOL", a:LIVE_FEEDS[9], b:LIVE_FEEDS[10] },
    { label:"Berlin Wind â†’ Berlin Temp", a:LIVE_FEEDS[4], b:LIVE_FEEDS[0] },
    { label:"Tokyo Temp â†’ Sydney Temp", a:LIVE_FEEDS[2], b:LIVE_FEEDS[3] },
    { label:"Reykjavik Pressure â†’ London Rain", a:LIVE_FEEDS[7], b:LIVE_FEEDS[5] },
  ];

  return (
    <div>
      {/* â•â•â• Compact Hilbert â†” Causality Reference â•â•â• */}
      <Section title="Hilbert Space â†” Causality" count={HILBERT_CONCEPTS.length} color={T.purple}>
        <div style={{ fontFamily:T.body, fontSize:T.fs.sm, color:T.text2, marginBottom:12, lineHeight:1.6 }}>
          Causal discovery is <strong style={{color:T.text0}}>geometry of information</strong>: which variables change the orthogonal decomposition of future information?
          All methods differ only by what Hilbert space they embed into, how they approximate projections, and how they test orthogonality.
        </div>
        <div style={{ display:"grid", gridTemplateColumns:"repeat(auto-fill, minmax(180px,1fr))", gap:6, marginBottom:12 }}>
          {[
            {concept:"Prediction", hilbert:"Projection P_H", color:T.blue},
            {concept:"Independence", hilbert:"Orthogonality", color:T.green},
            {concept:"Causality", hilbert:"Subspace expansion", color:T.orange},
            {concept:"Nonlinearity", hilbert:"RKHS lift Ï†(x)", color:T.orange},
            {concept:"Total dependence", hilbert:"â€–C_XYâ€–_HS", color:T.teal},
            {concept:"Time direction", hilbert:"Nested H_{t-1}âŠ‚H_t", color:T.purple},
          ].map((r,i) => (
            <div key={i} style={{ display:"flex", alignItems:"center", gap:6, padding:"5px 8px", background:T.bg3, borderRadius:T.rSm }}>
              <StatusDot color={r.color} size={5} />
              <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text1, flex:1 }}>{r.concept}</span>
              <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:r.color }}>= {r.hilbert}</span>
            </div>
          ))}
        </div>
        {/* Expandable concept cards */}
        <div style={{ display:"flex", flexDirection:"column", gap:6 }}>
          {HILBERT_CONCEPTS.map(hc => {
            const isOpen = expandedConcept === hc.id;
            return (
              <div key={hc.id} style={{ background:T.bg2, border:`1px solid ${T.border0}`, borderRadius:T.rMd, overflow:"hidden", borderLeft:`3px solid ${hc.color}` }}>
                <div onClick={() => setExpandedConcept(isOpen ? null : hc.id)} style={{ padding:"8px 10px", cursor:"pointer" }}>
                  <div style={{ display:"flex", alignItems:"center", gap:6 }}>
                    <span style={{ fontFamily:T.mono, fontSize:T.fs.sm, fontWeight:600, color:hc.color }}>{hc.symbol}</span>
                    <span style={{ fontFamily:T.display, fontWeight:700, fontSize:T.fs.md, color:T.text0, flex:1 }}>{hc.name}</span>
                    <Badge color={hc.color}>{hc.techniques.length}</Badge>
                    <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3, transform:isOpen?"rotate(90deg)":"rotate(0)", transition:"transform 0.2s" }}>â–¸</span>
                  </div>
                  <div style={{ fontFamily:T.body, fontSize:T.fs.xs, color:T.text2, marginTop:4 }}>{hc.description}</div>
                </div>
                <div style={{ maxHeight:isOpen?400:0, overflow:"hidden", transition:"max-height 0.3s ease" }}>
                  <div style={{ padding:"0 10px 10px", borderTop:`1px solid ${T.border0}` }}>
                    <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text1, padding:"8px 0 6px" }}>
                      <span style={{color:T.text3}}>Hilbert: </span>{hc.hilbertMeaning}
                    </div>
                    <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text1, paddingBottom:8, borderBottom:`1px dashed ${T.border0}` }}>
                      <span style={{color:T.text3}}>Causal role: </span>{hc.causalRole}
                    </div>
                    <div style={{ marginTop:8 }}>
                      <div style={labelS}>Techniques using this structure</div>
                      <div style={{ display:"flex", gap:3, flexWrap:"wrap" }}>
                        {hc.techniques.map(tid => {
                          const t=TECHNIQUES.find(x=>x.id===tid);
                          return t ? (
                            <span key={tid} style={{ fontFamily:T.mono, fontSize:T.fs.xs, padding:"0.12em 0.4em", borderRadius:T.rSm,
                              background:`${familyColor(t.family)}15`, color:familyColor(t.family), border:`1px solid ${familyColor(t.family)}28` }}>
                              {t.name}
                            </span>
                          ) : null;
                        })}
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            );
          })}
        </div>
      </Section>

      {/* â•â•â• CAUSAL DISCOVERY MACHINE â•â•â• */}
      <Section title="Causal Discovery Machine" color={T.orange} style={{ marginTop:12 }}>
        <div style={{ fontFamily:T.body, fontSize:T.fs.sm, color:T.text2, marginBottom:12, lineHeight:1.6 }}>
          Step-by-step numerical walkthrough: data â†’ predictor spaces â†’ projections â†’ residuals â†’ orthogonality test â†’ verdict.
          Uses <strong style={{color:T.blue}}>linear Granger</strong> (LÂ² projection),
          <strong style={{color:T.orange}}> kernel Granger</strong> (RKHS projection), and
          <strong style={{color:T.teal}}> HSIC</strong> (cross-covariance operator norm).
        </div>

        {/* Data source toggle */}
        <div style={{ display:"flex", gap:4, marginBottom:12 }}>
          <button onClick={() => setFeedMode("synthetic")} style={{
            fontFamily:T.mono, fontSize:T.fs.xs, padding:"6px 14px", borderRadius:T.rSm, cursor:"pointer",
            background:feedMode==="synthetic"?T.orangeDim:T.bg3, border:`1px solid ${feedMode==="synthetic"?T.orange:T.border0}`,
            color:feedMode==="synthetic"?T.orange:T.text2, fontWeight:feedMode==="synthetic"?600:400,
          }}>Synthetic Signals</button>
          <button onClick={() => setFeedMode("live")} style={{
            fontFamily:T.mono, fontSize:T.fs.xs, padding:"6px 14px", borderRadius:T.rSm, cursor:"pointer",
            background:feedMode==="live"?T.blueDim:T.bg3, border:`1px solid ${feedMode==="live"?T.blue:T.border0}`,
            color:feedMode==="live"?T.blue:T.text2, fontWeight:feedMode==="live"?600:400,
          }}>Live Data Feeds</button>
        </div>

        {feedMode === "synthetic" ? (
          <div style={{ display:"grid", gridTemplateColumns:"repeat(auto-fill, minmax(160px,1fr))", gap:8, marginBottom:12 }}>
            <div>
              <div style={labelS}>Causal Structure</div>
              <div style={{ display:"flex", flexDirection:"column", gap:3 }}>
                {[["linear","Xâ†’Y linear"],["nonlinear","Xâ†’Y nonlinear"],["none","Independent"],["bidirectional","Xâ†”Y mutual"]].map(([k,l]) => (
                  <button key={k} onClick={() => setCausalType(k)} style={{
                    fontFamily:T.mono, fontSize:T.fs.xs, padding:"4px 8px", borderRadius:T.rSm, cursor:"pointer", textAlign:"left",
                    background:causalType===k?T.orangeDim:T.bg3, border:`1px solid ${causalType===k?T.orange:T.border0}`,
                    color:causalType===k?T.orange:T.text2,
                  }}>{l}</button>
                ))}
              </div>
            </div>
            <div>
              <div style={labelS}>Delay (lags)</div>
              <input type="range" min={1} max={10} value={delay} onChange={e=>setDelay(+e.target.value)} style={{width:"100%"}} />
              <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text0, textAlign:"center" }}>{delay}</div>
            </div>
            <div>
              <div style={labelS}>Noise Ïƒ</div>
              <input type="range" min={0} max={2} step={0.1} value={noise} onChange={e=>setNoise(+e.target.value)} style={{width:"100%"}} />
              <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text0, textAlign:"center" }}>{noise.toFixed(1)}</div>
            </div>
            <div>
              <div style={labelS}>Sample size</div>
              <input type="range" min={100} max={800} step={50} value={nPts} onChange={e=>setNPts(+e.target.value)} style={{width:"100%"}} />
              <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text0, textAlign:"center" }}>{nPts}</div>
            </div>
          </div>
        ) : (
          <div style={{ marginBottom:12 }}>
            <div style={labelS}>Select signal pair for causal analysis</div>
            <div style={{ display:"grid", gridTemplateColumns:"repeat(auto-fill, minmax(220px,1fr))", gap:6 }}>
              {livePairs.map((lp,i) => (
                <button key={i} onClick={() => loadLivePair(lp.a, lp.b)} style={{
                  fontFamily:T.mono, fontSize:T.fs.xs, padding:"8px 10px", borderRadius:T.rSm, cursor:"pointer", textAlign:"left",
                  background:livePair && livePair.nameA===(lp.a.parse ? lp.a.name : lp.label) ? T.blueDim : T.bg3,
                  border:`1px solid ${T.border0}`, borderLeft:`3px solid ${T.blue}`, display:"block", width:"100%",
                }}>
                  <div style={{ color:T.text0, fontWeight:600 }}>{lp.label}</div>
                  <div style={{ fontSize:T.fs.xs, color:T.text3, marginTop:2 }}>Real-time data via API</div>
                </button>
              ))}
            </div>
            {loadingFeed && <div style={{ padding:"12px 0", fontFamily:T.mono, fontSize:T.fs.sm, color:T.blue }}><StatusDot color={T.blue} pulse size={8} /> Fetching live data...</div>}
          </div>
        )}

        {/* Run button */}
        <div style={{ display:"flex", gap:8, alignItems:"center", marginBottom:12 }}>
          <button onClick={runExperiment} disabled={running || (feedMode==="live" && !signals)} style={{
            fontFamily:T.mono, fontSize:T.fs.sm, padding:"8px 20px", borderRadius:T.rMd, cursor:running?"wait":"pointer",
            background:T.orangeDim, border:`1px solid ${T.orange}44`, color:T.orange, fontWeight:600,
          }}>{running ? "Computing projections..." : "â–¶ Run Full Causal Analysis"}</button>
          {steps && (
            <React.Fragment>
              <button onClick={() => {setCurrentStep(0);setAutoPlay(true);}} style={{
                fontFamily:T.mono, fontSize:T.fs.xs, padding:"6px 12px", borderRadius:T.rSm, cursor:"pointer",
                background:T.greenDim, border:`1px solid ${T.green}44`, color:T.green,
              }}>â–¶ Auto-play Steps</button>
              <button onClick={() => setCurrentStep(steps.length-1)} style={{
                fontFamily:T.mono, fontSize:T.fs.xs, padding:"6px 12px", borderRadius:T.rSm, cursor:"pointer",
                background:T.bg3, border:`1px solid ${T.border1}`, color:T.text2,
              }}>Skip to Verdict</button>
            </React.Fragment>
          )}
        </div>

        {/* Signal display */}
        {signals && (
          <div style={{ display:"grid", gridTemplateColumns:"1fr 1fr", gap:10, marginBottom:12 }}>
            <div style={{ background:T.bg3, padding:"8px 10px", borderRadius:T.rSm }}>
              <div style={labelS}>{livePair ? livePair.nameA : "X (driver)"}</div>
              <Sparkline data={signals.x.slice(0,400)} width={450} height={50} color={T.blue} filled showRange />
              <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3, marginTop:2 }}>n={signals.x.length} Â· Î¼={((signals.x.reduce((s,v)=>s+v,0))/signals.x.length).toFixed(2)} Â· Ïƒ={Math.sqrt(signals.x.reduce((s,v)=>s+(v-(signals.x.reduce((a,b)=>a+b,0)/signals.x.length))**2,0)/signals.x.length).toFixed(2)}</div>
            </div>
            <div style={{ background:T.bg3, padding:"8px 10px", borderRadius:T.rSm }}>
              <div style={labelS}>{livePair ? livePair.nameB : "Y (response)"}</div>
              <Sparkline data={signals.y.slice(0,400)} width={450} height={50} color={T.orange} filled showRange />
              <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3, marginTop:2 }}>n={signals.y.length} Â· Î¼={((signals.y.reduce((s,v)=>s+v,0))/signals.y.length).toFixed(2)} Â· Ïƒ={Math.sqrt(signals.y.reduce((s,v)=>s+(v-(signals.y.reduce((a,b)=>a+b,0)/signals.y.length))**2,0)/signals.y.length).toFixed(2)}</div>
            </div>
          </div>
        )}

        {/* â•â•â• STEP-BY-STEP WALKTHROUGH â•â•â• */}
        {steps && (
          <div style={{ marginTop:8 }}>
            {/* Step navigation */}
            <div style={{ display:"flex", gap:2, marginBottom:12, overflowX:"auto", paddingBottom:4 }}>
              {steps.map((step,i) => (
                <button key={i} onClick={() => {setCurrentStep(i);setAutoPlay(false);}} style={{
                  fontFamily:T.mono, fontSize:T.fs.xs, padding:"4px 8px", borderRadius:T.rSm, cursor:"pointer",
                  minWidth:28, textAlign:"center",
                  background: i<=currentStep ? `${step.color}22` : T.bg3,
                  border:`1px solid ${i===currentStep ? step.color : i<=currentStep ? `${step.color}44` : T.border0}`,
                  color: i<=currentStep ? step.color : T.text3,
                  fontWeight: i===currentStep ? 700 : 400,
                }}>{i}</button>
              ))}
            </div>

            {/* Visible steps */}
            <div style={{ display:"flex", flexDirection:"column", gap:8 }}>
              {steps.slice(0, currentStep+1).map((step,idx) => {
                const isActive = idx === currentStep;
                return (
                  <div key={step.id} style={{
                    background:isActive ? T.bg3 : T.bg2,
                    border:`1px solid ${isActive ? step.color : T.border0}`,
                    borderRadius:T.rMd, overflow:"hidden",
                    borderLeft:`3px solid ${step.color}`,
                    opacity: isActive ? 1 : 0.7,
                    transition:"opacity 0.3s, border-color 0.3s",
                  }}>
                    <div style={{ padding:"10px 14px" }}>
                      <div style={{ display:"flex", alignItems:"center", gap:8, marginBottom:4 }}>
                        <Badge color={step.color}>{step.id}</Badge>
                        <span style={{ fontFamily:T.display, fontWeight:700, fontSize:T.fs.md, color:T.text0, flex:1 }}>{step.title}</span>
                      </div>
                      <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:step.color, marginBottom:4, padding:"4px 8px", background:`${step.color}0a`, borderRadius:T.rSm, display:"inline-block" }}>
                        {step.math}
                      </div>
                      <div style={{ fontFamily:T.body, fontSize:T.fs.sm, color:T.text2, lineHeight:1.5 }}>{step.desc}</div>

                      {/* Step-specific visualizations */}
                      {step.id === 0 && step.data && (
                        <div style={{ display:"grid", gridTemplateColumns:"1fr 1fr", gap:8, marginTop:8 }}>
                          <div><div style={labelS}>X sample (first 80)</div><Sparkline data={step.data.xSample} width={350} height={30} color={T.blue} /></div>
                          <div><div style={labelS}>Y sample (first 80)</div><Sparkline data={step.data.ySample} width={350} height={30} color={T.orange} /></div>
                        </div>
                      )}
                      {step.id === 1 && step.data && (
                        <div style={{ marginTop:8 }}>
                          <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text2, marginBottom:4 }}>
                            Restricted (X only): <span style={{color:T.blue}}>{step.data.featRDims[0]} obs Ã— {step.data.featRDims[1]} features</span>
                            &nbsp;| Unrestricted (X+Y): <span style={{color:T.orange}}>{step.data.featUDims[0]} obs Ã— {step.data.featUDims[1]} features</span>
                          </div>
                          <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3, background:T.bg2, padding:"4px 8px", borderRadius:T.rSm, overflowX:"auto", maxWidth:"100%" }}>
                            Feature row [X_{"{t-1}"},...,X_{"{t-"+step.data.lags+"}"}]: [{step.data.sampleR[0]?.join(", ")}]
                          </div>
                        </div>
                      )}
                      {step.id === 2 && step.data && (
                        <div style={{ marginTop:8 }}>
                          <div style={{ display:"grid", gridTemplateColumns:"1fr 1fr", gap:8 }}>
                            <div>
                              <div style={{...labelS, color:T.blue}}>Restricted Prediction (X only) â€” RÂ²={step.data.r2R.toFixed(4)}</div>
                              <Sparkline data={step.data.predsR} width={350} height={35} color={T.blue} />
                              <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3, marginTop:2 }}>Î²_X = [{step.data.betaR.join(", ")}]</div>
                            </div>
                            <div>
                              <div style={{...labelS, color:T.orange}}>Unrestricted Prediction (X+Y) â€” RÂ²={step.data.r2U.toFixed(4)}</div>
                              <Sparkline data={step.data.predsU} width={350} height={35} color={T.orange} />
                              <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3, marginTop:2 }}>Î²_Y = [{step.data.betaU_Y.join(", ")}]</div>
                            </div>
                          </div>
                          <div style={{ marginTop:4 }}><div style={labelS}>Actual target</div><Sparkline data={step.data.actual} width={720} height={25} color={T.text2} /></div>
                        </div>
                      )}
                      {step.id === 3 && step.data && (
                        <div style={{ display:"grid", gridTemplateColumns:"1fr 1fr", gap:8, marginTop:8 }}>
                          <div>
                            <div style={{...labelS, color:T.blue}}>Îµ restricted (Ïƒ={step.data.residR_std.toFixed(4)})</div>
                            <Sparkline data={step.data.residR} width={350} height={35} color={T.blue} />
                          </div>
                          <div>
                            <div style={{...labelS, color:T.orange}}>Îµ unrestricted (Ïƒ={step.data.residU_std.toFixed(4)})</div>
                            <Sparkline data={step.data.residU} width={350} height={35} color={T.orange} />
                          </div>
                        </div>
                      )}
                      {step.id === 4 && step.data && (
                        <div style={{ marginTop:8, padding:"8px 12px", background:step.data.isCausal?T.greenDim:T.bg2, borderRadius:T.rSm, border:`1px solid ${step.data.isCausal?T.green:T.border0}33` }}>
                          <div style={{ fontFamily:T.mono, fontSize:T.fs.sm, color:step.data.isCausal?T.green:T.text3, fontWeight:700 }}>
                            Corr(Îµ, Y) = {step.data.corrResidY.toFixed(4)} {step.data.isCausal?"â†’ CAUSAL SIGNAL DETECTED":"â†’ no signal"}
                          </div>
                          <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text2, marginTop:2 }}>
                            After absorbing Y: Corr(Îµ_full, Y) = {step.data.corrResidY_U.toFixed(4)}
                          </div>
                        </div>
                      )}
                      {step.id === 5 && step.data && (
                        <div style={{ marginTop:8 }}>
                          <div style={{ display:"flex", alignItems:"center", gap:10 }}>
                            <div style={{ flex:1 }}>
                              <ProgressBar value={Math.min(1,Math.abs(step.data.reduction))} color={step.data.reduction>0.05?T.green:T.text3} thick />
                            </div>
                            <span style={{ fontFamily:T.display, fontWeight:700, fontSize:"1.3rem", color:step.data.reduction>0.05?T.green:T.text3 }}>
                              {(step.data.reduction*100).toFixed(1)}%
                            </span>
                          </div>
                          <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3, marginTop:4 }}>
                            RSS restricted: {step.data.rssR.toFixed(4)} â†’ RSS unrestricted: {step.data.rssU.toFixed(4)} | F = {step.data.fStat.toFixed(2)}
                          </div>
                        </div>
                      )}
                      {step.id === 7 && step.data && (
                        <div style={{ display:"grid", gridTemplateColumns:"1fr 1fr", gap:8, marginTop:8 }}>
                          <div style={{ background:T.bg2, padding:"6px 10px", borderRadius:T.rSm }}>
                            <div style={labelS}>X â†’ Y (kernel)</div>
                            <div style={{ display:"flex", alignItems:"center", gap:6 }}>
                              <ProgressBar value={Math.abs(step.data.kXY.reduction)} color={step.data.kXY.reduction>0.05?T.green:T.text3} thick />
                              <span style={{ fontFamily:T.mono, fontSize:T.fs.sm, color:step.data.kXY.reduction>0.05?T.green:T.text3, fontWeight:700 }}>{(step.data.kXY.reduction*100).toFixed(1)}%</span>
                            </div>
                          </div>
                          <div style={{ background:T.bg2, padding:"6px 10px", borderRadius:T.rSm }}>
                            <div style={labelS}>Y â†’ X (kernel)</div>
                            <div style={{ display:"flex", alignItems:"center", gap:6 }}>
                              <ProgressBar value={Math.abs(step.data.kYX.reduction)} color={step.data.kYX.reduction>0.05?T.green:T.text3} thick />
                              <span style={{ fontFamily:T.mono, fontSize:T.fs.sm, color:step.data.kYX.reduction>0.05?T.green:T.text3, fontWeight:700 }}>{(step.data.kYX.reduction*100).toFixed(1)}%</span>
                            </div>
                          </div>
                        </div>
                      )}
                      {step.id === 8 && step.data && (
                        <div style={{ marginTop:8, display:"flex", alignItems:"center", gap:12, padding:"8px 12px", background:T.bg2, borderRadius:T.rSm }}>
                          <div>
                            <div style={{ fontFamily:T.display, fontWeight:700, fontSize:"1.4rem", color:T.teal, lineHeight:1 }}>
                              {step.data.hXY.hsic.toFixed(6)}
                            </div>
                            <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3 }}>HSIC(X,Y)</div>
                          </div>
                          <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:step.data.hXY.hsic>0.001?T.green:T.text3 }}>
                            {step.data.hXY.hsic>0.01?"Strong dependence":step.data.hXY.hsic>0.001?"Weak dependence":"Near-independent"} Â· Ïƒ={step.data.hXY.sigma.toFixed(2)}
                          </div>
                        </div>
                      )}
                      {step.id === 9 && step.data && (
                        <div style={{ display:"grid", gridTemplateColumns:"1fr 1fr", gap:8, marginTop:8 }}>
                          <div style={{ background:T.bg2, padding:"8px 10px", borderRadius:T.rSm, borderLeft:`3px solid ${T.green}` }}>
                            <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.green, fontWeight:700, marginBottom:4 }}>Forward X â†’ Y</div>
                            <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text2 }}>Linear: {(step.data.fwd.lin*100).toFixed(1)}%</div>
                            <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text2 }}>Kernel: {(step.data.fwd.ker*100).toFixed(1)}%</div>
                          </div>
                          <div style={{ background:T.bg2, padding:"8px 10px", borderRadius:T.rSm, borderLeft:`3px solid ${T.yellow}` }}>
                            <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.yellow, fontWeight:700, marginBottom:4 }}>Reverse Y â†’ X</div>
                            <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text2 }}>Linear: {(step.data.rev.lin*100).toFixed(1)}%</div>
                            <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text2 }}>Kernel: {(step.data.rev.ker*100).toFixed(1)}%</div>
                          </div>
                        </div>
                      )}
                      {step.id === 10 && step.data && (
                        <div style={{ marginTop:8, padding:"10px 14px", background:(step.data.linFwd||step.data.kerFwd)?T.greenDim:T.bg2, borderRadius:T.rMd, border:`1px solid ${(step.data.linFwd||step.data.kerFwd)?T.green:T.border0}` }}>
                          <div style={{ fontFamily:T.display, fontWeight:700, fontSize:"1rem", color:(step.data.linFwd||step.data.kerFwd)?T.green:T.text3, marginBottom:4 }}>
                            {step.data.verdict}
                          </div>
                          <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text2 }}>
                            HSIC total dependence: {step.data.hsic.toFixed(6)}
                          </div>
                        </div>
                      )}
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        )}
      </Section>

      {/* â•â•â• BENCHMARK SUITE â•â•â• */}
      <Section title="Causal Method Benchmarks" color={T.yellow} style={{ marginTop:12 }}>
        <div style={{ fontFamily:T.body, fontSize:T.fs.sm, color:T.text2, marginBottom:12, lineHeight:1.6 }}>
          Run a battery of experiments across 4 signal types Ã— 4 noise levels Ã— 3 sample sizes.
          Compare <strong style={{color:T.blue}}>Linear Granger</strong>, <strong style={{color:T.orange}}>Kernel Granger</strong>, and <strong style={{color:T.teal}}>HSIC</strong> detection rates and timing.
        </div>
        <button onClick={runBenchmarks} disabled={benchRunning} style={{
          fontFamily:T.mono, fontSize:T.fs.sm, padding:"8px 20px", borderRadius:T.rMd, cursor:benchRunning?"wait":"pointer",
          background:T.yellowDim, border:`1px solid ${T.yellow}44`, color:T.yellow, fontWeight:600, marginBottom:12,
        }}>{benchRunning ? "Running 144 experiments..." : "â–¶ Run Benchmark Suite"}</button>

        {benchResults && (
          <div>
            {/* Summary by scenario */}
            <div style={{ display:"grid", gridTemplateColumns:"repeat(auto-fill, minmax(220px,1fr))", gap:8, marginBottom:16 }}>
              {["linear","nonlinear","none","bidirectional"].map(scId => {
                const rows = benchResults.filter(r => r.scenario === scId);
                const avgLin = rows.reduce((s,r) => s+r.linRate,0)/rows.length;
                const avgKer = rows.reduce((s,r) => s+r.kerRate,0)/rows.length;
                const avgHsic = rows.reduce((s,r) => s+r.hsicRate,0)/rows.length;
                const label = rows[0]?.label || scId;
                const shouldDetect = scId !== "none";
                return (
                  <div key={scId} style={{ background:T.bg2, border:`1px solid ${T.border0}`, borderRadius:T.rMd, padding:"12px 14px" }}>
                    <div style={{ fontFamily:T.display, fontWeight:700, fontSize:T.fs.md, color:T.text0, marginBottom:8 }}>{label}</div>
                    <div style={{ display:"flex", flexDirection:"column", gap:4 }}>
                      {[
                        {name:"Linear", rate:avgLin, color:T.blue},
                        {name:"Kernel", rate:avgKer, color:T.orange},
                        {name:"HSIC", rate:avgHsic, color:T.teal},
                      ].map(m => (
                        <div key={m.name} style={{ display:"flex", alignItems:"center", gap:6 }}>
                          <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:m.color, minWidth:50 }}>{m.name}</span>
                          <div style={{ flex:1, height:6, background:T.bg3, borderRadius:3, overflow:"hidden" }}>
                            <div style={{ width:`${m.rate*100}%`, height:"100%", background:m.color, borderRadius:3, transition:"width 0.3s" }} />
                          </div>
                          <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, minWidth:38, textAlign:"right",
                            color: shouldDetect ? (m.rate>0.7?T.green:m.rate>0.4?T.yellow:T.danger) : (m.rate<0.2?T.green:m.rate<0.5?T.yellow:T.danger)
                          }}>{(m.rate*100).toFixed(0)}%</span>
                        </div>
                      ))}
                    </div>
                    <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3, marginTop:6 }}>
                      {shouldDetect ? "Higher = better (should detect)" : "Lower = better (false positive rate)"}
                    </div>
                  </div>
                );
              })}
            </div>

            {/* Noise sensitivity grid */}
            <div style={labelS}>Detection vs Noise Level (n=300, all methods)</div>
            <div style={{ display:"grid", gridTemplateColumns:"repeat(auto-fill, minmax(280px,1fr))", gap:8, marginBottom:12 }}>
              {["linear","nonlinear","none","bidirectional"].map(scId => {
                const rows = benchResults.filter(r => r.scenario === scId && r.n === 300);
                return (
                  <div key={scId} style={{ background:T.bg2, border:`1px solid ${T.border0}`, borderRadius:T.rSm, padding:"8px 10px" }}>
                    <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text0, fontWeight:600, marginBottom:6 }}>{rows[0]?.label}</div>
                    <div style={{ display:"grid", gridTemplateColumns:"40px 1fr 1fr 1fr", gap:"2px 6px", alignItems:"center" }}>
                      <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3 }}>Ïƒ</span>
                      <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.blue, textAlign:"center" }}>Lin</span>
                      <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.orange, textAlign:"center" }}>Ker</span>
                      <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.teal, textAlign:"center" }}>HSIC</span>
                      {rows.map(r => (
                        <React.Fragment key={r.noise}>
                          <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3 }}>{r.noise}</span>
                          {[{rate:r.linRate,c:T.blue},{rate:r.kerRate,c:T.orange},{rate:r.hsicRate,c:T.teal}].map((m,i) => (
                            <div key={i} style={{ textAlign:"center" }}>
                              <span style={{
                                fontFamily:T.mono, fontSize:T.fs.xs, fontWeight:600, padding:"1px 4px", borderRadius:T.rSm,
                                background:`${m.rate>0.7?T.green:m.rate>0.3?T.yellow:T.text3}18`,
                                color:m.rate>0.7?T.green:m.rate>0.3?T.yellow:T.text3,
                              }}>{(m.rate*100).toFixed(0)}%</span>
                            </div>
                          ))}
                        </React.Fragment>
                      ))}
                    </div>
                  </div>
                );
              })}
            </div>

            {/* Timing summary */}
            <div style={labelS}>Average Timing (ms per run)</div>
            <div style={{ display:"flex", gap:12, flexWrap:"wrap" }}>
              {[
                {name:"Linear Granger", color:T.blue, key:"linMs"},
                {name:"Kernel Granger", color:T.orange, key:"kerMs"},
                {name:"HSIC", color:T.teal, key:"hsicMs"},
              ].map(m => {
                const avg = (benchResults.reduce((s,r) => s+parseFloat(r[m.key]),0)/benchResults.length).toFixed(1);
                return (
                  <div key={m.name} style={{ background:T.bg2, border:`1px solid ${T.border0}`, borderRadius:T.rSm, padding:"8px 14px", display:"flex", alignItems:"center", gap:8 }}>
                    <StatusDot color={m.color} size={6} />
                    <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text1 }}>{m.name}</span>
                    <span style={{ fontFamily:T.display, fontWeight:700, fontSize:T.fs.lg, color:m.color }}>{avg}</span>
                    <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3 }}>ms</span>
                  </div>
                );
              })}
            </div>
          </div>
        )}
      </Section>

      {/* â•â•â• Technique â†” Hilbert Mapping â•â•â• */}
      <Section title="Technique â†’ Hilbert Mapping" count={Object.keys(HILBERT_MAPPING).length} color={T.teal} style={{ marginTop:12 }}>
        <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text3, marginBottom:8 }}>
          Every forecasting technique secretly operates via a Hilbert space mechanism
        </div>
        <div style={{ display:"grid", gridTemplateColumns:"repeat(auto-fill, minmax(350px, 1fr))", gap:4 }}>
          {TECHNIQUES.map(t => {
            const hm = HILBERT_MAPPING[t.id];
            if (!hm) return null;
            const hc = HILBERT_CONCEPTS.find(c => c.id === hm.concept);
            if (!hc) return null;
            return (
              <div key={t.id} style={{ display:"flex", alignItems:"flex-start", gap:6, padding:"5px 8px",
                background:T.bg2, borderRadius:T.rSm, border:`1px solid ${T.border0}`, borderLeft:`3px solid ${hc.color}` }}>
                <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:familyColor(t.family), fontWeight:600, minWidth:90 }}>{t.name}</span>
                <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, padding:"0.1em 0.3em", borderRadius:T.rSm,
                  background:`${hc.color}15`, color:hc.color, flexShrink:0 }}>{hc.symbol.split(" ")[0]}</span>
                <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, color:T.text2, flex:1 }}>{hm.interpretation}</span>
              </div>
            );
          })}
        </div>
      </Section>
    </div>
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN APPLICATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function App() {
  const [tab, setTab] = useState("techniques");

  const tabs = [
    { key:"techniques", label:"Techniques", color:T.orange },
    { key:"composer", label:"Composer", color:T.green },
    { key:"matrix", label:"Matrix", color:T.blue },
    { key:"principles", label:"Principles", color:T.purple },
    { key:"logs", label:"Condensed Logs", color:T.teal },
    { key:"graph", label:"Graph", color:T.green },
    { key:"causal", label:"Causal", color:T.crimson },
    { key:"observatory", label:"Observatory", color:T.yellow },
  ];

  // Summary stats
  const familyCounts = {};
  TECHNIQUES.forEach(t => { familyCounts[t.family] = (familyCounts[t.family]||0)+1; });

  return (
    <div style={{ minHeight:"100vh", background:T.bg0, color:T.text1, fontFamily:T.body, fontSize:13, lineHeight:1.5 }}>
      <style>{`
        * { box-sizing:border-box; margin:0; padding:0; }
        ::-webkit-scrollbar { width:4px; height:4px; }
        ::-webkit-scrollbar-track { background:transparent; }
        ::-webkit-scrollbar-thumb { background:${T.border1}; border-radius:${T.rSm}px; }
        ::-webkit-scrollbar-thumb:hover { background:${T.border2}; }
        @keyframes statusPulse {
          0%, 100% { opacity:0; transform:scale(0.85); }
          50% { opacity:0.4; transform:scale(1.3); }
        }
        :focus-visible { outline:2px solid ${T.accent}; outline-offset:2px; border-radius:${T.rSm}px; }
        button { transition:background 150ms ease, color 150ms ease, border-color 150ms ease; }
        button:hover { filter:brightness(1.15); }
        input[type="range"] { -webkit-appearance:none; background:${T.bg3}; height:4px; border-radius:2px; outline:none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance:none; width:14px; height:14px; border-radius:50%; background:${T.accent}; cursor:pointer; border:2px solid ${T.bg1}; }
      `}</style>

      <div style={{ padding:"24px 32px 48px", maxWidth:1200, margin:"0 auto" }}>

        {/* HEADER */}
        <header style={{ marginBottom:24 }}>
          <div style={{ fontFamily:T.display, fontWeight:700, fontSize:"1.8rem", color:T.text0, lineHeight:1.1, marginBottom:4 }}>
            Foresight Compendium
          </div>
          <div style={{ fontFamily:T.mono, fontSize:T.fs.xs, textTransform:"uppercase", letterSpacing:"0.16em", color:T.text3, marginBottom:16 }}>
            Chromatic Lattice â€” Time Series Forecasting Observatory
          </div>
          <div style={{ display:"flex", gap:"0.4em", alignItems:"center", flexWrap:"wrap" }}>
            <Chip level="verified">{TECHNIQUES.length} techniques</Chip>
            <Chip level="invariant">{FAMILIES.length} families</Chip>
            <Chip level="asserted">{PRINCIPLES.length} principles</Chip>
            <Chip level="used">{OPERATORS.length} operators</Chip>
            <Chip level="inferred">{ARCHETYPES.length} archetypes</Chip>
            <Chip style={{ background:T.greenDim, color:T.green, border:`1px solid ${T.green}33` }}>{KNOWN_SYNERGIES.length} synergies</Chip>
            <Chip style={{ background:T.crimsonDim, color:T.crimson, border:`1px solid ${T.crimson}33` }}>{KNOWN_CONFLICTS.length} conflicts</Chip>
            <Chip style={{ background:T.blueDim, color:T.blue, border:`1px solid ${T.blue}33` }}>{CANONICAL_PIPELINES.length} pipelines</Chip>
          </div>
        </header>

        {/* METRIC CARDS */}
        <div style={{ display:"grid", gridTemplateColumns:"repeat(auto-fill, minmax(150px, 1fr))", gap:10, marginBottom:24 }}>
          <MetricCard label="Techniques" value={TECHNIQUES.length} delta={`${FAMILIES.length} families`} deltaDir="up" color={T.orange} />
          <MetricCard label="Synergies" value={KNOWN_SYNERGIES.length} delta="documented pairings" deltaDir="up" color={T.green} />
          <MetricCard label="Conflicts" value={KNOWN_CONFLICTS.length} delta="anti-patterns" deltaDir="down" color={T.crimson} />
          <MetricCard label="Pipelines" value={CANONICAL_PIPELINES.length} delta="canonical chains" deltaDir="up" color={T.blue} />
          <MetricCard label="Principles" value={PRINCIPLES.length} delta="composability rules" deltaDir="flat" color={T.purple} />
          <MetricCard label="Operators" value={OPERATORS.length} delta={`${OP_CATEGORIES.length} categories`} deltaDir="up" color={T.teal} />
        </div>

        {/* TAB BAR */}
        <TabBar tabs={tabs} active={tab} onChange={setTab} />

        {/* TAB CONTENT */}
        {tab === "techniques" && <TechniquesTab />}
        {tab === "composer" && <ComposerTab />}
        {tab === "matrix" && <MatrixTab />}
        {tab === "principles" && <PrinciplesTab />}
        {tab === "logs" && <CondensedLogsTab />}
        {tab === "graph" && <GraphTab />}
        {tab === "causal" && <CausalTab />}
        {tab === "observatory" && <ObservatoryTab />}

        {/* FOOTER */}
        <div style={{ marginTop:32, paddingTop:12, borderTop:`1px solid ${T.border0}`,
          display:"flex", gap:6, flexWrap:"wrap", alignItems:"center" }}>
          <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, textTransform:"uppercase", letterSpacing:"0.16em", color:T.text3, marginRight:6 }}>
            Epistemic Levels
          </span>
          {Object.keys(LEVEL_COLOR).map(k => <Chip key={k} level={k}>{k}</Chip>)}
        </div>

        {/* Family legend */}
        <div style={{ marginTop:8, display:"flex", gap:6, flexWrap:"wrap", alignItems:"center" }}>
          <span style={{ fontFamily:T.mono, fontSize:T.fs.xs, textTransform:"uppercase", letterSpacing:"0.16em", color:T.text3, marginRight:6 }}>
            Technique Families
          </span>
          {FAMILIES.map(f => (
            <span key={f.id} style={{ display:"inline-flex", alignItems:"center", gap:4, fontFamily:T.mono, fontSize:T.fs.xs, color:f.color }}>
              <span style={{ width:6, height:6, borderRadius:"50%", background:f.color }} />
              {f.name} ({familyCounts[f.id]||0})
            </span>
          ))}
        </div>
      </div>
    </div>
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RENDER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
</script>
</body>
</html>
