<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Foresight â€” Time Series Forecasting Compendium</title>
<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body style="margin:0;background:#08080c">
<div id="root"></div>
<script type="text/babel">
const { useState, useEffect, useCallback, useMemo, useRef } = React;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DESIGN TOKENS â€” Chromatic Lattice
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const T = {
  bg0:"#08080c", bg1:"#0e0e14", bg2:"#141420", bg3:"#1a1a28", bg4:"#222232",
  border0:"#1e1e2e", border1:"#2a2a3c", border2:"#36364a",
  text0:"#eae9f0", text1:"#c4c3ce", text2:"#8a899a", text3:"#5a596a",
  blue:"#4a8fe7", blueDim:"rgba(74,143,231,0.15)", blueMid:"rgba(74,143,231,0.35)",
  red:"#e84a5a", redDim:"rgba(232,74,90,0.15)", redMid:"rgba(232,74,90,0.35)",
  purple:"#9b6dff", purpleDim:"rgba(155,109,255,0.15)", purpleMid:"rgba(155,109,255,0.35)",
  green:"#3dbe78", greenDim:"rgba(61,190,120,0.15)", greenMid:"rgba(61,190,120,0.35)",
  yellow:"#e0c040", yellowDim:"rgba(224,192,64,0.12)", yellowMid:"rgba(224,192,64,0.30)",
  orange:"#e8762b", orangeDim:"rgba(232,118,43,0.15)", orangeMid:"rgba(232,118,43,0.35)",
  teal:"#2bbfa0", tealDim:"rgba(43,191,160,0.15)", tealMid:"rgba(43,191,160,0.35)",
  silver:"#b0b3c0", silverDim:"rgba(176,179,192,0.10)", silverMid:"rgba(176,179,192,0.28)",
  crimson:"#dc2640", crimsonDim:"rgba(220,38,64,0.15)", crimsonMid:"rgba(220,38,64,0.35)",
  rSm:3, rMd:5, rLg:8, rPill:100,
  mono:"ui-monospace, 'SF Mono', monospace",
  display:"Georgia, serif",
  body:"system-ui, sans-serif",
};

const LEVEL_COLOR = {
  verified:{ base:T.green, dim:T.greenDim, mid:T.greenMid, label:"VER" },
  asserted:{ base:T.orange, dim:T.orangeDim, mid:T.orangeMid, label:"ASR" },
  assumed:{ base:T.yellow, dim:T.yellowDim, mid:T.yellowMid, label:"ASM" },
  inferred:{ base:T.blue, dim:T.blueDim, mid:T.blueMid, label:"INF" },
  extrapolated:{ base:T.crimson, dim:T.crimsonDim, mid:T.crimsonMid, label:"EXT" },
  aspirational:{ base:T.silver, dim:T.silverDim, mid:T.silverMid, label:"ASP" },
  invariant:{ base:T.purple, dim:T.purpleDim, mid:T.purpleMid, label:"INV" },
  used:{ base:T.teal, dim:T.tealDim, mid:T.tealMid, label:"USE" },
};
const lc = l => LEVEL_COLOR[l] || LEVEL_COLOR.used;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DATA â€” FAMILIES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const FAMILIES = [
  { id:"baseline", name:"Baseline", color:T.silver, description:"Simple reference methods that establish performance floors" },
  { id:"statistical", name:"Statistical", color:T.blue, description:"Classical parametric models grounded in probability theory" },
  { id:"statespace", name:"State-Space", color:T.purple, description:"Hidden state models with observation equations" },
  { id:"ml", name:"Machine Learning", color:T.orange, description:"Non-parametric supervised learners on engineered features" },
  { id:"deep", name:"Deep Learning", color:T.crimson, description:"Neural sequence models learning representations end-to-end" },
  { id:"probabilistic", name:"Probabilistic", color:T.teal, description:"Uncertainty-native methods producing full distributions" },
  { id:"decomposition", name:"Decomposition", color:T.green, description:"Signal separation into trend, seasonal, and residual" },
  { id:"pointprocess", name:"Point Process", color:T.yellow, description:"Event arrival and intensity models" },
  { id:"ensemble", name:"Ensemble/Meta", color:T.red, description:"Model combination and meta-learning strategies" },
];

const familyColor = fid => (FAMILIES.find(f => f.id === fid) || {}).color || T.text2;
const familyName = fid => (FAMILIES.find(f => f.id === fid) || {}).name || fid;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DATA â€” TECHNIQUES (35)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const TECHNIQUES = [
  // Baseline (4)
  { id:"naive", name:"Naive", family:"baseline", desc:"Last observed value repeated as forecast",
    complexity:1, inputTypes:["univariate"], outputTypes:["point_forecast"],
    assumptions:[], ownedResponsibilities:["level"], timeScales:["daily","weekly","monthly"],
    leakageRisk:"low", bestFor:["Benchmarking","Sanity checks"], pipelineRole:"model" },
  { id:"seasonal_naive", name:"Seasonal Naive", family:"baseline", desc:"Value from same season last cycle as forecast",
    complexity:1, inputTypes:["univariate"], outputTypes:["point_forecast"],
    assumptions:["seasonality_present"], ownedResponsibilities:["seasonality"], timeScales:["daily","weekly","monthly","quarterly"],
    leakageRisk:"low", bestFor:["Seasonal benchmarks","Retail"], pipelineRole:"model" },
  { id:"ewma", name:"EWMA", family:"baseline", desc:"Exponentially weighted moving average â€” recent data weighted more",
    complexity:1, inputTypes:["univariate"], outputTypes:["point_forecast","features"],
    assumptions:[], ownedResponsibilities:["level","smoothing"], timeScales:["intraday","daily","weekly"],
    leakageRisk:"low", bestFor:["Smoothing","Online tracking"], pipelineRole:"model" },
  { id:"moving_avg", name:"Moving Average", family:"baseline", desc:"Simple rolling window mean",
    complexity:1, inputTypes:["univariate"], outputTypes:["point_forecast","features"],
    assumptions:[], ownedResponsibilities:["smoothing"], timeScales:["intraday","daily","weekly","monthly"],
    leakageRisk:"low", bestFor:["Noise reduction","Trend estimation"], pipelineRole:"transform" },

  // Statistical (6)
  { id:"arima", name:"ARIMA", family:"statistical", desc:"Autoregressive integrated moving average for non-seasonal series",
    complexity:3, inputTypes:["univariate"], outputTypes:["point_forecast","intervals"],
    assumptions:["stationarity_after_diff","linearity","normal_residuals"], ownedResponsibilities:["trend","autocorrelation"],
    timeScales:["daily","weekly","monthly"], leakageRisk:"medium", bestFor:["Trended series","Macro indicators"], pipelineRole:"model" },
  { id:"sarima", name:"SARIMA", family:"statistical", desc:"Seasonal ARIMA adding periodic autoregressive and MA terms",
    complexity:3, inputTypes:["univariate"], outputTypes:["point_forecast","intervals"],
    assumptions:["stationarity_after_diff","linearity","seasonal_stationarity"], ownedResponsibilities:["trend","seasonality","autocorrelation"],
    timeScales:["daily","weekly","monthly","quarterly"], leakageRisk:"medium", bestFor:["Seasonal macro","Energy demand"], pipelineRole:"model" },
  { id:"ets", name:"ETS / Holt-Winters", family:"statistical", desc:"Error-Trend-Seasonality exponential smoothing framework",
    complexity:2, inputTypes:["univariate"], outputTypes:["point_forecast","intervals"],
    assumptions:["smooth_trend","regular_seasonality"], ownedResponsibilities:["trend","seasonality","error"],
    timeScales:["daily","weekly","monthly","quarterly"], leakageRisk:"low", bestFor:["Retail sales","Inventory planning"], pipelineRole:"model" },
  { id:"var", name:"VAR", family:"statistical", desc:"Vector autoregression for multivariate time series",
    complexity:3, inputTypes:["multivariate"], outputTypes:["point_forecast","intervals"],
    assumptions:["stationarity","linearity","no_cointegration"], ownedResponsibilities:["cross_correlation","dynamics"],
    timeScales:["daily","weekly","monthly"], leakageRisk:"medium", bestFor:["Macro systems","Cross-asset"], pipelineRole:"model" },
  { id:"garch", name:"GARCH", family:"statistical", desc:"Generalized autoregressive conditional heteroskedasticity for volatility",
    complexity:3, inputTypes:["univariate","residuals"], outputTypes:["intervals","features"],
    assumptions:["stationarity","fat_tails"], ownedResponsibilities:["volatility"],
    timeScales:["intraday","daily","weekly"], leakageRisk:"low", bestFor:["Volatility forecasting","Risk management"], pipelineRole:"model" },
  { id:"theta", name:"Theta Method", family:"statistical", desc:"Decompose into theta-lines and extrapolate",
    complexity:2, inputTypes:["univariate"], outputTypes:["point_forecast"],
    assumptions:["smooth_trend"], ownedResponsibilities:["trend"],
    timeScales:["monthly","quarterly"], leakageRisk:"low", bestFor:["M-competition","Simple trend"], pipelineRole:"model" },

  // State-Space (3)
  { id:"kalman", name:"Kalman Filter", family:"statespace", desc:"Optimal recursive state estimator under Gaussian linear assumptions",
    complexity:4, inputTypes:["univariate","multivariate"], outputTypes:["point_forecast","intervals","features"],
    assumptions:["linearity","gaussian_noise"], ownedResponsibilities:["state_estimation","filtering"],
    timeScales:["tick","intraday","daily"], leakageRisk:"low", bestFor:["Real-time tracking","Sensor fusion"], pipelineRole:"model" },
  { id:"structural_ts", name:"Structural Time Series", family:"statespace", desc:"State-space decomposition into trend, seasonal, cycle components",
    complexity:4, inputTypes:["univariate"], outputTypes:["point_forecast","intervals","decomposed"],
    assumptions:["gaussian_noise","linear_components"], ownedResponsibilities:["trend","seasonality","cycle"],
    timeScales:["daily","weekly","monthly","quarterly"], leakageRisk:"low", bestFor:["Component analysis","Causal inference"], pipelineRole:"model" },
  { id:"hmm", name:"HMM", family:"statespace", desc:"Hidden Markov model for discrete regime detection",
    complexity:4, inputTypes:["univariate","multivariate","features"], outputTypes:["regime_labels","probabilities"],
    assumptions:["markov_property","finite_states"], ownedResponsibilities:["regime"],
    timeScales:["intraday","daily","weekly"], leakageRisk:"medium", bestFor:["Regime detection","Market states"], pipelineRole:"feature" },

  // ML (4)
  { id:"gbt", name:"Gradient Boosted Trees", family:"ml", desc:"Ensemble of sequential decision trees optimizing a loss function",
    complexity:3, inputTypes:["features"], outputTypes:["point_forecast","probabilities"],
    assumptions:["feature_engineering_done"], ownedResponsibilities:[],
    timeScales:["intraday","daily","weekly","monthly"], leakageRisk:"high", bestFor:["Tabular features","Non-linear patterns"], pipelineRole:"model" },
  { id:"rf", name:"Random Forest", family:"ml", desc:"Bagged ensemble of decorrelated decision trees",
    complexity:2, inputTypes:["features"], outputTypes:["point_forecast","probabilities"],
    assumptions:["feature_engineering_done"], ownedResponsibilities:[],
    timeScales:["intraday","daily","weekly","monthly"], leakageRisk:"high", bestFor:["Feature importance","Robust prediction"], pipelineRole:"model" },
  { id:"svr", name:"SVR", family:"ml", desc:"Support vector regression with kernel-based non-linearity",
    complexity:3, inputTypes:["features"], outputTypes:["point_forecast"],
    assumptions:["feature_engineering_done","scaled_inputs"], ownedResponsibilities:[],
    timeScales:["daily","weekly","monthly"], leakageRisk:"medium", bestFor:["Small datasets","Non-linear regression"], pipelineRole:"model" },
  { id:"regime_logistic", name:"Regime-Gated Logistic", family:"ml", desc:"Logistic regression gated by upstream regime labels",
    complexity:2, inputTypes:["features","regime_labels"], outputTypes:["probabilities"],
    assumptions:["regime_labels_available"], ownedResponsibilities:["regime_conditioning"],
    timeScales:["intraday","daily","weekly"], leakageRisk:"medium", bestFor:["Regime-aware signals","Interpretable ML"], pipelineRole:"model" },

  // Deep Learning (6)
  { id:"lstm", name:"LSTM", family:"deep", desc:"Long short-term memory recurrent network for sequence modeling",
    complexity:4, inputTypes:["univariate","multivariate"], outputTypes:["point_forecast","features"],
    assumptions:["sufficient_data","gpu_available"], ownedResponsibilities:["sequence_memory"],
    timeScales:["intraday","daily","weekly"], leakageRisk:"high", bestFor:["Long sequences","Complex dynamics"], pipelineRole:"model" },
  { id:"gru", name:"GRU", family:"deep", desc:"Gated recurrent unit â€” lighter alternative to LSTM",
    complexity:3, inputTypes:["univariate","multivariate"], outputTypes:["point_forecast","features"],
    assumptions:["sufficient_data"], ownedResponsibilities:["sequence_memory"],
    timeScales:["intraday","daily","weekly"], leakageRisk:"high", bestFor:["Medium sequences","Faster training"], pipelineRole:"model" },
  { id:"transformer", name:"Transformer", family:"deep", desc:"Self-attention mechanism for parallel sequence processing",
    complexity:5, inputTypes:["univariate","multivariate"], outputTypes:["point_forecast","features"],
    assumptions:["large_data","gpu_available"], ownedResponsibilities:["attention","representation"],
    timeScales:["intraday","daily","weekly","monthly"], leakageRisk:"high", bestFor:["Multi-horizon","Large datasets"], pipelineRole:"model" },
  { id:"nbeats", name:"N-BEATS", family:"deep", desc:"Neural basis expansion for interpretable time series forecasting",
    complexity:4, inputTypes:["univariate"], outputTypes:["point_forecast","decomposed"],
    assumptions:["sufficient_data"], ownedResponsibilities:["trend","seasonality"],
    timeScales:["daily","weekly","monthly"], leakageRisk:"high", bestFor:["Interpretable DL","Point forecasts"], pipelineRole:"model" },
  { id:"tft", name:"TFT", family:"deep", desc:"Temporal Fusion Transformer with variable selection and multi-horizon output",
    complexity:5, inputTypes:["multivariate"], outputTypes:["point_forecast","intervals"],
    assumptions:["large_data","gpu_available","static_covariates"], ownedResponsibilities:["attention","feature_selection"],
    timeScales:["daily","weekly","monthly"], leakageRisk:"high", bestFor:["Multi-horizon","Mixed covariates"], pipelineRole:"model" },
  { id:"deepar", name:"DeepAR", family:"deep", desc:"Autoregressive RNN producing full predictive distributions",
    complexity:4, inputTypes:["univariate","multivariate"], outputTypes:["distribution"],
    assumptions:["sufficient_data","parametric_likelihood"], ownedResponsibilities:["uncertainty"],
    timeScales:["daily","weekly","monthly"], leakageRisk:"high", bestFor:["Probabilistic forecasts","Inventory"], pipelineRole:"model" },

  // Probabilistic (4)
  { id:"bsts", name:"Bayesian Structural TS", family:"probabilistic", desc:"Bayesian inference over structural time series components",
    complexity:4, inputTypes:["univariate"], outputTypes:["distribution","intervals","decomposed"],
    assumptions:["prior_specification","gaussian_likelihood"], ownedResponsibilities:["trend","seasonality","uncertainty"],
    timeScales:["daily","weekly","monthly","quarterly"], leakageRisk:"low", bestFor:["Causal impact","Uncertainty quantification"], pipelineRole:"model" },
  { id:"gp", name:"Gaussian Process", family:"probabilistic", desc:"Non-parametric Bayesian regression with kernel-defined prior",
    complexity:5, inputTypes:["features"], outputTypes:["distribution","intervals"],
    assumptions:["kernel_choice","small_to_medium_data"], ownedResponsibilities:["uncertainty"],
    timeScales:["daily","weekly","monthly"], leakageRisk:"low", bestFor:["Small data","Uncertainty bounds"], pipelineRole:"model" },
  { id:"quantile_reg", name:"Quantile Regression", family:"probabilistic", desc:"Estimate conditional quantiles for prediction intervals",
    complexity:2, inputTypes:["features"], outputTypes:["intervals"],
    assumptions:["feature_engineering_done"], ownedResponsibilities:["quantile_estimation"],
    timeScales:["daily","weekly","monthly"], leakageRisk:"medium", bestFor:["Interval forecasts","Risk quantiles"], pipelineRole:"calibration" },
  { id:"conformal", name:"Conformal Prediction", family:"probabilistic", desc:"Distribution-free prediction intervals with coverage guarantees",
    complexity:2, inputTypes:["point_forecast","features"], outputTypes:["intervals"],
    assumptions:["exchangeability"], ownedResponsibilities:["coverage"],
    timeScales:["daily","weekly","monthly"], leakageRisk:"low", bestFor:["Coverage guarantees","Model-agnostic intervals"], pipelineRole:"calibration" },

  // Decomposition (3)
  { id:"stl", name:"STL", family:"decomposition", desc:"Seasonal-Trend decomposition using LOESS",
    complexity:2, inputTypes:["univariate"], outputTypes:["decomposed","residuals"],
    assumptions:["additive_or_multiplicative"], ownedResponsibilities:["trend","seasonality"],
    timeScales:["daily","weekly","monthly"], leakageRisk:"low", bestFor:["Preprocessing","Anomaly detection"], pipelineRole:"transform" },
  { id:"x13", name:"X-13 ARIMA-SEATS", family:"decomposition", desc:"Census Bureau seasonal adjustment with calendar effects",
    complexity:3, inputTypes:["univariate"], outputTypes:["decomposed","features"],
    assumptions:["monthly_or_quarterly","calendar_effects"], ownedResponsibilities:["seasonality","calendar"],
    timeScales:["monthly","quarterly"], leakageRisk:"low", bestFor:["Official statistics","Seasonal adjustment"], pipelineRole:"transform" },
  { id:"prophet", name:"Prophet", family:"decomposition", desc:"Additive regression with trend, seasonality, and holiday components",
    complexity:2, inputTypes:["univariate"], outputTypes:["point_forecast","intervals","decomposed"],
    assumptions:["additive_components","known_holidays"], ownedResponsibilities:["trend","seasonality","holidays"],
    timeScales:["daily","weekly","monthly"], leakageRisk:"low", bestFor:["Business forecasting","Quick prototyping"], pipelineRole:"model" },

  // Point Process (2)
  { id:"hawkes", name:"Hawkes Process", family:"pointprocess", desc:"Self-exciting point process where events increase future event probability",
    complexity:4, inputTypes:["events"], outputTypes:["point_forecast","features"],
    assumptions:["self_excitation","stationarity"], ownedResponsibilities:["self_excitation","intensity"],
    timeScales:["tick","intraday","daily"], leakageRisk:"low", bestFor:["Order flow","News cascades"], pipelineRole:"model" },
  { id:"cox", name:"Cox Process", family:"pointprocess", desc:"Doubly stochastic Poisson process with random intensity",
    complexity:5, inputTypes:["events","features"], outputTypes:["point_forecast","distribution"],
    assumptions:["conditional_poisson","intensity_model"], ownedResponsibilities:["intensity"],
    timeScales:["intraday","daily","weekly"], leakageRisk:"medium", bestFor:["Event modeling","Spatial-temporal"], pipelineRole:"model" },

  // Ensemble/Meta (3)
  { id:"late_fusion", name:"Late Fusion", family:"ensemble", desc:"Combine final predictions from multiple models via weighted average",
    complexity:1, inputTypes:["point_forecast"], outputTypes:["point_forecast"],
    assumptions:["diverse_models"], ownedResponsibilities:["combination"],
    timeScales:["intraday","daily","weekly","monthly"], leakageRisk:"medium", bestFor:["Model combination","Variance reduction"], pipelineRole:"decision" },
  { id:"stacking", name:"Stacking", family:"ensemble", desc:"Train meta-learner on base model predictions",
    complexity:3, inputTypes:["point_forecast","features"], outputTypes:["point_forecast"],
    assumptions:["diverse_models","sufficient_data"], ownedResponsibilities:["meta_learning"],
    timeScales:["daily","weekly","monthly"], leakageRisk:"high", bestFor:["Complex ensembles","Competition winning"], pipelineRole:"decision" },
  { id:"model_avg", name:"Model Averaging", family:"ensemble", desc:"Bayesian or frequentist averaging across model space",
    complexity:2, inputTypes:["point_forecast"], outputTypes:["point_forecast","intervals"],
    assumptions:["model_set_defined"], ownedResponsibilities:["combination","model_uncertainty"],
    timeScales:["daily","weekly","monthly"], leakageRisk:"low", bestFor:["Robust forecasts","Uncertainty from model selection"], pipelineRole:"decision" },
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DATA â€” 12 COMPOSABILITY PRINCIPLES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const PRINCIPLES = [
  { id:1, name:"Output-Input Typing", category:"structural",
    description:"Chain techniques only when A's output type is in B's accepted input types. Type mismatches silently corrupt pipelines.",
    rule:"outputTypes(A) âˆ© inputTypes(B) â‰  âˆ…",
    safeExamples:["STL (â†’decomposed) â†’ ARIMA (univariateâœ“)","HMM (â†’regime_labels) â†’ Regime-Gated Logistic (regime_labelsâœ“)"],
    unsafeExamples:["GARCH (â†’intervals) â†’ Random Forest (needs features)","Hawkes (â†’point_forecast) â†’ STL (needs univariate raw)"] },
  { id:2, name:"Single Responsibility", category:"structural",
    description:"Each technique should own exactly one transformation responsibility. Two techniques owning the same responsibility create ambiguous attribution.",
    rule:"ownedResp(A) âˆ© ownedResp(B) = âˆ…",
    safeExamples:["STL (owns trend+seasonal) â†’ GARCH (owns volatility)","HMM (owns regime) â†’ GBT (owns nothing specific)"],
    unsafeExamples:["SARIMA (owns trend+seasonal) â†’ ETS (owns trend+seasonal)","Prophet (owns trend) â†’ N-BEATS (owns trend)"] },
  { id:3, name:"Temporal Ordering", category:"causal",
    description:"Never pass future information to a model expecting only past data. Calibration and decision steps must follow model outputs, not precede them.",
    rule:"pipelineRole ordering: transform â†’ feature â†’ model â†’ calibration â†’ decision",
    safeExamples:["STL (transform) â†’ GBT (model) â†’ Conformal (calibration)","Moving Average (transform) â†’ LSTM (model) â†’ Late Fusion (decision)"],
    unsafeExamples:["Conformal (calibration) â†’ ARIMA (model)","Stacking (decision) â†’ GBT (model)"] },
  { id:4, name:"Scale Alignment", category:"structural",
    description:"Techniques in a pipeline must operate at compatible time scales. Mixing intraday features with monthly models produces nonsensical results.",
    rule:"timeScales(A) âˆ© timeScales(B) â‰  âˆ…",
    safeExamples:["EWMA (intraday/daily) â†’ GBT (intraday/daily)","SARIMA (monthly) â†’ Conformal (monthly)"],
    unsafeExamples:["Hawkes (tick) â†’ Theta (monthly)","Kalman (tick) â†’ X-13 (monthly/quarterly)"] },
  { id:5, name:"Stationarity Handoff", category:"statistical",
    description:"Non-stationary data must be made stationary before models that assume stationarity. Decomposition or differencing should precede such models.",
    rule:"If B assumes stationarity, A must output stationary data",
    safeExamples:["STL residuals â†’ ARIMA (stationary residuals)","Differencing â†’ VAR (stationary multivariate)"],
    unsafeExamples:["Raw trending series â†’ VAR (assumes stationarity)","Non-stationary prices â†’ GARCH (assumes stationarity)"] },
  { id:6, name:"Uncertainty Propagation", category:"statistical",
    description:"Probabilistic outputs should not be collapsed to point estimates mid-pipeline. Doing so discards calibrated uncertainty.",
    rule:"If A outputs distribution/intervals, B should accept them or the collapse should be explicit",
    safeExamples:["DeepAR (â†’distribution) â†’ Conformal (calibration)","BSTS (â†’intervals) â†’ Model Averaging (â†’intervals)"],
    unsafeExamples:["GP (â†’distribution) â†’ mean() â†’ GBT (loses uncertainty)","Quantile Regression (â†’intervals) â†’ point collapse â†’ Late Fusion"] },
  { id:7, name:"Regime Awareness", category:"causal",
    description:"Regime-dependent models must receive regime labels from an upstream detector. Self-detected regimes risk look-ahead bias.",
    rule:"If B requires regime_labels, A must produce them",
    safeExamples:["HMM (â†’regime_labels) â†’ Regime-Gated Logistic","Structural TS (â†’decomposed) â†’ regime classification â†’ GBT"],
    unsafeExamples:["Regime-Gated Logistic without upstream HMM","Manual regime assignment using future knowledge"] },
  { id:8, name:"Evaluation Isolation", category:"evaluation",
    description:"Test-set evaluation must happen outside the pipeline's training window. Any technique that touches the test set during training invalidates the evaluation.",
    rule:"No technique in the pipeline may access test-period data during fitting",
    safeExamples:["Walk-forward validation with expanding window","Nested cross-validation for hyperparameter selection"],
    unsafeExamples:["Scaling features using full dataset statistics","Selecting ARIMA order using AIC on combined train+test"] },
  { id:9, name:"Feature Leakage Prevention", category:"evaluation",
    description:"Engineered features must not encode target information from the evaluation period. Lag features, rolling stats, and lookbacks must respect temporal boundaries.",
    rule:"All features at time t derived only from data at times â‰¤ t",
    safeExamples:["Rolling mean with strict lookback window","Lag features with gap between feature and target"],
    unsafeExamples:["Future returns leaked via incorrect join","Rolling statistics computed on full series including future"] },
  { id:10, name:"Ablation Identifiability", category:"evaluation",
    description:"Every component in a pipeline must be independently removable for ablation testing. If removing one component breaks the pipeline structurally, the design is too coupled.",
    rule:"âˆ€ technique T in pipeline: pipeline \\ {T} still executes (possibly with degraded accuracy)",
    safeExamples:["Removing HMM â†’ Logistic falls back to unconditional","Removing STL â†’ ARIMA receives raw series (valid, less clean)"],
    unsafeExamples:["Removing feature extractor breaks model input dimensions","Tight coupling where calibration requires specific model internals"] },
  { id:11, name:"Complexity Gradient", category:"design",
    description:"Simpler models should precede complex ones in evaluation order. Always establish a baseline before adding complexity â€” the marginal value of complexity must be demonstrated.",
    rule:"Evaluate: baseline â†’ statistical â†’ ML â†’ DL, justify each step",
    safeExamples:["Naive â†’ ARIMA â†’ GBT â†’ LSTM ladder","EWMA baseline before Transformer deployment"],
    unsafeExamples:["Deploying Transformer without comparing to ARIMA","Stacking ensemble without individual model evaluation"] },
  { id:12, name:"Ensemble Independence", category:"design",
    description:"Ensemble members should have diverse error profiles. Combining models with correlated errors provides minimal variance reduction.",
    rule:"Corr(errors(A), errors(B)) should be low across ensemble members",
    safeExamples:["ARIMA + GBT + LSTM (different model families)","Statistical + ML + DL diverse ensemble"],
    unsafeExamples:["GBT + RF + XGBoost (all tree-based, correlated errors)","Three ARIMA variants with different orders"] },
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DATA â€” 22 OPERATORS (6 categories)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const OPERATORS = [
  // Level (4)
  { id:"L_mean", name:"Running Mean", category:"level", description:"Exponentially weighted running mean of the signal", formula:"Î¼_t = Î±Â·x_t + (1-Î±)Â·Î¼_{t-1}" },
  { id:"L_median", name:"Running Median", category:"level", description:"Rolling median over a fixed window for robust level estimation", formula:"med_t = median(x_{t-w}...x_t)" },
  { id:"L_quantile", name:"Quantile Tracker", category:"level", description:"Tracks arbitrary quantile of the streaming distribution", formula:"q_t^Ï„ = q_{t-1}^Ï„ + Î±Â·(ðŸ™[x_t â‰¤ q] - Ï„)" },
  { id:"L_zscore", name:"Z-Score", category:"level", description:"Standardized deviation from running mean in units of running std", formula:"z_t = (x_t - Î¼_t) / Ïƒ_t" },

  // Dynamic (4)
  { id:"D_velocity", name:"Velocity", category:"dynamic", description:"First discrete derivative â€” rate of change per unit time", formula:"v_t = x_t - x_{t-1}" },
  { id:"D_acceleration", name:"Acceleration", category:"dynamic", description:"Second derivative â€” rate of change of velocity", formula:"a_t = v_t - v_{t-1}" },
  { id:"D_momentum", name:"Momentum", category:"dynamic", description:"Exponentially weighted directional persistence", formula:"m_t = Î²Â·m_{t-1} + (1-Î²)Â·v_t" },
  { id:"D_volatility", name:"Volatility", category:"dynamic", description:"Rolling standard deviation capturing dispersion", formula:"Ïƒ_t = sqrt(EMA(v_tÂ², Î±))" },

  // Structure (4)
  { id:"S_autocorr", name:"Autocorrelation", category:"structure", description:"Lagged self-correlation measuring memory structure", formula:"Ï_k = Corr(x_t, x_{t-k})" },
  { id:"S_entropy", name:"Sample Entropy", category:"structure", description:"Regularity/complexity measure â€” low entropy = predictable", formula:"SampEn(m,r) = -ln(A/B)" },
  { id:"S_fractal", name:"Fractal Dimension", category:"structure", description:"Self-similarity measure across scales via box-counting", formula:"D = lim(log N(Îµ) / log(1/Îµ))" },
  { id:"S_cluster", name:"Cluster Membership", category:"structure", description:"Assigns current state to nearest behavioral cluster centroid", formula:"c_t = argmin_k ||s_t - Î¼_k||" },

  // Event (4)
  { id:"E_spike", name:"Spike Detector", category:"event", description:"Flags observations exceeding threshold in z-score space", formula:"spike_t = ðŸ™[|z_t| > Ï„]" },
  { id:"E_regime", name:"Regime Change", category:"event", description:"Detects structural breaks via change-point statistics", formula:"CP_t = max_s CUSUM(x_{s..t})" },
  { id:"E_anomaly", name:"Anomaly Flag", category:"event", description:"Multi-criteria anomaly detection combining level, volatility, and structure", formula:"anom_t = ðŸ™[score_t > Î¸]" },
  { id:"E_catalyst", name:"Catalyst Indicator", category:"event", description:"Binary indicator when a catalytic process fires", formula:"cat_t = ðŸ™[trigger(t)]" },

  // Stability (3)
  { id:"ST_lyapunov", name:"Lyapunov Exponent", category:"stability", description:"Measures rate of divergence of nearby trajectories â€” positive = chaos", formula:"Î» = lim (1/t) Î£ ln|f'(x_i)|" },
  { id:"ST_hurst", name:"Hurst Exponent", category:"stability", description:"Long-range dependence: H>0.5 trending, H<0.5 mean-reverting, H=0.5 random walk", formula:"E[R(n)/S(n)] = CÂ·n^H" },
  { id:"ST_stationarity", name:"Stationarity Test", category:"stability", description:"Augmented Dickey-Fuller test statistic for unit root detection", formula:"ADF = Î”x_t = Î± + Î²t + Î³x_{t-1} + Î£Î´_iÎ”x_{t-i}" },

  // Cross-Stream (3)
  { id:"X_correlation", name:"Cross-Correlation", category:"crossstream", description:"Pairwise Pearson correlation between streams over rolling window", formula:"Ï_{AB} = Cov(A,B) / (Ïƒ_AÂ·Ïƒ_B)" },
  { id:"X_granger", name:"Granger Causality", category:"crossstream", description:"Tests if stream A's history improves prediction of stream B", formula:"F-test: restricted vs unrestricted VAR" },
  { id:"X_coherence", name:"Spectral Coherence", category:"crossstream", description:"Frequency-domain correlation between two streams", formula:"C_{AB}(f) = |S_{AB}(f)|Â² / (S_A(f)Â·S_B(f))" },
];

const OP_CATEGORIES = [
  { id:"level", name:"Level", color:T.blue, desc:"Signal level estimation operators" },
  { id:"dynamic", name:"Dynamic", color:T.orange, desc:"Rate of change and momentum operators" },
  { id:"structure", name:"Structure", color:T.purple, desc:"Memory, complexity, and topology operators" },
  { id:"event", name:"Event", color:T.crimson, desc:"Discrete event detection operators" },
  { id:"stability", name:"Stability", color:T.green, desc:"Convergence and long-range behavior operators" },
  { id:"crossstream", name:"Cross-Stream", color:T.teal, desc:"Inter-stream relationship operators" },
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DATA â€” ARCHETYPES (6)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const ARCHETYPES = [
  { id:"trending", name:"Trending", description:"Persistent directional movement with occasional reversals",
    streams:["GDP growth","Secular stock trends","Population"],
    recommendedChain:["stl","arima","conformal"], antiPatterns:["Applying mean-reversion models","Ignoring structural breaks"] },
  { id:"mean_reverting", name:"Mean-Reverting", description:"Oscillates around a stable level with bounded excursions",
    streams:["Interest rate spreads","Pairs trading residuals","Temperature anomalies"],
    recommendedChain:["ewma","var","quantile_reg"], antiPatterns:["Using trend-following models","Ignoring half-life estimation"] },
  { id:"seasonal", name:"Seasonal", description:"Regular periodic patterns driven by calendar or physical cycles",
    streams:["Retail sales","Energy demand","Agricultural yields"],
    recommendedChain:["stl","sarima","conformal"], antiPatterns:["Ignoring holiday effects","Using non-seasonal models"] },
  { id:"regime_switching", name:"Regime-Switching", description:"Alternates between distinct statistical states",
    streams:["Bull/bear markets","Volatility regimes","Economic expansion/recession"],
    recommendedChain:["hmm","regime_logistic","late_fusion"], antiPatterns:["Assuming single regime","Ignoring transition dynamics"] },
  { id:"event_driven", name:"Event-Driven", description:"Dominated by discrete events with rapid response and decay",
    streams:["Earnings announcements","Policy decisions","Natural disasters"],
    recommendedChain:["hawkes","gbt","model_avg"], antiPatterns:["Smoothing away event spikes","Ignoring event clustering"] },
  { id:"high_freq_noise", name:"High-Frequency Noise", description:"Nearly white noise at observation scale â€” weak signal-to-noise",
    streams:["Tick-level returns","High-frequency sensor noise","Social media sentiment"],
    recommendedChain:["moving_avg","kalman","gp"], antiPatterns:["Overfitting to noise","Deep learning on insufficient signal"] },
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DATA â€” CLR SCHEMA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const CLR_SCHEMA = [
  { name:"ts", type:"int64", desc:"Unix epoch milliseconds â€” snapshot timestamp" },
  { name:"stream_id", type:"string", desc:"Source stream identifier (e.g., 'SPY_OHLCV')" },
  { name:"archetype", type:"enum", desc:"Detected behavioral archetype of the stream" },
  { name:"window", type:"int32", desc:"Lookback window size in observations" },
  { name:"operators", type:"map<str,f64>", desc:"Operator ID â†’ computed value at this snapshot" },
  { name:"regime", type:"string", desc:"Current detected regime label" },
  { name:"regime_conf", type:"float64", desc:"Confidence in regime assignment [0,1]" },
  { name:"flags", type:"string[]", desc:"Active anomaly/event flag identifiers" },
  { name:"hash", type:"bytes32", desc:"Content hash for deduplication and integrity" },
  { name:"meta", type:"map<str,any>", desc:"Optional extensible metadata" },
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DATA â€” TECHNIQUE DETAILS (strengths, weaknesses, connections)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const TECHNIQUE_DETAILS = {
  naive: {
    strengths:["Zero parameters â€” impossible to overfit","O(1) computation, always available","Universal baseline for any frequency"],
    weaknesses:["No trend, seasonality, or volatility capture","No prediction intervals","Equivalent to random walk assumption"],
    synergiesWith:["conformal","late_fusion"],conflictsWith:[],relatedTo:["seasonal_naive","ewma","moving_avg"],relevantOps:["L_mean"] },
  seasonal_naive: {
    strengths:["Captures seasonal patterns with zero tuning","Strong baseline for stable periodicity","Handles multiple seasonal periods"],
    weaknesses:["Assumes perfect periodicity","Cannot adapt to trend shifts","Breaks with evolving seasonality"],
    synergiesWith:["conformal","late_fusion"],conflictsWith:[],relatedTo:["naive","sarima","ets"],relevantOps:["L_mean","S_autocorr"] },
  ewma: {
    strengths:["Single parameter Î±, adaptive to level shifts","Memory-efficient O(1) streaming update","Low latency, suitable for real-time systems"],
    weaknesses:["Cannot model seasonality","Lags during sharp moves","No native prediction intervals"],
    synergiesWith:["garch","gbt","hmm","late_fusion"],conflictsWith:[],relatedTo:["moving_avg","kalman","naive"],relevantOps:["L_mean","D_momentum"] },
  moving_avg: {
    strengths:["Non-parametric smoothing, no distribution assumptions","Effective high-frequency noise removal","Easy to explain and audit"],
    weaknesses:["Lag proportional to window size","No extrapolation capability","Edge effects at series boundaries"],
    synergiesWith:["arima","gbt","garch","var"],conflictsWith:[],relatedTo:["ewma","stl","kalman"],relevantOps:["L_mean","L_median"] },
  arima: {
    strengths:["Solid Box-Jenkins theoretical foundation","Handles non-stationarity via differencing","Native prediction intervals from MLE"],
    weaknesses:["Linearity assumption limits expressiveness","Manual order selection (p,d,q) unless auto","Poor with structural breaks and regime changes"],
    synergiesWith:["stl","garch","conformal","moving_avg"],conflictsWith:["sarima","ets","theta"],relatedTo:["sarima","ets","theta","var"],relevantOps:["S_autocorr","ST_stationarity","D_velocity"] },
  sarima: {
    strengths:["Joint trend + seasonal + autocorrelation modeling","Well-studied inference properties","Works well on monthly/quarterly economic data"],
    weaknesses:["Combinatorial order selection (p,d,q)(P,D,Q)m","Assumes fixed seasonal period","Cannot model regime changes"],
    synergiesWith:["conformal","garch","stl"],conflictsWith:["arima","ets","prophet","nbeats"],relatedTo:["arima","ets","x13","seasonal_naive"],relevantOps:["S_autocorr","ST_stationarity"] },
  ets: {
    strengths:["Automatic model selection via AIC/BIC","Handles multiplicative seasonality","Interpretable error/trend/seasonal components"],
    weaknesses:["Limited to 30 pre-specified state-space forms","Cannot include exogenous regressors","Numerical issues with long seasonal periods"],
    synergiesWith:["garch","conformal"],conflictsWith:["sarima","prophet","structural_ts"],relatedTo:["arima","theta","sarima"],relevantOps:["L_mean","D_momentum"] },
  var: {
    strengths:["Captures cross-variable dynamics jointly","Granger causality testable from coefficients","Impulse response functions for policy analysis"],
    weaknesses:["Curse of dimensionality with many variables","Requires all series to be stationary","Cannot handle non-linear interactions"],
    synergiesWith:["stl","hmm","quantile_reg","moving_avg"],conflictsWith:[],relatedTo:["arima","garch"],relevantOps:["X_correlation","X_granger","ST_stationarity"] },
  garch: {
    strengths:["Purpose-built for volatility clustering","Captures fat tails and leverage effects","Feeds directly into risk metrics (VaR, ES)"],
    weaknesses:["Assumes specific parametric residual distribution","Cannot model mean (trend/seasonality)","Sensitive to outliers during estimation"],
    synergiesWith:["arima","ewma","stl","quantile_reg","moving_avg"],conflictsWith:[],relatedTo:["kalman","var","ewma"],relevantOps:["D_volatility","L_zscore","ST_stationarity"] },
  theta: {
    strengths:["Simple yet surprisingly competitive (M3 competition winner)","Only two theta-lines to extrapolate","Robust to overfitting on short series"],
    weaknesses:["No native seasonality handling","Theoretically equivalent to SES with drift","Limited extensibility"],
    synergiesWith:["conformal"],conflictsWith:["arima"],relatedTo:["arima","ets","ewma"],relevantOps:["L_mean","D_velocity"] },
  kalman: {
    strengths:["Optimal estimator under Gaussian-linear assumptions","Recursive O(n) with constant memory","Handles missing data and irregular timestamps natively"],
    weaknesses:["Requires explicit linear state-space specification","Sensitive to model misspecification","Gaussian assumption limits tail modeling"],
    synergiesWith:["hmm","gbt","conformal"],conflictsWith:[],relatedTo:["structural_ts","ewma"],relevantOps:["L_mean","D_velocity","D_volatility"] },
  structural_ts: {
    strengths:["Interpretable component decomposition via state-space","Handles irregular seasonality and missing data","Bayesian variants provide full uncertainty"],
    weaknesses:["Specification requires domain knowledge","Computationally heavier than ARIMA","Risk of overparameterization"],
    synergiesWith:["garch","conformal","hmm"],conflictsWith:["stl","prophet","bsts"],relatedTo:["bsts","stl","kalman"],relevantOps:["L_mean","S_autocorr"] },
  hmm: {
    strengths:["Discovers latent regime structure from data","Provides soft regime probabilities for downstream use","Handles non-stationarity via regime switching"],
    weaknesses:["Number of states must be pre-specified","EM convergence to local optima","Look-ahead risk if not properly windowed"],
    synergiesWith:["regime_logistic","gbt","kalman","late_fusion","var"],conflictsWith:[],relatedTo:["garch","structural_ts"],relevantOps:["S_cluster","E_regime"] },
  gbt: {
    strengths:["Handles arbitrary non-linear feature interactions","Built-in feature importance ranking","Robust to irrelevant and collinear features"],
    weaknesses:["Requires careful temporal feature engineering","High leakage risk without proper walk-forward CV","Cannot extrapolate beyond training data range"],
    synergiesWith:["stl","hmm","ewma","conformal","late_fusion"],conflictsWith:["rf"],relatedTo:["rf","svr","regime_logistic"],relevantOps:["L_mean","D_velocity","D_volatility","S_autocorr"] },
  rf: {
    strengths:["Parallelizable training, inherently lower variance","Built-in OOB error estimate, no separate validation","Handles mixed feature types without encoding"],
    weaknesses:["Cannot extrapolate, same limitation as all trees","Usually less accurate than boosting on tabular data","Large memory footprint with many trees"],
    synergiesWith:["stl","hmm","conformal"],conflictsWith:["gbt"],relatedTo:["gbt","svr"],relevantOps:["L_mean","D_velocity"] },
  svr: {
    strengths:["Kernel trick enables non-linearity without feature engineering","Effective in high-dimensional sparse feature spaces","Robust to overfitting via margin regularization"],
    weaknesses:["Scales poorly O(nÂ²) to O(nÂ³) with dataset size","Requires careful feature scaling","No native probabilistic output"],
    synergiesWith:["stl","conformal"],conflictsWith:[],relatedTo:["gbt","rf","gp"],relevantOps:["L_mean","D_velocity"] },
  regime_logistic: {
    strengths:["Interpretable coefficients per regime","Low parameter count, reduces overfitting","Explicit regime conditioning for auditability"],
    weaknesses:["Requires upstream regime labels","Linear within each regime","Cannot discover new or transitional regimes"],
    synergiesWith:["hmm","ewma","late_fusion"],conflictsWith:[],relatedTo:["gbt","hmm"],relevantOps:["S_cluster","E_regime"] },
  lstm: {
    strengths:["Learns long-range temporal dependencies via cell state","End-to-end feature learning from raw sequences","Flexible architecture for multivariate and multi-step"],
    weaknesses:["Requires large training data (>10k observations)","Sequential computation prevents parallelization","Prone to overfitting on small financial datasets"],
    synergiesWith:["stl","conformal","hmm","late_fusion"],conflictsWith:["gru"],relatedTo:["gru","transformer","deepar"],relevantOps:["D_momentum","S_autocorr"] },
  gru: {
    strengths:["Fewer parameters than LSTM, 30-40% faster training","Comparable accuracy on sequences < 200 steps","Simpler gradient flow reduces vanishing gradient issues"],
    weaknesses:["Same large-data requirements as LSTM","Less capacity for very long-range dependencies","Same overfitting risks on small datasets"],
    synergiesWith:["stl","conformal"],conflictsWith:["lstm"],relatedTo:["lstm","transformer"],relevantOps:["D_momentum","S_autocorr"] },
  transformer: {
    strengths:["Parallel computation over sequence (vs sequential RNN)","Self-attention discovers relevant lags automatically","State-of-the-art on large multivariate datasets"],
    weaknesses:["O(nÂ²) memory in sequence length","Needs very large training data to outperform ARIMA","Positional encoding design affects performance significantly"],
    synergiesWith:["stl","conformal"],conflictsWith:["tft"],relatedTo:["tft","nbeats","lstm"],relevantOps:["S_autocorr","D_momentum"] },
  nbeats: {
    strengths:["Interpretable trend/seasonal decomposition learned from data","No feature engineering required â€” pure univariate","Competitive with ensemble methods on M4 benchmark"],
    weaknesses:["Univariate only in base form, no exogenous inputs","Requires sufficient history for training","Block architecture limits flexibility"],
    synergiesWith:["conformal","garch"],conflictsWith:["stl","prophet"],relatedTo:["transformer","lstm","stl"],relevantOps:["L_mean","S_autocorr"] },
  tft: {
    strengths:["Variable importance via interpretable attention gates","Multi-horizon output in single forward pass","Handles static, known-future, and time-varying covariates"],
    weaknesses:["Complex architecture, difficult to debug and modify","Requires large training data to leverage full capacity","Slow inference on CPU, needs GPU for production"],
    synergiesWith:["stl","conformal"],conflictsWith:["transformer"],relatedTo:["transformer","deepar"],relevantOps:["S_autocorr","X_correlation"] },
  deepar: {
    strengths:["Full predictive distribution output (not just intervals)","Handles related time series jointly via shared parameters","No quantile crossing issues â€” produces coherent distributions"],
    weaknesses:["Parametric likelihood assumption may be misspecified","Requires sufficient training data per series","Slow sampling at inference time"],
    synergiesWith:["stl","hmm"],conflictsWith:[],relatedTo:["tft","bsts","lstm"],relevantOps:["D_volatility","S_autocorr"] },
  bsts: {
    strengths:["Full posterior over all structural components","Spike-and-slab variable selection for regressors","Google CausalImpact built directly on this framework"],
    weaknesses:["MCMC sampling is slow (minutes to hours)","Prior sensitivity requires Bayesian expertise","Scaling to hundreds of series is impractical"],
    synergiesWith:["garch","hmm"],conflictsWith:["structural_ts","prophet"],relatedTo:["structural_ts","gp","deepar"],relevantOps:["L_mean","S_autocorr","ST_stationarity"] },
  gp: {
    strengths:["Full uncertainty quantification from Bayesian posterior","Non-parametric â€” adapts model complexity to data","Kernel encodes inductive bias explicitly and transparently"],
    weaknesses:["O(nÂ³) training limits to ~10k data points","Kernel selection and hyperparameter tuning is an art","Posteriors can be overconfident far from training data"],
    synergiesWith:["stl","conformal"],conflictsWith:[],relatedTo:["bsts","svr"],relevantOps:["S_autocorr","ST_hurst"] },
  quantile_reg: {
    strengths:["Direct interval estimation without distributional assumptions","Reveals heteroskedasticity via crossing quantiles","Computationally efficient via linear programming"],
    weaknesses:["No coherent distribution â€” quantiles may cross","Requires feature engineering like any regression","Single quantile estimated per optimization"],
    synergiesWith:["gbt","var","arima","garch"],conflictsWith:["conformal"],relatedTo:["conformal","gp"],relevantOps:["L_quantile","L_zscore"] },
  conformal: {
    strengths:["Distribution-free finite-sample coverage guarantee","Model-agnostic â€” wraps any point predictor","Adaptive to non-stationarity via ACI variants"],
    weaknesses:["Requires exchangeability (relaxed in ACI)","Intervals may be wide if base model is poor","No parametric distribution, just intervals"],
    synergiesWith:["arima","gbt","lstm","transformer","prophet","ets","kalman","nbeats","tft","naive","rf","svr","theta"],conflictsWith:["quantile_reg"],relatedTo:["quantile_reg","model_avg"],relevantOps:["L_zscore","E_anomaly"] },
  stl: {
    strengths:["Robust to outliers via LOESS fitting","Separates signal into clean interpretable components","Residuals are approximately stationary â€” ideal for downstream models"],
    weaknesses:["Requires at least 2 full seasonal cycles","Additive only in base form, must log-transform for multiplicative","Single seasonal period â€” cannot handle dual seasonality natively"],
    synergiesWith:["arima","gbt","lstm","garch","var","gru","transformer","rf","svr","conformal","tft"],conflictsWith:["x13"],relatedTo:["x13","prophet","structural_ts"],relevantOps:["L_mean","S_autocorr","ST_stationarity"] },
  x13: {
    strengths:["Gold standard for seasonal adjustment (US Census Bureau)","Handles trading day, holiday, and outlier effects automatically","Produces publication-quality seasonally adjusted series"],
    weaknesses:["Designed for monthly/quarterly data only","Complex configuration with steep learning curve","Batch processing â€” not suited for streaming applications"],
    synergiesWith:["arima","gbt"],conflictsWith:["stl"],relatedTo:["stl","prophet","sarima"],relevantOps:["L_mean","S_autocorr"] },
  prophet: {
    strengths:["Handles holidays and special events with user-specified dates","Intuitive additive component model accessible to non-experts","Fast fitting enables interactive exploration of specifications"],
    weaknesses:["Additive linear trends can overshoot at long horizons","Less accurate than ARIMA on regular stationary series","Uncertainty intervals are often miscalibrated"],
    synergiesWith:["conformal","garch"],conflictsWith:["stl","nbeats","bsts","sarima"],relatedTo:["stl","bsts","ets"],relevantOps:["L_mean","S_autocorr"] },
  hawkes: {
    strengths:["Models event self-excitation and temporal clustering","Captures contagion and cascade dynamics analytically","Intensity function is interpretable and has closed-form mean"],
    weaknesses:["Assumes stationary base intensity","Parametric kernel limits flexibility (exponential/power-law)","Estimation difficult with very sparse event streams"],
    synergiesWith:["gbt","hmm","model_avg"],conflictsWith:["cox"],relatedTo:["cox"],relevantOps:["E_spike","E_catalyst","D_velocity"] },
  cox: {
    strengths:["Flexible random intensity driven by external covariates","Richer than Hawkes when external drivers are known","Full posterior on intensity with Bayesian MCMC methods"],
    weaknesses:["Requires explicit intensity model specification","Computationally expensive MCMC or variational inference","Less interpretable than Hawkes, more of a black box"],
    synergiesWith:["gbt","hmm"],conflictsWith:["hawkes"],relatedTo:["hawkes","gp"],relevantOps:["E_spike","E_catalyst","D_volatility"] },
  late_fusion: {
    strengths:["Simplest robust model combination â€” weighted average","No additional overfitting risk beyond base models","Weights can be updated online without full retraining"],
    weaknesses:["Requires diverse base models to be effective","Cannot learn non-linear interactions between model predictions","Optimal weights drift â€” requires periodic recalibration"],
    synergiesWith:["arima","gbt","lstm","hmm","regime_logistic"],conflictsWith:["stacking","model_avg"],relatedTo:["model_avg","stacking"],relevantOps:[] },
  stacking: {
    strengths:["Meta-learner captures non-linear model complementarities","Highest theoretical ceiling for model combination","Can use model predictions alongside raw features"],
    weaknesses:["High leakage risk â€” requires strict nested cross-validation","Computationally expensive: train all base models + meta-learner","Overfitting risk if base model errors are correlated"],
    synergiesWith:["gbt","lstm","arima"],conflictsWith:["late_fusion","model_avg"],relatedTo:["late_fusion","model_avg"],relevantOps:[] },
  model_avg: {
    strengths:["Bayesian model averaging provides calibrated model uncertainty","Robust to single model failure or misspecification","BIC/AIC weights have theoretical optimality properties"],
    weaknesses:["Assumes true model is in the candidate set (M-closed)","Weights tend to concentrate on single best model","Cannot improve beyond best model's systematic errors"],
    synergiesWith:["arima","gbt","bsts","hawkes"],conflictsWith:["late_fusion","stacking"],relatedTo:["late_fusion","stacking"],relevantOps:[] },
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HILBERT SPACE CAUSAL FRAMEWORK
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const HILBERT_CONCEPTS = [
  { id:"projection", name:"Orthogonal Projection", symbol:"P_H", color:T.blue,
    description:"Prediction as projection onto subspace of past information",
    hilbertMeaning:"Best predictor minimizes LÂ² distance to subspace â€” Var(X_{t+1}|H)",
    causalRole:"Granger causality = comparing projections onto nested subspaces H_X âŠ‚ H_{X,Y}",
    techniques:["naive","seasonal_naive","ewma","moving_avg","arima","sarima","ets","theta","kalman","quantile_reg","conformal"] },
  { id:"orthogonality", name:"Orthogonality = Independence", symbol:"X âŠ¥ Y â†” C_XY=0", color:T.green,
    description:"Statistical independence manifests as orthogonality of RKHS embeddings",
    hilbertMeaning:"C_XY = E[Ï†(X)âŠ—Ïˆ(Y)] = 0 iff X âŠ¥ Y when embedded in characteristic RKHS",
    causalRole:"HSIC / kernel conditional independence tests â€” conditioning annihilates the operator",
    techniques:["hmm","var","bsts","gp","regime_logistic"] },
  { id:"rkhs_lifting", name:"RKHS Lifting", symbol:"Ï†(x) âˆˆ H", color:T.orange,
    description:"Map nonlinear relationships to linear ones in infinite-dimensional Hilbert space",
    hilbertMeaning:"Kernel trick: k(x,y) = âŸ¨Ï†(x),Ï†(y)âŸ© replaces explicit infinite-dim feature maps",
    causalRole:"Kernel Granger causality detects nonlinear causal links invisible to linear methods",
    techniques:["gp","svr","gbt","rf","lstm","gru","transformer","nbeats","tft","deepar"] },
  { id:"tensor_product", name:"Tensor Factorization", symbol:"Hâ‚ âŠ— Hâ‚‚", color:T.crimson,
    description:"Multimodal signals live in tensor products of per-modality Hilbert spaces",
    hilbertMeaning:"Causality = whether projection onto one tensor factor reduces residual energy",
    causalRole:"Cross-modal causal inference via operator-valued kernels K: Hâ‚ â†’ Hâ‚‚",
    techniques:["var","tft","late_fusion","stacking","model_avg","regime_logistic"] },
  { id:"spectral", name:"Spectral Decomposition", symbol:"S_XY(Ï‰)", color:T.purple,
    description:"Time-delay causality as directional frequency flow via cross-spectrum operators",
    hilbertMeaning:"Spectral theorem decomposes covariance operators â€” eigenfunctions = frequency modes",
    causalRole:"Transfer entropy approximations, directed coherence, neural connectivity inference",
    techniques:["stl","x13","garch","sarima","prophet","nbeats","structural_ts","bsts"] },
  { id:"cross_covariance", name:"Cross-Covariance Operator", symbol:"C_XY = E[Ï†(X)âŠ—Ïˆ(Y)]", color:T.teal,
    description:"Operator encoding all dependencies between embedded signals",
    hilbertMeaning:"â€–C_XYâ€–_HS measures total dependence; C_XY=0 â†” independence in RKHS",
    causalRole:"HSIC statistic, kernel conditional independence, operator-valued regression",
    techniques:["var","gp","hmm","hawkes","cox","kalman","ewma"] },
];

const HILBERT_MAPPING = {
  naive:{ concept:"projection", interpretation:"Constant projection: P_H(X_{t+1}) = X_t â€” degenerate subspace" },
  seasonal_naive:{ concept:"projection", interpretation:"Periodic subspace projection: copies value from same phase of previous cycle" },
  ewma:{ concept:"cross_covariance", interpretation:"Exponentially weighted projection â€” implicitly estimates local cross-covariance" },
  moving_avg:{ concept:"projection", interpretation:"Uniform projection onto finite-window subspace span{X_{t-w},...,X_t}" },
  arima:{ concept:"projection", interpretation:"Projection onto ARMA subspace after differencing to achieve stationarity" },
  sarima:{ concept:"projection", interpretation:"Seasonal subspace projection: H = span{Ï†_p(X), Ï†_P(X_season)}" },
  ets:{ concept:"projection", interpretation:"State-space projection decomposing into error, trend, seasonal components" },
  var:{ concept:"cross_covariance", interpretation:"Joint projection exploiting cross-covariance C_XY between series â€” Granger testable" },
  garch:{ concept:"spectral", interpretation:"2nd-moment spectral projection: models volatility as autoregressive spectrum of squared residuals" },
  theta:{ concept:"projection", interpretation:"Projection onto theta-line subspace â€” equivalent to SES with drift" },
  kalman:{ concept:"projection", interpretation:"Optimal recursive projection P_{H_t}(X_t): minimizes posterior variance at each step" },
  structural_ts:{ concept:"spectral", interpretation:"State-space spectral decomposition into trend + seasonal + cycle eigenmodes" },
  hmm:{ concept:"orthogonality", interpretation:"Regime detection via orthogonal state partitioning: P(regime|obs) factorizes" },
  gbt:{ concept:"rkhs_lifting", interpretation:"Tree ensemble â‰ˆ projection in implicit RKHS defined by leaf partition kernel" },
  rf:{ concept:"rkhs_lifting", interpretation:"Random forest kernel K(x,y) = fraction of trees placing x,y in same leaf" },
  svr:{ concept:"rkhs_lifting", interpretation:"Explicit RKHS projection: f(x) = âŸ¨w,Ï†(x)âŸ©_H with Îµ-insensitive loss" },
  regime_logistic:{ concept:"tensor_product", interpretation:"Regime âŠ— features tensor product: prediction conditioned on regime factor" },
  lstm:{ concept:"rkhs_lifting", interpretation:"Learned nonlinear lifting Ï†: sequence â†’ H via gated memory cells" },
  gru:{ concept:"rkhs_lifting", interpretation:"Gated lifting into representation space â€” simplified RKHS with reset/update" },
  transformer:{ concept:"rkhs_lifting", interpretation:"Self-attention â‰ˆ softmax kernel regression: K(q,k) = exp(qÂ·k/âˆšd)" },
  nbeats:{ concept:"spectral", interpretation:"Learned basis expansion â‰ˆ data-adaptive spectral decomposition into trend + harmonic" },
  tft:{ concept:"tensor_product", interpretation:"Variable selection via attention in covariate tensor space H_static âŠ— H_temporal" },
  deepar:{ concept:"rkhs_lifting", interpretation:"Autoregressive RNN: maps sequences to likelihood parameters via learned Ï†" },
  bsts:{ concept:"spectral", interpretation:"Bayesian spectral decomposition with spike-and-slab prior on component inclusion" },
  gp:{ concept:"rkhs_lifting", interpretation:"Exact RKHS projection: posterior mean = P_{span{k(Â·,x_i)}}(f) in kernel Hilbert space" },
  quantile_reg:{ concept:"projection", interpretation:"Asymmetric LÂ¹ projection: minimizes weighted absolute deviation per quantile" },
  conformal:{ concept:"projection", interpretation:"Nonparametric projection set with finite-sample coverage via exchangeability" },
  stl:{ concept:"spectral", interpretation:"LOESS-based spectral separation: trend (low-freq) + seasonal (periodic) + residual" },
  x13:{ concept:"spectral", interpretation:"Calendar-aware spectral decomposition with trading-day + holiday adjustment" },
  prophet:{ concept:"spectral", interpretation:"Projection onto trend + Fourier seasonal basis: f(t) = g(t) + Î£ aâ‚™sin(2Ï€nt/P)" },
  hawkes:{ concept:"cross_covariance", interpretation:"Self-excitation kernel Î¼(t) = Î¼â‚€ + Î£ Î±Â·exp(-Î²(t-táµ¢)) â€” causal intensity coupling" },
  cox:{ concept:"cross_covariance", interpretation:"Doubly stochastic intensity: random projection in event-counting Hilbert space" },
  late_fusion:{ concept:"tensor_product", interpretation:"Averaging over model tensor factors: f = Î£ wáµ¢ fáµ¢ where fáµ¢ âˆˆ Háµ¢" },
  stacking:{ concept:"tensor_product", interpretation:"Meta-learner in tensor product: g(fâ‚(x),...,fâ‚–(x)) maps Hâ‚âŠ—...âŠ—Hâ‚– â†’ R" },
  model_avg:{ concept:"tensor_product", interpretation:"Bayesian model-space averaging: E_Ï€[f] over model index factor" },
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DATA â€” KNOWN SYNERGIES (54 documented pairings)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const KNOWN_SYNERGIES = [
  { from:"stl", to:"arima", reason:"STL removes trend+seasonality, leaving stationary residuals ideal for ARIMA modeling", principles:[1,2,5] },
  { from:"stl", to:"garch", reason:"STL residuals reveal volatility clustering that GARCH is designed to capture", principles:[1,2,5] },
  { from:"stl", to:"gbt", reason:"Decomposed components (trend, seasonal, residual) become clean features for gradient boosting", principles:[1,3] },
  { from:"stl", to:"lstm", reason:"Pre-decomposition reduces non-stationarity, letting LSTM focus on complex residual dynamics", principles:[1,5] },
  { from:"stl", to:"transformer", reason:"Decomposition lets transformer attend to residual patterns without learning seasonality from scratch", principles:[1,5] },
  { from:"stl", to:"gp", reason:"Decomposed residuals are well-suited for GP regression with stationary kernels", principles:[1,5] },
  { from:"stl", to:"var", reason:"Decomposed residuals from multiple series create a stationary multivariate system for VAR", principles:[1,2,5] },
  { from:"hmm", to:"regime_logistic", reason:"HMM provides regime labels that logistic regression uses to make regime-conditional predictions", principles:[1,7] },
  { from:"hmm", to:"gbt", reason:"Regime labels from HMM become powerful categorical features for tree-based models", principles:[1,7] },
  { from:"hmm", to:"late_fusion", reason:"Regime probabilities from HMM can weight ensemble members by regime-specific accuracy", principles:[1,3] },
  { from:"hmm", to:"var", reason:"Regime-conditional VAR parameters capture state-dependent cross-variable dynamics", principles:[1,7] },
  { from:"arima", to:"conformal", reason:"ARIMA point forecasts gain distribution-free coverage guarantees from conformal prediction", principles:[1,3,6] },
  { from:"gbt", to:"conformal", reason:"ML predictions wrapped with conformal intervals achieve both accuracy and calibrated coverage", principles:[1,3,6] },
  { from:"lstm", to:"conformal", reason:"Deep learning forecasts gain rigorous finite-sample coverage guarantees", principles:[1,3,6] },
  { from:"prophet", to:"conformal", reason:"Prophet's often-miscalibrated intervals replaced with distribution-free coverage guarantees", principles:[1,3,6] },
  { from:"tft", to:"conformal", reason:"TFT multi-horizon forecasts wrapped with conformal intervals for reliable coverage", principles:[1,3,6] },
  { from:"arima", to:"garch", reason:"ARIMA for mean equation + GARCH for variance equation = complete specification", principles:[1,2] },
  { from:"ewma", to:"garch", reason:"EWMA-smoothed level estimate feeds cleanly into GARCH volatility model â€” level/vol separation", principles:[1,2] },
  { from:"ewma", to:"hmm", reason:"Smoothed features improve HMM regime detection by reducing observation noise", principles:[1,3] },
  { from:"kalman", to:"hmm", reason:"Kalman-filtered state estimates provide cleaned input for regime classification", principles:[1,3] },
  { from:"moving_avg", to:"var", reason:"Smoothed series better satisfy stationarity assumptions required by VAR", principles:[1,5] },
  { from:"moving_avg", to:"gbt", reason:"Moving average features at multiple window sizes are powerful predictors for tree models", principles:[1,3] },
  { from:"garch", to:"quantile_reg", reason:"Volatility features from GARCH inform quantile regression for heteroskedastic risk intervals", principles:[1,2] },
  { from:"hawkes", to:"gbt", reason:"Hawkes intensity features capture event clustering that tree models can exploit as features", principles:[1,3] },
  { from:"bsts", to:"model_avg", reason:"Multiple BSTS specifications averaged via posterior model probabilities for robust inference", principles:[1,12] },
  { from:"kalman", to:"gbt", reason:"Kalman-filtered state estimates create clean features for gradient boosting", principles:[1,3] },
  { from:"kalman", to:"conformal", reason:"Kalman point estimates gain distribution-free coverage guarantees", principles:[1,3,6] },
  { from:"garch", to:"hmm", reason:"Volatility features from GARCH improve regime boundary detection", principles:[1,7] },
  { from:"x13", to:"arima", reason:"Official seasonal adjustment leaves calendar-clean residuals for ARIMA", principles:[1,2,5] },
  { from:"x13", to:"gbt", reason:"Calendar-adjusted features from X-13 are clean inputs for tree models", principles:[1,3] },
  { from:"stl", to:"rf", reason:"Decomposed components become interpretable features for random forest", principles:[1,3] },
  { from:"stl", to:"nbeats", reason:"Pre-decomposed residuals let N-BEATS focus on complex patterns", principles:[1,5] },
  { from:"hmm", to:"garch", reason:"Regime-conditional GARCH captures state-dependent volatility dynamics", principles:[1,7] },
  { from:"hmm", to:"kalman", reason:"Regime labels enable switching Kalman filter for state-dependent dynamics", principles:[1,7] },
  { from:"gp", to:"conformal", reason:"GP posterior uncertainty wrapped with conformal for finite-sample coverage", principles:[1,3,6] },
  { from:"stacking", to:"conformal", reason:"Stacked ensemble predictions calibrated with conformal intervals", principles:[1,3,6] },
  { from:"deepar", to:"model_avg", reason:"Multiple DeepAR runs with different seeds averaged for robust distributions", principles:[1,12] },
  { from:"nbeats", to:"conformal", reason:"N-BEATS point forecasts gain distribution-free coverage guarantees", principles:[1,3,6] },
  { from:"rf", to:"conformal", reason:"Random forest predictions wrapped with conformal for reliable intervals", principles:[1,3,6] },
  { from:"gru", to:"conformal", reason:"GRU point forecasts calibrated with conformal prediction sets", principles:[1,3,6] },
  { from:"var", to:"garch", reason:"VAR for multivariate mean equation + GARCH for marginal variance â€” complete spec", principles:[1,2] },
  { from:"cox", to:"gbt", reason:"Cox process intensity estimates become powerful features for tree models", principles:[1,3] },
  { from:"prophet", to:"gbt", reason:"Prophet residuals + regressors create rich features for gradient boosting", principles:[1,3] },
  { from:"ewma", to:"gbt", reason:"EWMA at multiple decay rates creates informative smoothed features for trees", principles:[1,3] },
  { from:"ewma", to:"lstm", reason:"Smoothed input reduces noise, letting LSTM focus on temporal structure", principles:[1,3] },
  { from:"structural_ts", to:"conformal", reason:"Structural TS point forecasts gain coverage guarantees from conformal", principles:[1,3,6] },
  { from:"theta", to:"conformal", reason:"Theta's simple forecasts gain rigorous prediction intervals", principles:[1,3,6] },
  { from:"svr", to:"conformal", reason:"SVR regression surface wrapped with conformal coverage bands", principles:[1,3,6] },
  { from:"hmm", to:"stacking", reason:"Regime probabilities become meta-features for stacking ensemble", principles:[1,3,7] },
  { from:"stl", to:"deepar", reason:"Pre-decomposition lets DeepAR model residual dynamics with less data", principles:[1,5] },
  { from:"stl", to:"svr", reason:"Decomposed components as features reduce non-stationarity for SVR", principles:[1,5] },
  { from:"hawkes", to:"hmm", reason:"Hawkes intensity dynamics reveal event clustering for regime detection", principles:[1,7] },
  { from:"moving_avg", to:"kalman", reason:"Pre-smoothed observations reduce observation noise for Kalman filter", principles:[1,3] },
  { from:"moving_avg", to:"lstm", reason:"Multi-window moving averages create temporal features for LSTM", principles:[1,3] },
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DATA â€” KNOWN CONFLICTS (15 documented anti-patterns)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const KNOWN_CONFLICTS = [
  { from:"sarima", to:"ets", reason:"Both own trend+seasonality â€” impossible to attribute which component comes from which model", violation:2, severity:"fail" },
  { from:"sarima", to:"prophet", reason:"Both model trend+seasonality â€” redundant decomposition creates uninterpretable pipeline", violation:2, severity:"fail" },
  { from:"prophet", to:"nbeats", reason:"Both learn trend/seasonal decomposition â€” N-BEATS would re-decompose Prophet's output", violation:2, severity:"fail" },
  { from:"stl", to:"x13", reason:"Two decomposition transforms in sequence â€” X-13 would try to decompose already-decomposed data", violation:2, severity:"fail" },
  { from:"structural_ts", to:"bsts", reason:"Nearly identical state-space decomposition approaches â€” one is completely redundant", violation:2, severity:"fail" },
  { from:"conformal", to:"arima", reason:"Calibration step before model step violates pipeline role ordering (calibrationâ†’model)", violation:3, severity:"fail" },
  { from:"stacking", to:"gbt", reason:"Decision/meta-learner before base model violates causal ordering", violation:3, severity:"fail" },
  { from:"late_fusion", to:"lstm", reason:"Ensemble decision step before model step â€” reversed pipeline direction", violation:3, severity:"fail" },
  { from:"hawkes", to:"theta", reason:"Tick-level point process chained with monthly-only method â€” incompatible time scales", violation:4, severity:"fail" },
  { from:"kalman", to:"x13", reason:"Real-time streaming filter feeding into monthly/quarterly batch method â€” scale mismatch", violation:4, severity:"fail" },
  { from:"gbt", to:"rf", reason:"Both tree-based with correlated errors â€” minimal diversity benefit if ensembled together", violation:12, severity:"warn" },
  { from:"lstm", to:"gru", reason:"Both gated RNNs with nearly identical error profiles â€” wastes compute without diversity", violation:12, severity:"warn" },
  { from:"transformer", to:"tft", reason:"Both attention-based architectures â€” high error correlation undermines combination benefit", violation:12, severity:"warn" },
  { from:"prophet", to:"stl", reason:"Prophet already decomposes internally â€” STL would re-decompose, destroying component structure", violation:2, severity:"warn" },
  { from:"nbeats", to:"stl", reason:"N-BEATS learns decomposition end-to-end â€” STL after it would re-separate already-separated components", violation:2, severity:"warn" },
  { from:"bsts", to:"ets", reason:"Both own trend+seasonality decomposition â€” redundant component modeling", violation:2, severity:"fail" },
  { from:"structural_ts", to:"stl", reason:"Both decompose into trend+seasonal â€” chaining re-decomposes already-decomposed output", violation:2, severity:"fail" },
  { from:"prophet", to:"structural_ts", reason:"Both decompose into components â€” structural TS would re-decompose Prophet's decomposition", violation:2, severity:"fail" },
  { from:"nbeats", to:"ets", reason:"N-BEATS learns its own decomposition â€” ETS would model already-decomposed output", violation:2, severity:"warn" },
  { from:"deepar", to:"gp", reason:"Both produce full predictive distributions â€” stacking uncertainties is incoherent", violation:2, severity:"warn" },
  { from:"deepar", to:"quantile_reg", reason:"Both produce distributional output â€” redundant uncertainty quantification", violation:2, severity:"warn" },
  { from:"rf", to:"svr", reason:"Both single-output regressors with similar error profiles â€” minimal diversity gain", violation:12, severity:"warn" },
  { from:"model_avg", to:"stacking", reason:"Both ensemble combination methods at same pipeline level â€” cannot stack a stack", violation:3, severity:"fail" },
  { from:"model_avg", to:"late_fusion", reason:"Two ensemble aggregation steps in sequence â€” second would trivially average one model", violation:3, severity:"fail" },
  { from:"x13", to:"stl", reason:"Both seasonal decomposition methods â€” X-13 output is already decomposed", violation:2, severity:"fail" },
  { from:"hawkes", to:"cox", reason:"Both model event arrival intensity â€” redundant point process specification", violation:2, severity:"fail" },
  { from:"bsts", to:"prophet", reason:"Both decompose into trend+seasonality with Bayesian/MAP estimation â€” fully redundant", violation:2, severity:"fail" },
  { from:"arima", to:"theta", reason:"Theta is equivalent to SES with drift â€” conflicts with ARIMA's trend specification", violation:2, severity:"warn" },
  { from:"late_fusion", to:"stacking", reason:"Both are meta-learner steps â€” one combination method is sufficient", violation:3, severity:"fail" },
  { from:"gru", to:"lstm", reason:"Both gated RNNs with nearly identical architectures â€” insufficient diversity", violation:12, severity:"warn" },
  { from:"ets", to:"structural_ts", reason:"Both state-space models owning trend+seasonality â€” redundant component estimation", violation:2, severity:"fail" },
  { from:"gp", to:"bsts", reason:"Both probabilistic models with full posteriors â€” stacking posteriors lacks coherence", violation:2, severity:"warn" },
  { from:"quantile_reg", to:"conformal", reason:"Both calibration-step methods â€” redundant interval estimation", violation:2, severity:"warn" },
  { from:"sarima", to:"nbeats", reason:"Both model trend+seasonality â€” N-BEATS would re-learn what SARIMA already captured", violation:2, severity:"fail" },
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DATA â€” CANONICAL PIPELINES (12 recommended chains)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const CANONICAL_PIPELINES = [
  { id:"quick_baseline", name:"Quick Baseline", description:"Minimal viable forecast â€” establish the floor before adding complexity",
    steps:["naive","conformal"], archetype:"any", complexity:1, useCase:"First benchmark for any new series" },
  { id:"seasonal_forecast", name:"Seasonal Forecasting", description:"Classical decomposition â†’ seasonal model â†’ calibrated intervals",
    steps:["stl","sarima","conformal"], archetype:"seasonal", complexity:3, useCase:"Retail sales, energy demand, quarterly financials" },
  { id:"regime_aware_ml", name:"Regime-Aware ML", description:"Detect hidden regimes â†’ predict conditional on regime â†’ combine",
    steps:["hmm","regime_logistic","late_fusion"], archetype:"regime_switching", complexity:3, useCase:"Trading signals across bull/bear markets" },
  { id:"volatility_pipeline", name:"Volatility Pipeline", description:"Separate level from volatility â†’ model each â†’ risk quantiles",
    steps:["stl","garch","quantile_reg"], archetype:"regime_switching", complexity:3, useCase:"Risk management, VaR and ES estimation" },
  { id:"deep_sequence", name:"Deep Sequence", description:"Decompose â†’ model residuals with LSTM â†’ conformal coverage",
    steps:["stl","lstm","conformal"], archetype:"trending", complexity:4, useCase:"Complex non-linear dynamics with coverage guarantees" },
  { id:"bayesian_stack", name:"Bayesian Full-Stack", description:"Bayesian structural model with posterior model averaging",
    steps:["bsts","model_avg"], archetype:"trending", complexity:4, useCase:"Causal impact analysis, macro forecasting" },
  { id:"event_cascade", name:"Event Cascade", description:"Model self-excitation â†’ extract features â†’ robust combination",
    steps:["hawkes","gbt","model_avg"], archetype:"event_driven", complexity:4, useCase:"News cascades, order flow, social contagion" },
  { id:"cross_asset", name:"Cross-Asset System", description:"Smooth â†’ multivariate dynamics â†’ heteroskedastic risk intervals",
    steps:["moving_avg","var","quantile_reg"], archetype:"mean_reverting", complexity:3, useCase:"Multi-asset portfolio, macro indicators" },
  { id:"ml_ensemble", name:"ML Competition Pipeline", description:"Decompose â†’ diverse ML â†’ stack with meta-learner",
    steps:["stl","gbt","stacking"], archetype:"seasonal", complexity:4, useCase:"Forecasting competitions, maximum accuracy" },
  { id:"robust_diverse", name:"Robust Diverse Ensemble", description:"Multi-family models combined for variance reduction",
    steps:["moving_avg","arima","late_fusion"], archetype:"any", complexity:2, useCase:"Production deployment, robust to model failure" },
  { id:"attention_forecast", name:"Attention Forecasting", description:"Decompose â†’ transformer â†’ conformal calibration",
    steps:["stl","transformer","conformal"], archetype:"trending", complexity:5, useCase:"Large datasets with complex multi-horizon patterns" },
  { id:"noise_filter", name:"Noise Filtering", description:"Smooth â†’ state estimation â†’ non-parametric uncertainty",
    steps:["moving_avg","kalman","gp"], archetype:"high_freq_noise", complexity:4, useCase:"Sensor data, noisy high-frequency signals" },
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COMPOSABILITY ENGINE (enhanced with synergy/conflict data)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const ROLE_ORDER = { transform:0, feature:1, model:2, calibration:3, decision:4 };

// Build fast lookup tables
const _synergyMap = {};
KNOWN_SYNERGIES.forEach(s => { _synergyMap[`${s.from}|${s.to}`] = s; });
const _conflictMap = {};
KNOWN_CONFLICTS.forEach(c => { _conflictMap[`${c.from}|${c.to}`] = c; });

function checkComposition(techA, techB) {
  const checks = [];
  const key = `${techA.id}|${techB.id}`;
  const synergy = _synergyMap[key];
  const conflict = _conflictMap[key];

  // 1. Semantic compatibility â€” does B accept A's output type?
  const typeOverlap = techA.outputTypes.some(t => techB.inputTypes.includes(t));
  // Also check if decomposed output feeds univariate consumer (common pattern)
  const implicitCompat = techA.outputTypes.includes("decomposed") && techB.inputTypes.includes("univariate");
  const semanticOk = typeOverlap || implicitCompat;
  checks.push({ name:"Semantic Compatibility", pass:semanticOk,
    severity: semanticOk ? "ok" : "fail",
    detail: semanticOk
      ? (implicitCompat && !typeOverlap)
        ? `decomposed components feed as univariate (implicit)`
        : `${techA.outputTypes.filter(t=>techB.inputTypes.includes(t)).join(", ")} accepted`
      : `${techA.name} outputs [${techA.outputTypes}] but ${techB.name} needs [${techB.inputTypes}]` });

  // 2. Ownership â€” do they own the same responsibility?
  const shared = techA.ownedResponsibilities.filter(r => techB.ownedResponsibilities.includes(r));
  checks.push({ name:"Ownership", pass: shared.length === 0,
    severity: shared.length === 0 ? "ok" : shared.length > 1 ? "fail" : "warn",
    detail: shared.length === 0 ? "No responsibility overlap" : `Both own: ${shared.join(", ")}` });

  // 3. Time honesty â€” does pipeline role ordering hold?
  const orderA = ROLE_ORDER[techA.pipelineRole] ?? 2;
  const orderB = ROLE_ORDER[techB.pipelineRole] ?? 2;
  const timeOk = orderA <= orderB;
  checks.push({ name:"Time Honesty", pass:timeOk,
    severity: timeOk ? "ok" : "fail",
    detail: timeOk ? `${techA.pipelineRole} â†’ ${techB.pipelineRole} preserves causal order`
      : `${techA.pipelineRole} â†’ ${techB.pipelineRole} violates pipeline ordering` });

  // 4. Scale compatibility â€” are time scales reconciled?
  const scaleOverlap = techA.timeScales.some(s => techB.timeScales.includes(s));
  const sharedScales = techA.timeScales.filter(s => techB.timeScales.includes(s));
  checks.push({ name:"Scale Compatibility", pass:scaleOverlap,
    severity: scaleOverlap ? "ok" : "warn",
    detail: scaleOverlap ? `Shared: ${sharedScales.join(", ")}` : `Mismatch: [${techA.timeScales}] vs [${techB.timeScales}]` });

  // 5. Evaluation integrity â€” does chaining force snooping?
  const bothHigh = techA.leakageRisk === "high" && techB.leakageRisk === "high";
  checks.push({ name:"Evaluation Integrity", pass:!bothHigh,
    severity: bothHigh ? "warn" : "ok",
    detail: bothHigh ? "Both high leakage risk â€” nested CV required" : "Evaluation isolation maintainable" });

  // 6. Identifiability â€” can you still ablate?
  const sameModel = techA.pipelineRole === "model" && techB.pipelineRole === "model";
  checks.push({ name:"Identifiability", pass:!sameModel,
    severity: sameModel ? "warn" : "ok",
    detail: sameModel ? "Two models in sequence â€” ablation requires care" : "Components independently testable" });

  // 7. Known synergy boost
  if (synergy) {
    checks.push({ name:"Known Synergy", pass:true, severity:"ok",
      detail: `âœ¦ ${synergy.reason} (principles ${synergy.principles.join(",")})` });
  }

  // 8. Known conflict penalty
  if (conflict) {
    checks.push({ name:"Known Conflict", pass:false, severity:conflict.severity,
      detail: `âœ— ${conflict.reason} (violates principle ${conflict.violation})` });
  }

  const total = checks.length;
  const score = checks.reduce((s,c) => s + (c.severity === "ok" ? 1 : c.severity === "warn" ? 0.5 : 0), 0) / total;
  return { score, checks, synergy: !!synergy, conflict: !!conflict };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FEED INFRASTRUCTURE â€” generators, detection, recommendations
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function gaussianRandom() {
  let u = 0, v = 0;
  while (u === 0) u = Math.random();
  while (v === 0) v = Math.random();
  return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
}

function generateRandomWalk(n=365, drift=0.001, vol=0.02) {
  const data = [100];
  for (let i = 1; i < n; i++) data.push(data[i-1] * (1 + drift + vol * gaussianRandom()));
  return data;
}

function generateSeasonal(n=365, period=7, amplitude=10, trend=0.05, noiseStd=2) {
  return Array.from({length:n}, (_, i) =>
    50 + trend * i + amplitude * Math.sin(2 * Math.PI * i / period) + noiseStd * gaussianRandom()
  );
}

function generateRegimeSwitching(n=500, p01=0.02, p10=0.03) {
  let regime = 0;
  const data = [100];
  for (let i = 1; i < n; i++) {
    if (regime === 0 && Math.random() < p01) regime = 1;
    else if (regime === 1 && Math.random() < p10) regime = 0;
    const vol = regime === 0 ? 0.008 : 0.035;
    const drift = regime === 0 ? 0.0005 : -0.001;
    data.push(data[i-1] * (1 + drift + vol * gaussianRandom()));
  }
  return data;
}

function generateMeanReverting(n=365, mean=100, speed=0.05, vol=3) {
  const data = [mean + (Math.random() - 0.5) * 20];
  for (let i = 1; i < n; i++) data.push(data[i-1] + speed * (mean - data[i-1]) + vol * gaussianRandom());
  return data;
}

function generateEventDriven(n=365, baseRate=0.1, excitement=0.3, decay=0.95) {
  const intensity = [baseRate];
  const events = [];
  const data = [0];
  for (let i = 1; i < n; i++) {
    if (Math.random() < intensity[i-1]) {
      events.push(i);
      data.push(data[i-1] + 1 + Math.random() * 3);
    } else {
      data.push(data[i-1] * 0.995);
    }
    let lambda = baseRate;
    events.forEach(e => { lambda += excitement * Math.pow(decay, i - e); });
    intensity.push(Math.min(lambda, 0.95));
  }
  return data;
}

function generateHighFreqNoise(n=1000, signalFreq=0.01, snr=0.3) {
  return Array.from({length:n}, (_, i) =>
    snr * Math.sin(2 * Math.PI * signalFreq * i) + (1 - snr) * gaussianRandom()
  );
}

function generateMultiSeasonal(n=730, periods=[7,30,365], amps=[5,8,15], trend=0.02, noise=2) {
  return Array.from({length:n}, (_, i) => {
    let v = 40 + trend * i;
    periods.forEach((p,j) => { v += (amps[j]||5) * Math.sin(2 * Math.PI * i / p); });
    return v + noise * gaussianRandom();
  });
}

function generateLevelShift(n=365, shiftAt=180, shiftSize=20, vol=2) {
  return Array.from({length:n}, (_, i) =>
    50 + (i >= shiftAt ? shiftSize : 0) + vol * gaussianRandom()
  );
}

// â”€â”€â”€ Characteristic Detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function detectCharacteristics(data) {
  const n = data.length;
  if (n < 10) return { error:"Too few data points", n };

  const mean = data.reduce((s,v) => s + v, 0) / n;
  const std = Math.sqrt(data.reduce((s,v) => s + (v - mean) ** 2, 0) / n);

  // Linear regression slope
  const xMean = (n - 1) / 2;
  let num = 0, den = 0;
  for (let i = 0; i < n; i++) { num += (i - xMean) * (data[i] - mean); den += (i - xMean) ** 2; }
  const slope = den > 0 ? num / den : 0;
  const trendStrength = Math.abs(slope * n / (std + 1e-10));
  const hasTrend = trendStrength > 0.5;

  // Autocorrelation function
  function autocorr(lag) {
    let nm = 0, dn = 0;
    for (let i = 0; i < n; i++) dn += (data[i] - mean) ** 2;
    for (let i = lag; i < n; i++) nm += (data[i] - mean) * (data[i - lag] - mean);
    return dn > 0 ? nm / dn : 0;
  }

  // Check seasonal periods
  const seasonalLags = [4, 5, 7, 12, 24, 30, 52, 60, 90, 168, 365].filter(l => l < n / 3);
  const acfs = seasonalLags.map(l => ({ lag: l, acf: autocorr(l) }));
  const bestSeasonal = acfs.reduce((a, b) => Math.abs(b.acf) > Math.abs(a.acf) ? b : a, { lag: 0, acf: 0 });
  const hasSeasonality = Math.abs(bestSeasonal.acf) > 0.25;

  // Stationarity proxy (split-half)
  const half = Math.floor(n / 2);
  const mean1 = data.slice(0, half).reduce((s, v) => s + v, 0) / half;
  const mean2 = data.slice(half).reduce((s, v) => s + v, 0) / (n - half);
  const var1 = data.slice(0, half).reduce((s, v) => s + (v - mean1) ** 2, 0) / half;
  const var2 = data.slice(half).reduce((s, v) => s + (v - mean2) ** 2, 0) / (n - half);
  const meanShift = Math.abs(mean2 - mean1) / (std + 1e-10);
  const varRatio = Math.max(var1, var2) / (Math.min(var1, var2) + 1e-10);
  const isStationary = meanShift < 0.5 && varRatio < 2;

  // Volatility clustering (squared return autocorrelation)
  const returns = [];
  for (let i = 1; i < n; i++) returns.push(data[i] - data[i - 1]);
  const retMean = returns.reduce((s, v) => s + v, 0) / returns.length;
  const retStd = Math.sqrt(returns.reduce((s, v) => s + (v - retMean) ** 2, 0) / returns.length);
  const sqReturns = returns.map(r => r * r);
  const sqMean = sqReturns.reduce((s, v) => s + v, 0) / sqReturns.length;
  let vcNum = 0, vcDen = 0;
  for (let i = 0; i < sqReturns.length; i++) vcDen += (sqReturns[i] - sqMean) ** 2;
  for (let i = 1; i < sqReturns.length; i++) vcNum += (sqReturns[i] - sqMean) * (sqReturns[i - 1] - sqMean);
  const volAutocorr = vcDen > 0 ? vcNum / vcDen : 0;
  const hasVolClustering = volAutocorr > 0.15;

  // Noise level
  const noiseRatio = std / (Math.abs(mean) + 1e-10);
  const noiseLevel = noiseRatio > 0.5 ? "high" : noiseRatio > 0.1 ? "medium" : "low";

  // Skewness & kurtosis
  const skew = data.reduce((s, v) => s + ((v - mean) / (std + 1e-10)) ** 3, 0) / n;
  const kurt = data.reduce((s, v) => s + ((v - mean) / (std + 1e-10)) ** 4, 0) / n - 3;

  // Lag-1 autocorrelation (persistence)
  const lag1 = autocorr(1);

  // Min, max, range
  const min = Math.min(...data);
  const max = Math.max(...data);

  return {
    n, mean, std, min, max, slope,
    hasTrend, trendStrength, trendDirection: slope > 0 ? "up" : "down",
    hasSeasonality, seasonalPeriod: bestSeasonal.lag, seasonalStrength: Math.abs(bestSeasonal.acf),
    isStationary, meanShift, varRatio,
    hasVolClustering, volAutocorr,
    noiseLevel, noiseRatio,
    skewness: skew, kurtosis: kurt,
    lag1Autocorr: lag1,
    allAcfs: acfs,
    retMean, retStd,
  };
}

// â”€â”€â”€ Technique & Pipeline Recommendation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function recommendTechniques(chars) {
  const recs = [];
  recs.push({ id: "naive", reason: "Universal baseline", priority: 1 });
  recs.push({ id: "conformal", reason: "Distribution-free prediction intervals", priority: 2 });

  if (chars.hasSeasonality) {
    recs.push({ id: "seasonal_naive", reason: `Seasonal pattern (periodâ‰ˆ${chars.seasonalPeriod}, acf=${chars.seasonalStrength.toFixed(2)})`, priority: 1 });
    recs.push({ id: "stl", reason: "Decompose seasonal structure before modeling", priority: 2 });
    recs.push({ id: "sarima", reason: "Seasonal ARIMA for periodic series", priority: 2 });
    recs.push({ id: "ets", reason: "ETS handles seasonal components natively", priority: 2 });
    recs.push({ id: "prophet", reason: "Multiple seasonalities + holidays", priority: 3 });
    recs.push({ id: "x13", reason: "Official seasonal adjustment with calendar effects", priority: 3 });
  }

  if (chars.hasTrend) {
    recs.push({ id: "arima", reason: `Trend detected (slope=${chars.slope.toFixed(4)}, strength=${chars.trendStrength.toFixed(2)})`, priority: 2 });
    recs.push({ id: "theta", reason: "Theta excels at trended short series", priority: 2 });
    if (!chars.hasSeasonality) recs.push({ id: "ets", reason: "ETS trend component", priority: 2 });
    recs.push({ id: "structural_ts", reason: "State-space trend decomposition", priority: 3 });
  }

  if (chars.hasVolClustering) {
    recs.push({ id: "garch", reason: `Volatility clustering (vol_acf=${chars.volAutocorr.toFixed(2)})`, priority: 2 });
    recs.push({ id: "ewma", reason: "Adaptive level tracking for volatile series", priority: 2 });
    recs.push({ id: "hmm", reason: "Regime detection for volatility states", priority: 3 });
    recs.push({ id: "quantile_reg", reason: "Quantile estimation for heteroskedastic risk", priority: 3 });
  }

  if (!chars.isStationary) {
    recs.push({ id: "stl", reason: `Non-stationary (mean_shift=${chars.meanShift.toFixed(2)}, var_ratio=${chars.varRatio.toFixed(2)})`, priority: 2 });
    recs.push({ id: "kalman", reason: "Kalman filter for non-stationary state tracking", priority: 3 });
  }

  if (chars.isStationary && !chars.hasTrend && !chars.hasSeasonality) {
    recs.push({ id: "arima", reason: "Stationary ARIMA (low d) for autocorrelated residuals", priority: 2 });
    recs.push({ id: "var", reason: "VAR if multivariate context available", priority: 3 });
    recs.push({ id: "gp", reason: "GP regression with stationary kernel", priority: 3 });
  }

  if (chars.n > 500) {
    recs.push({ id: "lstm", reason: `Sufficient data (n=${chars.n}) for sequence learning`, priority: 3 });
    recs.push({ id: "transformer", reason: "Attention for long-range dependencies", priority: 3 });
    recs.push({ id: "tft", reason: "TFT with variable selection", priority: 3 });
    recs.push({ id: "nbeats", reason: "N-BEATS interpretable deep forecasting", priority: 3 });
    recs.push({ id: "deepar", reason: "Probabilistic deep autoregression", priority: 3 });
  } else if (chars.n > 200) {
    recs.push({ id: "gbt", reason: `Moderate data (n=${chars.n}) â€” tree models feasible`, priority: 3 });
    recs.push({ id: "rf", reason: "Random forest with lag features", priority: 3 });
  }

  if (chars.noiseLevel === "high") {
    recs.push({ id: "moving_avg", reason: `High noise (ratio=${chars.noiseRatio.toFixed(2)}) â€” smoothing recommended`, priority: 2 });
    recs.push({ id: "kalman", reason: "Kalman filtering for noisy observations", priority: 3 });
    recs.push({ id: "gp", reason: "GP posterior mean is a denoiser", priority: 3 });
  }

  if (Math.abs(chars.kurtosis) > 3) {
    recs.push({ id: "garch", reason: `Heavy tails (kurtosis=${chars.kurtosis.toFixed(1)})`, priority: 3 });
    recs.push({ id: "quantile_reg", reason: "Quantile regression for fat-tailed distributions", priority: 3 });
  }

  if (chars.lag1Autocorr > 0.8) {
    recs.push({ id: "ewma", reason: `High persistence (lag1_acf=${chars.lag1Autocorr.toFixed(2)})`, priority: 2 });
  }

  // Deduplicate by id, keeping highest priority
  const seen = {};
  return recs.filter(r => { if (seen[r.id]) return false; seen[r.id] = true; return true; })
    .sort((a, b) => a.priority - b.priority);
}

function recommendPipelines(chars) {
  return CANONICAL_PIPELINES.filter(p => {
    if (p.archetype === "any") return true;
    if (p.archetype === "seasonal" && chars.hasSeasonality) return true;
    if (p.archetype === "trending" && chars.hasTrend) return true;
    if (p.archetype === "regime_switching" && chars.hasVolClustering) return true;
    if (p.archetype === "mean_reverting" && chars.isStationary && !chars.hasTrend) return true;
    if (p.archetype === "high_freq_noise" && chars.noiseLevel === "high") return true;
    if (p.archetype === "event_driven" && !chars.isStationary && !chars.hasTrend) return true;
    return false;
  });
}

// â”€â”€â”€ Feed Definitions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const LIVE_FEEDS = [
  { id:"weather_berlin", name:"Berlin Temperature", category:"weather", archetype:"seasonal",
    description:"Hourly temperature (past 90 days) â€” strong daily + seasonal cycles",
    url:"https://api.open-meteo.com/v1/forecast?latitude=52.52&longitude=13.41&hourly=temperature_2m&past_days=90&forecast_days=0",
    parse: d => ({ values: d.hourly.temperature_2m.filter(v => v !== null), name:"Berlin Â°C" }) },
  { id:"weather_nyc", name:"NYC Temperature", category:"weather", archetype:"seasonal",
    description:"Hourly temperature (past 90 days) â€” continental seasonal pattern",
    url:"https://api.open-meteo.com/v1/forecast?latitude=40.71&longitude=-74.01&hourly=temperature_2m&past_days=90&forecast_days=0",
    parse: d => ({ values: d.hourly.temperature_2m.filter(v => v !== null), name:"NYC Â°C" }) },
  { id:"weather_tokyo", name:"Tokyo Temperature", category:"weather", archetype:"seasonal",
    description:"Hourly temperature (past 90 days) â€” maritime seasonal with typhoon noise",
    url:"https://api.open-meteo.com/v1/forecast?latitude=35.68&longitude=139.69&hourly=temperature_2m&past_days=90&forecast_days=0",
    parse: d => ({ values: d.hourly.temperature_2m.filter(v => v !== null), name:"Tokyo Â°C" }) },
  { id:"weather_sydney", name:"Sydney Temperature", category:"weather", archetype:"seasonal",
    description:"Hourly temperature (past 90 days) â€” southern hemisphere, inverse seasonality",
    url:"https://api.open-meteo.com/v1/forecast?latitude=-33.87&longitude=151.21&hourly=temperature_2m&past_days=90&forecast_days=0",
    parse: d => ({ values: d.hourly.temperature_2m.filter(v => v !== null), name:"Sydney Â°C" }) },
  { id:"weather_wind_berlin", name:"Berlin Wind Speed", category:"weather", archetype:"high_freq_noise",
    description:"Hourly wind speed (past 90 days) â€” noisy, bursty, non-negative",
    url:"https://api.open-meteo.com/v1/forecast?latitude=52.52&longitude=13.41&hourly=wind_speed_10m&past_days=90&forecast_days=0",
    parse: d => ({ values: d.hourly.wind_speed_10m.filter(v => v !== null), name:"Berlin Wind km/h" }) },
  { id:"weather_rain_london", name:"London Precipitation", category:"weather", archetype:"event_driven",
    description:"Hourly precipitation (past 90 days) â€” intermittent, zero-inflated",
    url:"https://api.open-meteo.com/v1/forecast?latitude=51.51&longitude=-0.13&hourly=precipitation&past_days=90&forecast_days=0",
    parse: d => ({ values: d.hourly.precipitation.filter(v => v !== null), name:"London Rain mm" }) },
  { id:"weather_humidity_mumbai", name:"Mumbai Humidity", category:"weather", archetype:"seasonal",
    description:"Hourly relative humidity (past 90 days) â€” monsoon seasonality",
    url:"https://api.open-meteo.com/v1/forecast?latitude=19.08&longitude=72.88&hourly=relative_humidity_2m&past_days=90&forecast_days=0",
    parse: d => ({ values: d.hourly.relative_humidity_2m.filter(v => v !== null), name:"Mumbai RH %" }) },
  { id:"weather_pressure_iceland", name:"Reykjavik Pressure", category:"weather", archetype:"mean_reverting",
    description:"Hourly surface pressure (past 90 days) â€” mean-reverting with weather systems",
    url:"https://api.open-meteo.com/v1/forecast?latitude=64.15&longitude=-21.95&hourly=surface_pressure&past_days=90&forecast_days=0",
    parse: d => ({ values: d.hourly.surface_pressure.filter(v => v !== null), name:"Reykjavik hPa" }) },
  { id:"bitcoin", name:"Bitcoin / USD", category:"crypto", archetype:"regime_switching",
    description:"90-day price history â€” volatility clustering, regime shifts, fat tails",
    url:"https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=usd&days=90",
    parse: d => ({ values: d.prices.map(p => p[1]), name:"BTC/USD" }) },
  { id:"ethereum", name:"Ethereum / USD", category:"crypto", archetype:"regime_switching",
    description:"90-day price history â€” correlated with BTC, high volatility",
    url:"https://api.coingecko.com/api/v3/coins/ethereum/market_chart?vs_currency=usd&days=90",
    parse: d => ({ values: d.prices.map(p => p[1]), name:"ETH/USD" }) },
  { id:"solana", name:"Solana / USD", category:"crypto", archetype:"regime_switching",
    description:"90-day price history â€” high beta, frequent regime switches",
    url:"https://api.coingecko.com/api/v3/coins/solana/market_chart?vs_currency=usd&days=90",
    parse: d => ({ values: d.prices.map(p => p[1]), name:"SOL/USD" }) },
];

const SYNTHETIC_FEEDS = [
  { id:"syn_trending", name:"Trending Walk", archetype:"trending",
    description:"Random walk with positive drift â€” tests trend detection and extrapolation",
    generate: () => generateRandomWalk(365, 0.002, 0.015) },
  { id:"syn_seasonal", name:"Weekly Seasonal", archetype:"seasonal",
    description:"Clear 7-day cycle + trend + noise â€” tests decomposition and seasonal models",
    generate: () => generateSeasonal(365, 7, 12, 0.03, 2) },
  { id:"syn_multi_seasonal", name:"Multi-Seasonal", archetype:"seasonal",
    description:"Daily (7) + monthly (30) + annual (365) cycles â€” tests Prophet, TFT, multi-period models",
    generate: () => generateMultiSeasonal(730) },
  { id:"syn_regime", name:"Regime Switching", archetype:"regime_switching",
    description:"Two-state HMM with different volatility â€” tests HMM, GARCH, regime-gated methods",
    generate: () => generateRegimeSwitching(500, 0.02, 0.03) },
  { id:"syn_meanrev", name:"Mean Reverting", archetype:"mean_reverting",
    description:"Ornstein-Uhlenbeck process â€” tests stationary models, VAR, spread trading",
    generate: () => generateMeanReverting(365, 100, 0.05, 3) },
  { id:"syn_events", name:"Event Cascade", archetype:"event_driven",
    description:"Self-exciting point process (Hawkes-like) â€” tests Hawkes, Cox, event-driven pipelines",
    generate: () => generateEventDriven(365, 0.1, 0.3, 0.95) },
  { id:"syn_noisy", name:"Noisy Signal", archetype:"high_freq_noise",
    description:"Weak sinusoid buried in Gaussian noise â€” tests Kalman, GP, smoothing methods",
    generate: () => generateHighFreqNoise(1000, 0.01, 0.3) },
  { id:"syn_level_shift", name:"Level Shift", archetype:"trending",
    description:"Abrupt structural break mid-series â€” tests adaptivity and change detection",
    generate: () => generateLevelShift(365, 180, 25, 2) },
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SIMULATION ENGINE â€” simplified technique transforms
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function simulateStep(techId, data) {
  const n = data.length;
  if (n < 3) return { values: data, label: "pass-through" };
  switch (techId) {
    case 'moving_avg': {
      const w = Math.max(2, Math.min(7, Math.floor(n / 20)));
      return { values: data.map((_, i) => {
        const lo = Math.max(0, i - w), hi = Math.min(n - 1, i + w);
        let s = 0; for (let j = lo; j <= hi; j++) s += data[j];
        return s / (hi - lo + 1);
      }), label: `MA(${2 * w + 1}) smoothed` };
    }
    case 'ewma': {
      const a = 0.15, r = [data[0]];
      for (let i = 1; i < n; i++) r.push(a * data[i] + (1 - a) * r[i - 1]);
      return { values: r, label: "EWMA(Î±=0.15)" };
    }
    case 'stl': case 'x13': {
      const w = Math.max(3, Math.min(14, Math.floor(n / 8)));
      const trend = data.map((_, i) => {
        const lo = Math.max(0, i - w), hi = Math.min(n - 1, i + w);
        let s = 0; for (let j = lo; j <= hi; j++) s += data[j];
        return s / (hi - lo + 1);
      });
      return { values: data.map((v, i) => v - trend[i]), label: "Residuals (trend removed)", trend };
    }
    case 'arima': case 'sarima': case 'theta': {
      return { values: data.slice(1).map((v, i) => v - data[i]), label: "Î” first-differenced" };
    }
    case 'garch': {
      const ret = data.slice(1).map((v, i) => v - data[i]);
      const sq = ret.map(r => r * r);
      const a = 0.06, vol = [Math.sqrt(sq[0])];
      for (let i = 1; i < sq.length; i++) vol.push(Math.sqrt(a * sq[i] + (1 - a) * vol[i - 1] * vol[i - 1]));
      return { values: vol, label: "Ïƒ GARCH volatility" };
    }
    case 'var': {
      const a = 0.2, r = [data[0]];
      for (let i = 1; i < n; i++) r.push(a * data[i] + (1 - a) * r[i - 1]);
      return { values: r, label: "VAR fitted" };
    }
    case 'kalman': {
      let x = data[0], P = 1; const Q = 0.01, R = 1, out = [x];
      for (let i = 1; i < n; i++) {
        const Pp = P + Q, K = Pp / (Pp + R);
        x = x + K * (data[i] - x); P = (1 - K) * Pp; out.push(x);
      }
      return { values: out, label: "Kalman filtered" };
    }
    case 'structural_ts': case 'bsts': case 'prophet': {
      const w = Math.max(5, Math.min(20, Math.floor(n / 10)));
      const trend = data.map((_, i) => {
        const lo = Math.max(0, i - w), hi = Math.min(n - 1, i + w);
        let s = 0; for (let j = lo; j <= hi; j++) s += data[j];
        return s / (hi - lo + 1);
      });
      return { values: trend, label: "Structural trend estimate" };
    }
    case 'hmm': {
      const w = Math.max(5, Math.min(30, Math.floor(n / 10)));
      const vol = data.map((_, i) => {
        const lo = Math.max(0, i - w), sl = data.slice(lo, i + 1);
        const m = sl.reduce((s, v) => s + v, 0) / sl.length;
        return Math.sqrt(sl.reduce((s, v) => s + (v - m) ** 2, 0) / sl.length);
      });
      const med = [...vol].sort((a, b) => a - b)[Math.floor(vol.length / 2)];
      return { values: vol.map(v => v > med * 1.2 ? 1 : 0), label: "Regime (0=calm 1=volatile)" };
    }
    case 'conformal': {
      const mean = data.reduce((s, v) => s + v, 0) / n;
      const std = Math.sqrt(data.reduce((s, v) => s + (v - mean) ** 2, 0) / n);
      return { values: data, label: `Â±${(std * 1.96).toFixed(2)} conformal band`, band: std * 1.96 };
    }
    case 'quantile_reg': {
      const w = Math.max(5, Math.min(30, Math.floor(n / 8)));
      const lo = data.map((_, i) => {
        const sl = [...data.slice(Math.max(0, i - w), i + 1)].sort((a, b) => a - b);
        return sl[Math.floor(sl.length * 0.1)];
      });
      const hi = data.map((_, i) => {
        const sl = [...data.slice(Math.max(0, i - w), i + 1)].sort((a, b) => a - b);
        return sl[Math.floor(sl.length * 0.9)];
      });
      return { values: data, label: "Q10â€“Q90 risk bands", bands: { lo, hi } };
    }
    case 'late_fusion': case 'model_avg': case 'stacking': {
      const a = 0.2, r = [data[0]];
      for (let i = 1; i < n; i++) r.push(a * data[i] + (1 - a) * r[i - 1]);
      return { values: data.map((v, i) => (v + r[i]) / 2), label: "Ensemble combination" };
    }
    default: {
      const a = 0.25, r = [data[0]];
      for (let i = 1; i < n; i++) r.push(a * data[i] + (1 - a) * r[i - 1]);
      return { values: r, label: `${techId} output (smoothed)` };
    }
  }
}

function percolatePipeline(rawData, steps) {
  const stages = [{ techId: '_input', values: rawData, label: 'Raw Feed' }];
  let current = [...rawData];
  steps.forEach(stepId => {
    const result = simulateStep(stepId, current);
    stages.push({ techId: stepId, values: result.values, label: result.label, band: result.band, bands: result.bands, trend: result.trend });
    current = result.values.filter(v => typeof v === 'number' && isFinite(v));
    if (current.length < 3) current = rawData; // fallback
  });
  return stages;
}

// â”€â”€â”€ Path Discovery â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function findSynergyPaths(startId, maxDepth = 5) {
  const paths = [];
  const startTech = TECHNIQUES.find(t => t.id === startId);
  if (!startTech) return paths;
  function dfs(currentId, path, currentRole) {
    if (path.length >= 2) paths.push([...path]);
    if (path.length >= maxDepth) return;
    KNOWN_SYNERGIES.forEach(s => {
      if (s.from === currentId) {
        const t = TECHNIQUES.find(x => x.id === s.to);
        if (!t || path.includes(s.to)) return;
        const role = ROLE_ORDER[t.pipelineRole] ?? 2;
        if (role >= currentRole) dfs(s.to, [...path, s.to], role);
      }
    });
  }
  dfs(startId, [startId], ROLE_ORDER[startTech.pipelineRole] ?? 2);
  return paths.map(p => {
    let total = 0, pairs = 0;
    for (let i = 0; i < p.length - 1; i++) {
      const a = TECHNIQUES.find(t => t.id === p[i]), b = TECHNIQUES.find(t => t.id === p[i + 1]);
      if (a && b) { total += checkComposition(a, b).score; pairs++; }
    }
    return { steps: p, score: pairs > 0 ? total / pairs : 0, length: p.length };
  }).sort((a, b) => b.score - a.score || b.length - a.length);
}

// â”€â”€â”€ Graph Layout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const GRAPH_COL_DEFS = [
  { x: 55, label: "TRANSFORM" },
  { x: 175, label: "FEATURE" },
  { x: 305, label: "BASE / STAT" },
  { x: 450, label: "STATE / ML" },
  { x: 600, label: "DEEP / PROB" },
  { x: 775, label: "CALIBRATE" },
  { x: 935, label: "DECIDE" },
];

const NODE_COL = {
  moving_avg:0, stl:0, x13:0,
  hmm:1,
  naive:2, seasonal_naive:2, ewma:2, arima:2, sarima:2, ets:2, var:2, garch:2, theta:2,
  kalman:3, structural_ts:3, prophet:3, gbt:3, rf:3, svr:3, regime_logistic:3, hawkes:3, cox:3,
  lstm:4, gru:4, transformer:4, nbeats:4, tft:4, deepar:4, bsts:4, gp:4,
  quantile_reg:5, conformal:5,
  late_fusion:6, stacking:6, model_avg:6,
};

function computeNodePositions(H) {
  const cols = {};
  TECHNIQUES.forEach(t => {
    const c = NODE_COL[t.id]; if (c === undefined) return;
    if (!cols[c]) cols[c] = [];
    cols[c].push(t);
  });
  const pos = {};
  Object.entries(cols).forEach(([c, techs]) => {
    const ci = parseInt(c);
    const x = GRAPH_COL_DEFS[ci].x;
    const sp = Math.min(56, (H - 80) / (techs.length + 1));
    const startY = (H - sp * (techs.length - 1)) / 2;
    techs.forEach((t, i) => { pos[t.id] = { x, y: startY + i * sp }; });
  });
  return pos;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CAUSAL INFERENCE ENGINE â€” Granger + Kernel + HSIC
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function grangerTest(x, y, lags = 5) {
  const n = Math.min(x.length, y.length) - lags;
  if (n < lags * 3) return { reduction: 0, fStat: 0, detail: "Insufficient data" };
  const target = [], featR = [], featU = [];
  for (let t = lags; t < lags + n; t++) {
    target.push(x[t]);
    const xL = [], xyL = [];
    for (let l = 1; l <= lags; l++) { xL.push(x[t - l]); xyL.push(x[t - l]); }
    for (let l = 1; l <= lags; l++) { xyL.push(y[t - l]); }
    featR.push(xL); featU.push(xyL);
  }
  function olsRSS(tgt, feat) {
    const m = tgt.length, p = feat[0].length;
    const A = Array.from({ length: p }, () => new Array(p + 1).fill(0));
    for (let i = 0; i < m; i++) for (let j = 0; j < p; j++) {
      A[j][p] += feat[i][j] * tgt[i];
      for (let k = j; k < p; k++) { A[j][k] += feat[i][j] * feat[i][k]; if (k > j) A[k][j] = A[j][k]; }
    }
    for (let j = 0; j < p; j++) A[j][j] += 1e-6;
    for (let i = 0; i < p; i++) {
      let mx = i; for (let j = i + 1; j < p; j++) if (Math.abs(A[j][i]) > Math.abs(A[mx][i])) mx = j;
      [A[i], A[mx]] = [A[mx], A[i]]; if (Math.abs(A[i][i]) < 1e-12) continue;
      for (let j = i + 1; j < p; j++) { const f = A[j][i] / A[i][i]; for (let k = i; k <= p; k++) A[j][k] -= f * A[i][k]; }
    }
    const beta = new Array(p).fill(0);
    for (let i = p - 1; i >= 0; i--) { beta[i] = A[i][p]; for (let j = i + 1; j < p; j++) beta[i] -= A[i][j] * beta[j]; beta[i] /= A[i][i] || 1; }
    let rss = 0;
    for (let i = 0; i < m; i++) { let pred = 0; for (let j = 0; j < p; j++) pred += feat[i][j] * beta[j]; rss += (tgt[i] - pred) ** 2; }
    return rss / m;
  }
  const rssR = olsRSS(target, featR), rssU = olsRSS(target, featU);
  const reduction = rssR > 0 ? 1 - rssU / rssR : 0;
  const fStat = lags > 0 ? ((rssR - rssU) / lags) / (rssU / Math.max(1, n - 2 * lags - 1)) : 0;
  return { reduction, fStat, rssR, rssU, n };
}

function kernelGrangerTest(x, y, lags = 5) {
  const n = Math.min(x.length, y.length) - lags;
  const maxN = Math.min(n, 150);
  const step = Math.max(1, Math.floor(n / maxN));
  const target = [], featX = [], featXY = [];
  for (let t = lags; t < lags + n; t += step) {
    target.push(x[t]);
    const xL = [], xyL = [];
    for (let l = 1; l <= lags; l++) { xL.push(x[t - l]); xyL.push(x[t - l]); }
    for (let l = 1; l <= lags; l++) { xyL.push(y[t - l]); }
    featX.push(xL); featXY.push(xyL);
  }
  // Median heuristic for bandwidth
  const dists = [];
  for (let i = 0; i < Math.min(80, featX.length); i++)
    for (let j = i + 1; j < Math.min(80, featX.length); j++) {
      let d = 0; for (let k = 0; k < featX[i].length; k++) d += (featX[i][k] - featX[j][k]) ** 2;
      dists.push(Math.sqrt(d));
    }
  dists.sort((a, b) => a - b);
  const sigma = dists[Math.floor(dists.length / 2)] || 1;
  const m = target.length, lam = 1e-3;

  function krr(feats) {
    const K = Array.from({ length: m }, (_, i) => {
      const row = new Array(m);
      for (let j = 0; j < m; j++) {
        let sq = 0; for (let d = 0; d < feats[i].length; d++) sq += (feats[i][d] - feats[j][d]) ** 2;
        row[j] = Math.exp(-sq / (2 * sigma * sigma)) + (i === j ? lam : 0);
      }
      return row;
    });
    const A = K.map((row, i) => [...row, target[i]]);
    for (let i = 0; i < m; i++) {
      let mx = i; for (let j = i + 1; j < m; j++) if (Math.abs(A[j][i]) > Math.abs(A[mx][i])) mx = j;
      [A[i], A[mx]] = [A[mx], A[i]]; if (Math.abs(A[i][i]) < 1e-12) continue;
      for (let j = i + 1; j < m; j++) { const f = A[j][i] / A[i][i]; for (let k = i; k <= m; k++) A[j][k] -= f * A[i][k]; }
    }
    const alpha = new Array(m).fill(0);
    for (let i = m - 1; i >= 0; i--) { alpha[i] = A[i][m]; for (let j = i + 1; j < m; j++) alpha[i] -= A[i][j] * alpha[j]; alpha[i] /= A[i][i] || 1; }
    let rss = 0;
    for (let i = 0; i < m; i++) {
      let pred = 0;
      for (let j = 0; j < m; j++) {
        let sq = 0; for (let d = 0; d < feats[i].length; d++) sq += (feats[i][d] - feats[j][d]) ** 2;
        pred += alpha[j] * Math.exp(-sq / (2 * sigma * sigma));
      }
      rss += (target[i] - pred) ** 2;
    }
    return rss / m;
  }
  const rssR = krr(featX), rssU = krr(featXY);
  const reduction = rssR > 0 ? 1 - rssU / rssR : 0;
  return { reduction, rssR, rssU, n: m, sigma };
}

function hsicTest(x, y) {
  const n = Math.min(x.length, y.length, 200);
  const xs = x.slice(0, n), ys = y.slice(0, n);
  const dists = [];
  for (let i = 0; i < Math.min(60, n); i++)
    for (let j = i + 1; j < Math.min(60, n); j++) dists.push(Math.abs(xs[i] - xs[j]));
  dists.sort((a, b) => a - b);
  const sigma = dists[Math.floor(dists.length / 2)] || 1;
  const s2 = 2 * sigma * sigma;
  let trKL = 0, totalK = 0, totalL = 0;
  const Kcol = new Array(n).fill(0), Lcol = new Array(n).fill(0);
  for (let i = 0; i < n; i++) for (let j = 0; j < n; j++) {
    const kij = Math.exp(-(xs[i] - xs[j]) ** 2 / s2);
    const lij = Math.exp(-(ys[i] - ys[j]) ** 2 / s2);
    trKL += kij * lij; totalK += kij; totalL += lij; Kcol[j] += kij; Lcol[j] += lij;
  }
  let sumKL1 = 0;
  for (let j = 0; j < n; j++) sumKL1 += Kcol[j] * Lcol[j];
  const hsic = (1 / (n * n)) * (trKL - (2 / n) * sumKL1 + (1 / (n * n)) * totalK * totalL);
  return { hsic, n, sigma };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REUSED COMPONENTS (from init)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function Chip({ level, children, style: sx, onClick }) {
  const c = level ? lc(level) : null;
  return (
    <span onClick={onClick} style={{
      display:"inline-flex", alignItems:"center", gap:"0.35em",
      fontFamily:T.mono, fontSize:"0.68rem", fontWeight:500,
      padding:"0.25em 0.65em", borderRadius:T.rSm,
      border:`1px solid ${c ? `${c.base}44` : T.border1}`,
      background: c ? c.dim : T.bg2, color: c ? c.base : T.text1,
      whiteSpace:"nowrap", cursor: onClick ? "pointer" : "default", ...sx,
    }}>
      {c && <span style={{ width:6, height:6, borderRadius:"50%", background:c.base, boxShadow:`0 0 6px ${c.base}`, flexShrink:0 }} />}
      {children || (level ? c.label : "")}
    </span>
  );
}

function Badge({ children, color = T.crimson }) {
  return (
    <span style={{
      display:"inline-flex", alignItems:"center", justifyContent:"center",
      minWidth:20, height:20, fontFamily:T.mono, fontSize:"0.6rem",
      fontWeight:600, padding:"0 5px", borderRadius:T.rPill,
      background:color, color: [T.yellow,T.teal,T.green].includes(color) ? "#0a1a10" : "#fff",
    }}>{children}</span>
  );
}

function StatusDot({ color, pulse, size = 8 }) {
  return (
    <span style={{ width:size, height:size, borderRadius:"50%", background:color, display:"inline-block", position:"relative", flexShrink:0 }}>
      {pulse && <span style={{ position:"absolute", inset:-3, borderRadius:"50%", border:`1px solid ${color}`, animation:"statusPulse 2s ease-in-out infinite" }} />}
    </span>
  );
}

function Sparkline({ data, width = 200, height = 40, color = T.blue, showRange = false, showMean = false, filled = false }) {
  if (!data || data.length < 2) return null;
  const min = Math.min(...data);
  const max = Math.max(...data);
  const range = max - min || 1;
  const pts = data.map((v, i) =>
    `${(i / (data.length - 1)) * width},${height - ((v - min) / range) * (height - 4) - 2}`
  );
  const line = pts.join(" ");
  const fillPath = filled ? `M0,${height} L${line.split(" ").map((p, i) => i === 0 ? p.replace(/^/, "") : p).join(" L")} L${width},${height} Z` : null;
  const meanY = height - (((data.reduce((s, v) => s + v, 0) / data.length) - min) / range) * (height - 4) - 2;
  return (
    <svg width={width} height={height} style={{ display: "block" }}>
      {filled && <path d={`M0,${height} ${pts.map((p, i) => `L${p}`).join(" ")} L${width},${height} Z`}
        fill={`${color}15`} />}
      <polyline points={line} fill="none" stroke={color} strokeWidth={1.2} />
      {showMean && <line x1={0} y1={meanY} x2={width} y2={meanY} stroke={T.text3} strokeWidth={0.5} strokeDasharray="3,3" />}
      {showRange && (
        <React.Fragment>
          <text x={width - 2} y={9} textAnchor="end" style={{ fontFamily: T.mono, fontSize: 8, fill: T.text3 }}>{max.toFixed(1)}</text>
          <text x={width - 2} y={height - 2} textAnchor="end" style={{ fontFamily: T.mono, fontSize: 8, fill: T.text3 }}>{min.toFixed(1)}</text>
        </React.Fragment>
      )}
    </svg>
  );
}

function AcfChart({ acfs, width = 240, height = 60, threshold = 0.25 }) {
  if (!acfs || acfs.length === 0) return null;
  const maxAcf = Math.max(...acfs.map(a => Math.abs(a.acf)), 0.5);
  const barW = Math.min(20, (width - 20) / acfs.length - 2);
  const midY = height / 2;
  return (
    <svg width={width} height={height} style={{ display: "block" }}>
      <line x1={0} y1={midY} x2={width} y2={midY} stroke={T.border1} strokeWidth={0.5} />
      <line x1={0} y1={midY - (threshold / maxAcf) * midY} x2={width} y2={midY - (threshold / maxAcf) * midY}
        stroke={T.crimson} strokeWidth={0.5} strokeDasharray="3,2" />
      <line x1={0} y1={midY + (threshold / maxAcf) * midY} x2={width} y2={midY + (threshold / maxAcf) * midY}
        stroke={T.crimson} strokeWidth={0.5} strokeDasharray="3,2" />
      {acfs.map((a, i) => {
        const x = 10 + i * (barW + 2);
        const h = (a.acf / maxAcf) * midY;
        const c = Math.abs(a.acf) > threshold ? T.blue : T.text3;
        return (
          <React.Fragment key={a.lag}>
            <rect x={x} y={h > 0 ? midY - h : midY} width={barW} height={Math.abs(h)} fill={c} rx={1} />
            <text x={x + barW / 2} y={height - 1} textAnchor="middle" style={{ fontFamily: T.mono, fontSize: 7, fill: T.text3 }}>{a.lag}</text>
          </React.Fragment>
        );
      })}
    </svg>
  );
}

function ProgressBar({ value, color, thick }) {
  return (
    <div style={{ width:"100%", height: thick ? 10 : 6, background:T.bg3, borderRadius:T.rPill, overflow:"hidden" }}>
      <div style={{ height:"100%", width:`${Math.min(100,value*100)}%`, background:color, borderRadius:T.rPill, transition:"width 0.6s cubic-bezier(0.22,1,0.36,1)" }} />
    </div>
  );
}

function MetricCard({ label, value, unit, delta, deltaDir, color }) {
  return (
    <div style={{ background:T.bg1, border:`1px solid ${T.border0}`, borderRadius:T.rMd, padding:16 }}>
      <div style={{ fontFamily:T.mono, fontSize:"0.6rem", textTransform:"uppercase", letterSpacing:"0.14em", color:T.text3, marginBottom:6 }}>{label}</div>
      <div style={{ fontFamily:T.display, fontWeight:700, fontSize:"1.6rem", color:color||T.text0, lineHeight:1 }}>
        {value}{unit && <span style={{ fontSize:"0.8rem", fontWeight:400 }}>{unit}</span>}
      </div>
      {delta && <div style={{ fontFamily:T.mono, fontSize:"0.65rem", marginTop:6, color: deltaDir==="up"?T.green:deltaDir==="down"?T.crimson:T.text3 }}>{delta}</div>}
    </div>
  );
}

function Section({ title, count, color, children, style:sx }) {
  return (
    <div style={{ background:T.bg1, border:`1px solid ${T.border0}`, borderRadius:T.rMd, overflow:"hidden", ...sx }}>
      {color && <div style={{ height:3, width:"100%", background:color }} />}
      <div style={{ padding:"14px 16px" }}>
        <div style={{ display:"flex", justifyContent:"space-between", alignItems:"center", marginBottom:14, paddingBottom:10, borderBottom:`1px solid ${T.border0}` }}>
          <span style={{ fontFamily:T.display, fontWeight:700, fontSize:"0.95rem", color:T.text0 }}>{title}</span>
          {count !== undefined && <Badge color={color||T.teal}>{count}</Badge>}
        </div>
        {children}
      </div>
    </div>
  );
}

function Segmented({ options, active, onChange }) {
  return (
    <div style={{ display:"inline-flex", background:T.bg2, border:`1px solid ${T.border0}`, borderRadius:T.rMd, padding:2, gap:2, flexWrap:"wrap" }}>
      {options.map(o => (
        <button key={o.key} onClick={() => onChange(o.key)} style={{
          fontFamily:T.mono, fontSize:"0.68rem", padding:"0.3em 0.7em",
          borderRadius:T.rSm, border:"none", cursor:"pointer",
          background: active===o.key ? T.bg4 : "transparent",
          color: active===o.key ? T.text0 : T.text3,
        }}>{o.label}</button>
      ))}
    </div>
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NEW COMPONENTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function TabBar({ tabs, active, onChange }) {
  return (
    <div style={{ display:"flex", gap:2, background:T.bg2, border:`1px solid ${T.border0}`, borderRadius:T.rMd, padding:3, marginBottom:24 }}>
      {tabs.map(t => (
        <button key={t.key} onClick={() => onChange(t.key)} style={{
          flex:1, fontFamily:T.mono, fontSize:"0.72rem", fontWeight: active===t.key ? 600 : 400,
          padding:"10px 12px", borderRadius:T.rSm, border:"none", cursor:"pointer",
          background: active===t.key ? T.bg4 : "transparent",
          color: active===t.key ? T.text0 : T.text3,
          transition:"all 0.2s ease",
          borderBottom: active===t.key ? `2px solid ${t.color || T.teal}` : "2px solid transparent",
        }}>{t.label}</button>
      ))}
    </div>
  );
}

function TechCard({ tech, expanded, onToggle }) {
  const fc = familyColor(tech.family);
  const roleColors = { transform:T.green, feature:T.blue, model:T.orange, calibration:T.purple, decision:T.red };
  const riskColors = { low:T.green, medium:T.yellow, high:T.crimson };
  return (
    <div style={{ background:T.bg2, border:`1px solid ${T.border0}`, borderRadius:T.rMd, overflow:"hidden" }}>
      <div style={{ height:2, background:fc }} />
      <div onClick={onToggle} style={{ padding:"12px 14px", cursor:"pointer" }}>
        <div style={{ display:"flex", alignItems:"center", gap:8, marginBottom:4 }}>
          <StatusDot color={fc} size={7} />
          <span style={{ fontFamily:T.display, fontWeight:700, fontSize:"0.88rem", color:T.text0, flex:1 }}>{tech.name}</span>
          <span style={{ fontFamily:T.mono, fontSize:"0.58rem", padding:"0.15em 0.5em", borderRadius:T.rSm,
            background:`${fc}22`, color:fc, border:`1px solid ${fc}33` }}>{familyName(tech.family)}</span>
          <span style={{ fontFamily:T.mono, fontSize:"0.6rem", color:T.text3, transform:expanded?"rotate(90deg)":"rotate(0)",transition:"transform 0.2s" }}>â–¸</span>
        </div>
        <div style={{ fontFamily:T.body, fontSize:"0.75rem", color:T.text2, marginLeft:15 }}>{tech.desc}</div>
        <div style={{ display:"flex", gap:4, marginTop:8, marginLeft:15, flexWrap:"wrap" }}>
          <span style={{ fontFamily:T.mono, fontSize:"0.55rem", padding:"0.12em 0.4em", borderRadius:T.rSm,
            background:(roleColors[tech.pipelineRole]||T.text3)+"22", color:roleColors[tech.pipelineRole]||T.text3 }}>{tech.pipelineRole}</span>
          <span style={{ fontFamily:T.mono, fontSize:"0.55rem", padding:"0.12em 0.4em", borderRadius:T.rSm,
            background:(riskColors[tech.leakageRisk]||T.text3)+"22", color:riskColors[tech.leakageRisk]||T.text3 }}>leak: {tech.leakageRisk}</span>
          {Array.from({length:5}).map((_,i) => (
            <span key={i} style={{ width:6, height:6, borderRadius:"50%", background: i < tech.complexity ? fc : T.bg4, marginTop:3 }} />
          ))}
        </div>
      </div>
      <div style={{ maxHeight:expanded?2000:0, overflow:"hidden", transition:"max-height 0.4s ease" }}>
        <div style={{ padding:"0 14px 14px", borderTop:`1px solid ${T.border0}` }}>
          <div style={{ display:"grid", gridTemplateColumns:"1fr 1fr", gap:10, marginTop:10 }}>
            <div>
              <div style={{ fontFamily:T.mono, fontSize:"0.55rem", color:T.text3, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:4 }}>Inputs</div>
              <div style={{ display:"flex", gap:3, flexWrap:"wrap" }}>{tech.inputTypes.map(t => <Chip key={t} style={{ fontSize:"0.6rem" }}>{t}</Chip>)}</div>
            </div>
            <div>
              <div style={{ fontFamily:T.mono, fontSize:"0.55rem", color:T.text3, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:4 }}>Outputs</div>
              <div style={{ display:"flex", gap:3, flexWrap:"wrap" }}>{tech.outputTypes.map(t => <Chip key={t} style={{ fontSize:"0.6rem" }}>{t}</Chip>)}</div>
            </div>
            <div>
              <div style={{ fontFamily:T.mono, fontSize:"0.55rem", color:T.text3, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:4 }}>Assumptions</div>
              <div style={{ display:"flex", gap:3, flexWrap:"wrap" }}>
                {tech.assumptions.length ? tech.assumptions.map(a => <Chip key={a} style={{ fontSize:"0.6rem" }}>{a.replace(/_/g," ")}</Chip>) : <span style={{fontFamily:T.mono,fontSize:"0.6rem",color:T.text3}}>none</span>}
              </div>
            </div>
            <div>
              <div style={{ fontFamily:T.mono, fontSize:"0.55rem", color:T.text3, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:4 }}>Owns</div>
              <div style={{ display:"flex", gap:3, flexWrap:"wrap" }}>
                {tech.ownedResponsibilities.length ? tech.ownedResponsibilities.map(r => <Chip key={r} style={{ fontSize:"0.6rem", background:T.purpleDim, color:T.purple, border:`1px solid ${T.purple}33` }}>{r.replace(/_/g," ")}</Chip>) : <span style={{fontFamily:T.mono,fontSize:"0.6rem",color:T.text3}}>none</span>}
              </div>
            </div>
            <div>
              <div style={{ fontFamily:T.mono, fontSize:"0.55rem", color:T.text3, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:4 }}>Time Scales</div>
              <div style={{ display:"flex", gap:3, flexWrap:"wrap" }}>{tech.timeScales.map(s => <Chip key={s} style={{ fontSize:"0.6rem" }}>{s}</Chip>)}</div>
            </div>
            <div>
              <div style={{ fontFamily:T.mono, fontSize:"0.55rem", color:T.text3, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:4 }}>Best For</div>
              <div style={{ display:"flex", gap:3, flexWrap:"wrap" }}>{tech.bestFor.map(b => <Chip key={b} style={{ fontSize:"0.6rem", background:T.greenDim, color:T.green, border:`1px solid ${T.green}33` }}>{b}</Chip>)}</div>
            </div>
          </div>
          {/* â”€â”€â”€ TECHNIQUE_DETAILS enrichment â”€â”€â”€ */}
          {(() => {
            const d = TECHNIQUE_DETAILS[tech.id];
            if (!d) return null;
            const techName = id => (TECHNIQUES.find(t => t.id === id) || {}).name || id;
            const techColor = id => familyColor((TECHNIQUES.find(t => t.id === id) || {}).family);
            const opName = id => (OPERATORS.find(o => o.id === id) || {}).id || id;
            return (
              <div style={{ marginTop:12, paddingTop:10, borderTop:`1px dashed ${T.border0}` }}>
                {/* Strengths */}
                <div style={{ marginBottom:10 }}>
                  <div style={{ fontFamily:T.mono, fontSize:"0.55rem", color:T.green, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:5 }}>Strengths</div>
                  {d.strengths.map((s,i) => (
                    <div key={i} style={{ display:"flex", gap:6, alignItems:"flex-start", padding:"2px 0" }}>
                      <StatusDot color={T.green} size={5} />
                      <span style={{ fontFamily:T.mono, fontSize:"0.65rem", color:T.text1 }}>{s}</span>
                    </div>
                  ))}
                </div>
                {/* Weaknesses */}
                <div style={{ marginBottom:10 }}>
                  <div style={{ fontFamily:T.mono, fontSize:"0.55rem", color:T.crimson, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:5 }}>Weaknesses</div>
                  {d.weaknesses.map((w,i) => (
                    <div key={i} style={{ display:"flex", gap:6, alignItems:"flex-start", padding:"2px 0" }}>
                      <StatusDot color={T.crimson} size={5} />
                      <span style={{ fontFamily:T.mono, fontSize:"0.65rem", color:T.text1 }}>{w}</span>
                    </div>
                  ))}
                </div>
                {/* Connections row */}
                <div style={{ display:"grid", gridTemplateColumns:"1fr 1fr 1fr", gap:10 }}>
                  {/* Synergies */}
                  <div>
                    <div style={{ fontFamily:T.mono, fontSize:"0.55rem", color:T.teal, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:5 }}>Synergies With</div>
                    <div style={{ display:"flex", gap:3, flexWrap:"wrap" }}>
                      {d.synergiesWith.length ? d.synergiesWith.map(id => (
                        <span key={id} style={{ fontFamily:T.mono, fontSize:"0.6rem", padding:"0.12em 0.4em", borderRadius:T.rSm,
                          background:`${techColor(id)}15`, color:techColor(id), border:`1px solid ${techColor(id)}33`, cursor:"default" }}>
                          {techName(id)}
                        </span>
                      )) : <span style={{fontFamily:T.mono,fontSize:"0.6rem",color:T.text3}}>none</span>}
                    </div>
                  </div>
                  {/* Conflicts */}
                  <div>
                    <div style={{ fontFamily:T.mono, fontSize:"0.55rem", color:T.crimson, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:5 }}>Conflicts With</div>
                    <div style={{ display:"flex", gap:3, flexWrap:"wrap" }}>
                      {d.conflictsWith.length ? d.conflictsWith.map(id => (
                        <span key={id} style={{ fontFamily:T.mono, fontSize:"0.6rem", padding:"0.12em 0.4em", borderRadius:T.rSm,
                          background:T.crimsonDim, color:T.crimson, border:`1px solid ${T.crimson}33`, cursor:"default" }}>
                          {techName(id)}
                        </span>
                      )) : <span style={{fontFamily:T.mono,fontSize:"0.6rem",color:T.text3}}>none</span>}
                    </div>
                  </div>
                  {/* Related */}
                  <div>
                    <div style={{ fontFamily:T.mono, fontSize:"0.55rem", color:T.text3, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:5 }}>Related To</div>
                    <div style={{ display:"flex", gap:3, flexWrap:"wrap" }}>
                      {d.relatedTo.map(id => (
                        <span key={id} style={{ fontFamily:T.mono, fontSize:"0.6rem", padding:"0.12em 0.4em", borderRadius:T.rSm,
                          background:T.bg4, color:T.text2, border:`1px solid ${T.border1}`, cursor:"default" }}>
                          {techName(id)}
                        </span>
                      ))}
                    </div>
                  </div>
                </div>
                {/* Relevant CLR Operators */}
                {d.relevantOps.length > 0 && (
                  <div style={{ marginTop:10 }}>
                    <div style={{ fontFamily:T.mono, fontSize:"0.55rem", color:T.orange, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:5 }}>CLR Operators</div>
                    <div style={{ display:"flex", gap:3, flexWrap:"wrap" }}>
                      {d.relevantOps.map(opId => {
                        const op = OPERATORS.find(o => o.id === opId);
                        const cc = op ? (OP_CATEGORIES.find(c => c.id === op.category) || {}).color || T.text3 : T.text3;
                        return (
                          <span key={opId} title={op ? op.description : opId} style={{ fontFamily:T.mono, fontSize:"0.6rem", padding:"0.12em 0.5em", borderRadius:T.rSm,
                            background:`${cc}15`, color:cc, border:`1px solid ${cc}33`, cursor:"help" }}>
                            {opId}
                          </span>
                        );
                      })}
                    </div>
                  </div>
                )}
                {/* Canonical pipelines this technique appears in */}
                {(() => {
                  const pipes = CANONICAL_PIPELINES.filter(p => p.steps.includes(tech.id));
                  if (pipes.length === 0) return null;
                  return (
                    <div style={{ marginTop:10 }}>
                      <div style={{ fontFamily:T.mono, fontSize:"0.55rem", color:T.blue, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:5 }}>Appears in Pipelines</div>
                      <div style={{ display:"flex", gap:4, flexWrap:"wrap" }}>
                        {pipes.map(p => (
                          <span key={p.id} title={p.description} style={{ fontFamily:T.mono, fontSize:"0.6rem", padding:"0.12em 0.5em", borderRadius:T.rSm,
                            background:T.blueDim, color:T.blue, border:`1px solid ${T.blue}33`, cursor:"help" }}>
                            {p.name}
                          </span>
                        ))}
                      </div>
                    </div>
                  );
                })()}
                {/* Hilbert Space Interpretation */}
                {(() => {
                  const hm = HILBERT_MAPPING[tech.id];
                  if (!hm) return null;
                  const hc = HILBERT_CONCEPTS.find(c => c.id === hm.concept);
                  if (!hc) return null;
                  return (
                    <div style={{ marginTop:10, padding:"8px 10px", background:`${hc.color}08`, borderRadius:T.rSm, border:`1px solid ${hc.color}20` }}>
                      <div style={{ display:"flex", alignItems:"center", gap:6, marginBottom:4 }}>
                        <span style={{ fontFamily:T.mono, fontSize:"0.55rem", color:hc.color, textTransform:"uppercase", letterSpacing:"0.1em" }}>Hilbert</span>
                        <span style={{ fontFamily:T.mono, fontSize:"0.6rem", padding:"0.1em 0.4em", borderRadius:T.rSm,
                          background:`${hc.color}18`, color:hc.color, border:`1px solid ${hc.color}33` }}>{hc.symbol}</span>
                        <span style={{ fontFamily:T.mono, fontSize:"0.58rem", color:hc.color }}>{hc.name}</span>
                      </div>
                      <div style={{ fontFamily:T.mono, fontSize:"0.62rem", color:T.text2, fontStyle:"italic" }}>{hm.interpretation}</div>
                    </div>
                  );
                })()}
              </div>
            );
          })()}
        </div>
      </div>
    </div>
  );
}

function PrincipleCard({ p, expanded, onToggle }) {
  const catColors = { structural:T.blue, causal:T.orange, statistical:T.purple, evaluation:T.crimson, design:T.green };
  const cc = catColors[p.category] || T.teal;
  return (
    <div style={{ background:T.bg2, border:`1px solid ${T.border0}`, borderRadius:T.rMd, overflow:"hidden" }}>
      <div style={{ height:2, background:cc }} />
      <div onClick={onToggle} style={{ padding:"12px 14px", cursor:"pointer" }}>
        <div style={{ display:"flex", alignItems:"center", gap:8 }}>
          <Badge color={cc}>{p.id}</Badge>
          <span style={{ fontFamily:T.display, fontWeight:700, fontSize:"0.88rem", color:T.text0, flex:1 }}>{p.name}</span>
          <span style={{ fontFamily:T.mono, fontSize:"0.55rem", padding:"0.15em 0.5em", borderRadius:T.rSm,
            background:`${cc}22`, color:cc }}>{p.category}</span>
          <span style={{ fontFamily:T.mono, fontSize:"0.6rem", color:T.text3, transform:expanded?"rotate(90deg)":"rotate(0)",transition:"transform 0.2s" }}>â–¸</span>
        </div>
        <div style={{ fontFamily:T.body, fontSize:"0.75rem", color:T.text2, marginTop:6, marginLeft:28 }}>{p.description}</div>
      </div>
      <div style={{ maxHeight:expanded?500:0, overflow:"hidden", transition:"max-height 0.3s ease" }}>
        <div style={{ padding:"0 14px 14px", borderTop:`1px solid ${T.border0}` }}>
          <div style={{ fontFamily:T.mono, fontSize:"0.68rem", color:T.text0, padding:"10px 0 8px", borderBottom:`1px dashed ${T.border0}` }}>
            <span style={{ color:T.text3 }}>Rule: </span>{p.rule}
          </div>
          <div style={{ display:"grid", gridTemplateColumns:"1fr 1fr", gap:12, marginTop:10 }}>
            <div>
              <div style={{ fontFamily:T.mono, fontSize:"0.55rem", color:T.green, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:6 }}>Safe Examples</div>
              {p.safeExamples.map((e,i) => (
                <div key={i} style={{ fontFamily:T.mono, fontSize:"0.65rem", color:T.text1, padding:"4px 0", display:"flex", gap:6, alignItems:"flex-start" }}>
                  <StatusDot color={T.green} size={5} /><span>{e}</span>
                </div>
              ))}
            </div>
            <div>
              <div style={{ fontFamily:T.mono, fontSize:"0.55rem", color:T.crimson, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:6 }}>Unsafe Examples</div>
              {p.unsafeExamples.map((e,i) => (
                <div key={i} style={{ fontFamily:T.mono, fontSize:"0.65rem", color:T.text1, padding:"4px 0", display:"flex", gap:6, alignItems:"flex-start" }}>
                  <StatusDot color={T.crimson} size={5} /><span>{e}</span>
                </div>
              ))}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TAB 1: TECHNIQUES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function TechniquesTab() {
  const [search, setSearch] = useState("");
  const [familyFilter, setFamilyFilter] = useState("all");
  const [expanded, setExpanded] = useState(new Set());

  const filtered = useMemo(() => {
    return TECHNIQUES.filter(t => {
      if (familyFilter !== "all" && t.family !== familyFilter) return false;
      if (search && !t.name.toLowerCase().includes(search.toLowerCase()) && !t.desc.toLowerCase().includes(search.toLowerCase())) return false;
      return true;
    });
  }, [search, familyFilter]);

  const toggle = useCallback(id => setExpanded(p => { const n = new Set(p); n.has(id)?n.delete(id):n.add(id); return n; }), []);

  return (
    <div>
      <div style={{ display:"flex", gap:10, marginBottom:16, alignItems:"center", flexWrap:"wrap" }}>
        <input value={search} onChange={e => setSearch(e.target.value)} placeholder="Search techniques..."
          style={{ fontFamily:T.mono, fontSize:"0.72rem", padding:"8px 12px", borderRadius:T.rMd,
            border:`1px solid ${T.border1}`, background:T.bg2, color:T.text0, outline:"none", flex:"1 1 200px", minWidth:150 }} />
        <Segmented
          options={[{key:"all",label:"All"},...FAMILIES.map(f=>({key:f.id,label:f.name}))]}
          active={familyFilter} onChange={setFamilyFilter} />
      </div>
      <div style={{ fontFamily:T.mono, fontSize:"0.62rem", color:T.text3, marginBottom:12 }}>
        {filtered.length} technique{filtered.length!==1?"s":""} Â· {new Set(filtered.map(t=>t.family)).size} families
      </div>
      <div style={{ display:"grid", gridTemplateColumns:"repeat(auto-fill, minmax(380px, 1fr))", gap:8 }}>
        {filtered.map(t => <TechCard key={t.id} tech={t} expanded={expanded.has(t.id)} onToggle={() => toggle(t.id)} />)}
      </div>
    </div>
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TAB 2: PIPELINE COMPOSER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function ComposerTab() {
  const [pipeline, setPipeline] = useState([]);
  const [familyFilter, setFamilyFilter] = useState("all");

  const addTech = useCallback(id => {
    setPipeline(p => [...p, id]);
  }, []);
  const removeTech = useCallback(idx => {
    setPipeline(p => p.filter((_,i) => i !== idx));
  }, []);
  const clearPipeline = useCallback(() => setPipeline([]), []);

  const pairChecks = useMemo(() => {
    const results = [];
    for (let i = 0; i < pipeline.length - 1; i++) {
      const a = TECHNIQUES.find(t => t.id === pipeline[i]);
      const b = TECHNIQUES.find(t => t.id === pipeline[i+1]);
      if (a && b) results.push({ from:a, to:b, ...checkComposition(a, b) });
    }
    return results;
  }, [pipeline]);

  const overallScore = pairChecks.length > 0
    ? pairChecks.reduce((s,c) => s + c.score, 0) / pairChecks.length : 0;
  const scoreColor = overallScore > 0.8 ? T.green : overallScore > 0.5 ? T.yellow : T.crimson;

  const palette = useMemo(() => {
    if (familyFilter === "all") return TECHNIQUES;
    return TECHNIQUES.filter(t => t.family === familyFilter);
  }, [familyFilter]);

  return (
    <div>
      {/* Pipeline display */}
      <Section title="Pipeline" count={pipeline.length} color={scoreColor}>
        {pipeline.length === 0 ? (
          <div style={{ fontFamily:T.mono, fontSize:"0.72rem", color:T.text3, padding:"20px 0", textAlign:"center" }}>
            Click techniques below to build a pipeline
          </div>
        ) : (
          <div>
            <div style={{ display:"flex", alignItems:"center", gap:0, overflowX:"auto", padding:"8px 0" }}>
              {pipeline.map((id, idx) => {
                const tech = TECHNIQUES.find(t => t.id === id);
                if (!tech) return null;
                const fc = familyColor(tech.family);
                return (
                  <React.Fragment key={idx}>
                    <div style={{ display:"flex", flexDirection:"column", alignItems:"center", minWidth:100, position:"relative" }}>
                      <div style={{
                        background:T.bg3, border:`1px solid ${fc}55`, borderRadius:T.rMd, padding:"8px 12px",
                        textAlign:"center", minWidth:90, position:"relative",
                      }}>
                        <button onClick={() => removeTech(idx)} style={{
                          position:"absolute", top:-6, right:-6, width:16, height:16, borderRadius:"50%",
                          background:T.crimson, color:"#fff", border:"none", cursor:"pointer",
                          fontFamily:T.mono, fontSize:"0.5rem", display:"flex", alignItems:"center", justifyContent:"center",
                        }}>x</button>
                        <div style={{ width:6, height:6, borderRadius:"50%", background:fc, margin:"0 auto 4px" }} />
                        <div style={{ fontFamily:T.mono, fontSize:"0.68rem", color:T.text0, fontWeight:600 }}>{tech.name}</div>
                        <div style={{ fontFamily:T.mono, fontSize:"0.52rem", color:T.text3 }}>{tech.pipelineRole}</div>
                      </div>
                    </div>
                    {idx < pipeline.length - 1 && (
                      <div style={{ display:"flex", flexDirection:"column", alignItems:"center", minWidth:30 }}>
                        {pairChecks[idx] && (
                          <React.Fragment>
                            <div style={{ fontFamily:T.mono, fontSize:"0.52rem", color: pairChecks[idx].score>0.8?T.green:pairChecks[idx].score>0.5?T.yellow:T.crimson, marginBottom:2 }}>
                              {(pairChecks[idx].score*100).toFixed(0)}%
                            </div>
                            <div style={{ width:20, height:2, background: pairChecks[idx].score>0.8?T.green:pairChecks[idx].score>0.5?T.yellow:T.crimson }} />
                            <span style={{ fontFamily:T.mono, fontSize:"0.7rem", color: pairChecks[idx].score>0.8?T.green:pairChecks[idx].score>0.5?T.yellow:T.crimson }}>â†’</span>
                          </React.Fragment>
                        )}
                      </div>
                    )}
                  </React.Fragment>
                );
              })}
            </div>
            {pipeline.length >= 2 && (
              <div style={{ display:"flex", alignItems:"center", gap:10, marginTop:12, paddingTop:10, borderTop:`1px solid ${T.border0}` }}>
                <span style={{ fontFamily:T.mono, fontSize:"0.62rem", color:T.text3 }}>Overall Score</span>
                <div style={{ flex:1 }}><ProgressBar value={overallScore} color={scoreColor} thick /></div>
                <span style={{ fontFamily:T.display, fontWeight:700, fontSize:"1.1rem", color:scoreColor }}>{(overallScore*100).toFixed(0)}%</span>
              </div>
            )}
            <div style={{ textAlign:"right", marginTop:8 }}>
              <button onClick={clearPipeline} style={{ fontFamily:T.mono, fontSize:"0.62rem", padding:"4px 10px",
                borderRadius:T.rSm, border:`1px solid ${T.border1}`, background:T.bg3, color:T.text2, cursor:"pointer" }}>Clear</button>
            </div>
          </div>
        )}
      </Section>

      {/* Pair checks detail */}
      {pairChecks.length > 0 && (
        <Section title="Composition Checks" count={pairChecks.reduce((s,p) => s + p.checks.filter(c=>!c.pass).length, 0)} color={T.orange} style={{ marginTop:12 }}>
          {pairChecks.map((pair, idx) => (
            <div key={idx} style={{ marginBottom:12, paddingBottom:12, borderBottom: idx < pairChecks.length-1 ? `1px solid ${T.border0}` : "none" }}>
              <div style={{ fontFamily:T.mono, fontSize:"0.72rem", color:T.text0, marginBottom:8 }}>
                <span style={{ color:familyColor(pair.from.family) }}>{pair.from.name}</span>
                <span style={{ color:T.text3 }}> â†’ </span>
                <span style={{ color:familyColor(pair.to.family) }}>{pair.to.name}</span>
                <span style={{ marginLeft:8, color: pair.score>0.8?T.green:pair.score>0.5?T.yellow:T.crimson }}>
                  ({(pair.score*100).toFixed(0)}%)
                </span>
              </div>
              <div style={{ display:"grid", gridTemplateColumns:"repeat(auto-fill, minmax(280px, 1fr))", gap:6 }}>
                {pair.checks.map((c, ci) => (
                  <div key={ci} style={{ display:"flex", alignItems:"flex-start", gap:6, padding:"4px 8px",
                    borderRadius:T.rSm, background: c.severity==="ok"?T.greenDim:c.severity==="warn"?T.yellowDim:T.crimsonDim }}>
                    <StatusDot color={c.severity==="ok"?T.green:c.severity==="warn"?T.yellow:T.crimson} size={6} />
                    <div>
                      <div style={{ fontFamily:T.mono, fontSize:"0.62rem", fontWeight:600, color:T.text0 }}>{c.name}</div>
                      <div style={{ fontFamily:T.mono, fontSize:"0.58rem", color:T.text2 }}>{c.detail}</div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          ))}
        </Section>
      )}

      {/* Canonical Pipelines */}
      <Section title="Canonical Pipelines" count={CANONICAL_PIPELINES.length} color={T.blue} style={{ marginTop:12 }}>
        <div style={{ fontFamily:T.mono, fontSize:"0.62rem", color:T.text3, marginBottom:10 }}>
          Click a pipeline to load it into the composer
        </div>
        <div style={{ display:"grid", gridTemplateColumns:"repeat(auto-fill, minmax(320px, 1fr))", gap:8 }}>
          {CANONICAL_PIPELINES.map(cp => (
            <button key={cp.id} onClick={() => setPipeline(cp.steps)} style={{
              background:T.bg2, border:`1px solid ${T.border0}`, borderRadius:T.rMd, padding:"10px 12px",
              cursor:"pointer", textAlign:"left", borderLeft:`3px solid ${T.blue}`, display:"block", width:"100%",
            }}>
              <div style={{ display:"flex", alignItems:"center", gap:6, marginBottom:4 }}>
                <span style={{ fontFamily:T.display, fontWeight:700, fontSize:"0.78rem", color:T.text0, flex:1 }}>{cp.name}</span>
                <span style={{ fontFamily:T.mono, fontSize:"0.52rem", padding:"0.12em 0.4em", borderRadius:T.rSm,
                  background:T.bg4, color:T.text3 }}>complexity {cp.complexity}</span>
              </div>
              <div style={{ fontFamily:T.body, fontSize:"0.68rem", color:T.text2, marginBottom:6 }}>{cp.description}</div>
              <div style={{ display:"flex", gap:3, alignItems:"center", flexWrap:"wrap", marginBottom:4 }}>
                {cp.steps.map((sid, i) => {
                  const t = TECHNIQUES.find(x => x.id === sid);
                  const fc = t ? familyColor(t.family) : T.text3;
                  return (
                    <React.Fragment key={sid}>
                      {i > 0 && <span style={{ fontFamily:T.mono, fontSize:"0.6rem", color:T.text3 }}>â†’</span>}
                      <span style={{ fontFamily:T.mono, fontSize:"0.58rem", padding:"0.1em 0.4em", borderRadius:T.rSm,
                        background:`${fc}18`, color:fc, border:`1px solid ${fc}33` }}>
                        {t ? t.name : sid}
                      </span>
                    </React.Fragment>
                  );
                })}
              </div>
              <div style={{ fontFamily:T.mono, fontSize:"0.55rem", color:T.text3 }}>
                <span style={{ color:T.teal }}>{cp.archetype}</span> Â· {cp.useCase}
              </div>
            </button>
          ))}
        </div>
      </Section>

      {/* Technique palette */}
      <div style={{ marginTop:12 }}>
        <div style={{ display:"flex", gap:8, alignItems:"center", marginBottom:10, flexWrap:"wrap" }}>
          <span style={{ fontFamily:T.display, fontWeight:700, fontSize:"0.88rem", color:T.text0 }}>Add Technique</span>
          <Segmented options={[{key:"all",label:"All"},...FAMILIES.map(f=>({key:f.id,label:f.name}))]}
            active={familyFilter} onChange={setFamilyFilter} />
        </div>
        <div style={{ display:"grid", gridTemplateColumns:"repeat(auto-fill, minmax(180px, 1fr))", gap:6 }}>
          {palette.map(t => {
            const fc = familyColor(t.family);
            return (
              <button key={t.id} onClick={() => addTech(t.id)} style={{
                background:T.bg2, border:`1px solid ${T.border0}`, borderRadius:T.rSm,
                padding:"8px 10px", cursor:"pointer", textAlign:"left", borderTop:`2px solid ${fc}`,
              }}>
                <div style={{ fontFamily:T.mono, fontSize:"0.68rem", color:T.text0, fontWeight:500 }}>{t.name}</div>
                <div style={{ fontFamily:T.mono, fontSize:"0.52rem", color:T.text3, marginTop:2 }}>{t.pipelineRole} Â· {t.family}</div>
              </button>
            );
          })}
        </div>
      </div>
    </div>
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TAB 3: COMPATIBILITY MATRIX
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function MatrixTab() {
  const [hover, setHover] = useState(null);
  const [familyFilter, setFamilyFilter] = useState("all");

  const techs = useMemo(() => {
    if (familyFilter === "all") return TECHNIQUES;
    return TECHNIQUES.filter(t => t.family === familyFilter);
  }, [familyFilter]);

  const matrix = useMemo(() => {
    const m = {};
    for (const a of techs) {
      for (const b of techs) {
        if (a.id === b.id) { m[`${a.id}|${b.id}`] = { score:1, checks:[] }; continue; }
        m[`${a.id}|${b.id}`] = checkComposition(a, b);
      }
    }
    return m;
  }, [techs]);

  const cellSize = Math.max(14, Math.min(24, Math.floor(700 / techs.length)));
  const labelW = 110;
  const w = labelW + techs.length * cellSize + 10;
  const h = labelW + techs.length * cellSize + 10;

  const hoverData = hover ? matrix[`${hover.a}|${hover.b}`] : null;
  const hoverA = hover ? TECHNIQUES.find(t=>t.id===hover.a) : null;
  const hoverB = hover ? TECHNIQUES.find(t=>t.id===hover.b) : null;

  return (
    <div>
      <div style={{ display:"flex", gap:10, marginBottom:16, alignItems:"center", flexWrap:"wrap" }}>
        <Segmented options={[{key:"all",label:"All (35)"},...FAMILIES.map(f=>({key:f.id,label:f.name}))]}
          active={familyFilter} onChange={setFamilyFilter} />
        <span style={{ fontFamily:T.mono, fontSize:"0.62rem", color:T.text3 }}>
          {techs.length}Ã—{techs.length} = {techs.length*techs.length} cells Â· Hover for details
        </span>
      </div>

      <div style={{ display:"flex", gap:16, alignItems:"flex-start", flexWrap:"wrap" }}>
        <div style={{ overflowX:"auto", flex:"1 1 auto" }}>
          <svg viewBox={`0 0 ${w} ${h}`} style={{ width:Math.min(w, 900), height:Math.min(h, 900), display:"block" }}>
            {/* Column labels */}
            {techs.map((t, i) => (
              <text key={`cl-${t.id}`} x={labelW + i*cellSize + cellSize/2} y={labelW - 4}
                textAnchor="end" fill={familyColor(t.family)} fontSize={Math.min(7, cellSize*0.4)} fontFamily={T.mono}
                transform={`rotate(-65, ${labelW + i*cellSize + cellSize/2}, ${labelW - 4})`}>{t.name}</text>
            ))}
            {/* Row labels */}
            {techs.map((t, i) => (
              <text key={`rl-${t.id}`} x={labelW - 4} y={labelW + i*cellSize + cellSize/2 + 3}
                textAnchor="end" fill={familyColor(t.family)} fontSize={Math.min(7, cellSize*0.4)} fontFamily={T.mono}>{t.name}</text>
            ))}
            {/* Cells */}
            {techs.map((a, ai) => techs.map((b, bi) => {
              const key = `${a.id}|${b.id}`;
              const d = matrix[key];
              const s = d ? d.score : 0;
              const fill = a.id === b.id ? T.bg3 : s > 0.8 ? T.green : s > 0.6 ? `${T.green}88` : s > 0.4 ? T.yellow : s > 0.2 ? T.orange : T.crimson;
              const opacity = a.id === b.id ? 0.3 : 0.25 + s * 0.55;
              return (
                <rect key={key} x={labelW + bi*cellSize} y={labelW + ai*cellSize}
                  width={cellSize-1} height={cellSize-1} rx={1}
                  fill={fill} opacity={opacity}
                  stroke={hover && hover.a===a.id && hover.b===b.id ? T.text0 : "none"} strokeWidth={1.5}
                  onMouseEnter={() => setHover({a:a.id, b:b.id})}
                  onMouseLeave={() => setHover(null)}
                  style={{ cursor:"pointer" }} />
              );
            }))}
          </svg>
        </div>

        {/* Hover detail panel */}
        <div style={{ minWidth:280, maxWidth:320, flex:"0 0 auto" }}>
          {hoverData && hoverA && hoverB ? (
            <Section title={`${hoverA.name} â†’ ${hoverB.name}`} color={hoverData.score>0.8?T.green:hoverData.score>0.5?T.yellow:T.crimson}>
              <div style={{ display:"flex", alignItems:"center", gap:8, marginBottom:10 }}>
                <span style={{ fontFamily:T.mono, fontSize:"0.62rem", color:T.text3 }}>Score</span>
                <div style={{ flex:1 }}><ProgressBar value={hoverData.score} color={hoverData.score>0.8?T.green:hoverData.score>0.5?T.yellow:T.crimson} thick /></div>
                <span style={{ fontFamily:T.display, fontWeight:700, fontSize:"1rem", color:hoverData.score>0.8?T.green:hoverData.score>0.5?T.yellow:T.crimson }}>
                  {(hoverData.score*100).toFixed(0)}%
                </span>
              </div>
              {hoverData.checks.map((c,i) => (
                <div key={i} style={{ display:"flex", alignItems:"flex-start", gap:6, padding:"5px 0",
                  borderBottom: i < hoverData.checks.length-1 ? `1px solid ${T.border0}` : "none" }}>
                  <StatusDot color={c.severity==="ok"?T.green:c.severity==="warn"?T.yellow:T.crimson} size={6} />
                  <div>
                    <div style={{ fontFamily:T.mono, fontSize:"0.62rem", fontWeight:600, color:T.text0 }}>{c.name}</div>
                    <div style={{ fontFamily:T.mono, fontSize:"0.55rem", color:T.text2 }}>{c.detail}</div>
                  </div>
                </div>
              ))}
            </Section>
          ) : (
            <div style={{ background:T.bg1, border:`1px solid ${T.border0}`, borderRadius:T.rMd, padding:20, textAlign:"center" }}>
              <div style={{ fontFamily:T.mono, fontSize:"0.72rem", color:T.text3 }}>Hover a cell to see<br/>compatibility details</div>
            </div>
          )}

          {/* Legend */}
          <div style={{ marginTop:12, background:T.bg1, border:`1px solid ${T.border0}`, borderRadius:T.rMd, padding:12 }}>
            <div style={{ fontFamily:T.mono, fontSize:"0.55rem", color:T.text3, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:8 }}>Legend</div>
            {[{label:"> 80% Compatible",color:T.green},{label:"60-80%",color:`${T.green}88`},{label:"40-60%",color:T.yellow},{label:"20-40%",color:T.orange},{label:"< 20%",color:T.crimson}].map(l => (
              <div key={l.label} style={{ display:"flex", alignItems:"center", gap:8, padding:"2px 0" }}>
                <div style={{ width:14, height:14, borderRadius:2, background:l.color, opacity:0.7 }} />
                <span style={{ fontFamily:T.mono, fontSize:"0.6rem", color:T.text2 }}>{l.label}</span>
              </div>
            ))}
          </div>
        </div>
      </div>
    </div>
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TAB 4: PRINCIPLES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function PrinciplesTab() {
  const [expanded, setExpanded] = useState(new Set([1]));
  const [catFilter, setCatFilter] = useState("all");
  const toggle = useCallback(id => setExpanded(p => { const n = new Set(p); n.has(id)?n.delete(id):n.add(id); return n; }), []);
  const cats = [...new Set(PRINCIPLES.map(p => p.category))];

  const filtered = catFilter === "all" ? PRINCIPLES : PRINCIPLES.filter(p => p.category === catFilter);

  return (
    <div>
      <div style={{ display:"flex", gap:10, marginBottom:16, alignItems:"center", flexWrap:"wrap" }}>
        <Segmented options={[{key:"all",label:"All (12)"},...cats.map(c => ({key:c,label:c}))]}
          active={catFilter} onChange={setCatFilter} />
        <button onClick={() => setExpanded(new Set(filtered.map(p=>p.id)))} style={{
          fontFamily:T.mono, fontSize:"0.62rem", padding:"4px 10px", borderRadius:T.rSm,
          border:`1px solid ${T.border1}`, background:T.bg3, color:T.text2, cursor:"pointer" }}>Expand All</button>
        <button onClick={() => setExpanded(new Set())} style={{
          fontFamily:T.mono, fontSize:"0.62rem", padding:"4px 10px", borderRadius:T.rSm,
          border:`1px solid ${T.border1}`, background:T.bg3, color:T.text2, cursor:"pointer" }}>Collapse All</button>
      </div>
      <div style={{ display:"flex", flexDirection:"column", gap:8 }}>
        {filtered.map(p => <PrincipleCard key={p.id} p={p} expanded={expanded.has(p.id)} onToggle={() => toggle(p.id)} />)}
      </div>
    </div>
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TAB 5: CONDENSED LOGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function CondensedLogsTab() {
  const [opCat, setOpCat] = useState("all");
  const [expandedArch, setExpandedArch] = useState(new Set());
  const toggleArch = useCallback(id => setExpandedArch(p => { const n = new Set(p); n.has(id)?n.delete(id):n.add(id); return n; }), []);

  const filteredOps = opCat === "all" ? OPERATORS : OPERATORS.filter(o => o.category === opCat);

  const thS = { fontFamily:T.mono, fontSize:"0.58rem", textTransform:"uppercase", letterSpacing:"0.12em", color:T.text3, padding:"8px 10px", textAlign:"left", fontWeight:500, borderBottom:`1px solid ${T.border0}` };
  const tdS = { padding:"6px 10px", borderBottom:`1px solid ${T.border0}`, fontFamily:T.mono, fontSize:"0.72rem", color:T.text1 };

  return (
    <div>
      {/* CLR Schema */}
      <Section title="Condensed Log Record (CLR) Schema" count={CLR_SCHEMA.length} color={T.purple}>
        <div style={{ overflowX:"auto" }}>
          <table style={{ width:"100%", borderCollapse:"collapse" }}>
            <thead style={{ background:T.bg3 }}>
              <tr>
                <th style={thS}>Field</th>
                <th style={thS}>Type</th>
                <th style={thS}>Description</th>
              </tr>
            </thead>
            <tbody>
              {CLR_SCHEMA.map(f => (
                <tr key={f.name}>
                  <td style={{ ...tdS, color:T.blue, fontWeight:600 }}>{f.name}</td>
                  <td style={{ ...tdS, color:T.purple }}>{f.type}</td>
                  <td style={{ ...tdS, color:T.text2 }}>{f.desc}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </Section>

      {/* Operators */}
      <Section title="Operator Stack" count={OPERATORS.length} color={T.orange} style={{ marginTop:12 }}>
        <div style={{ marginBottom:12 }}>
          <Segmented options={[{key:"all",label:`All (${OPERATORS.length})`},...OP_CATEGORIES.map(c => ({key:c.id,label:`${c.name} (${OPERATORS.filter(o=>o.category===c.id).length})`}))]}
            active={opCat} onChange={setOpCat} />
        </div>
        <div style={{ display:"flex", flexDirection:"column", gap:6 }}>
          {filteredOps.map(op => {
            const cc = (OP_CATEGORIES.find(c => c.id === op.category) || {}).color || T.text2;
            return (
              <div key={op.id} style={{ display:"flex", alignItems:"flex-start", gap:10, padding:"8px 10px",
                background:T.bg2, borderRadius:T.rSm, border:`1px solid ${T.border0}`, borderLeft:`3px solid ${cc}` }}>
                <div style={{ flex:1 }}>
                  <div style={{ display:"flex", alignItems:"center", gap:6, marginBottom:3 }}>
                    <span style={{ fontFamily:T.mono, fontSize:"0.72rem", fontWeight:600, color:T.text0 }}>{op.id}</span>
                    <span style={{ fontFamily:T.mono, fontSize:"0.55rem", padding:"0.1em 0.4em", borderRadius:T.rSm,
                      background:`${cc}22`, color:cc }}>{op.category}</span>
                  </div>
                  <div style={{ fontFamily:T.body, fontSize:"0.72rem", color:T.text2, marginBottom:3 }}>{op.description}</div>
                  <div style={{ fontFamily:T.mono, fontSize:"0.65rem", color:T.teal, background:T.tealDim, padding:"2px 6px", borderRadius:T.rSm, display:"inline-block" }}>{op.formula}</div>
                  {/* Cross-reference: which techniques use this operator */}
                  {(() => {
                    const users = TECHNIQUES.filter(t => {
                      const d = TECHNIQUE_DETAILS[t.id];
                      return d && d.relevantOps.includes(op.id);
                    });
                    if (users.length === 0) return null;
                    return (
                      <div style={{ marginTop:5, display:"flex", gap:3, flexWrap:"wrap", alignItems:"center" }}>
                        <span style={{ fontFamily:T.mono, fontSize:"0.5rem", color:T.text3, textTransform:"uppercase", letterSpacing:"0.08em" }}>Used by:</span>
                        {users.map(t => (
                          <span key={t.id} style={{ fontFamily:T.mono, fontSize:"0.55rem", padding:"0.08em 0.35em", borderRadius:T.rSm,
                            background:`${familyColor(t.family)}12`, color:familyColor(t.family), border:`1px solid ${familyColor(t.family)}28` }}>
                            {t.name}
                          </span>
                        ))}
                      </div>
                    );
                  })()}
                </div>
              </div>
            );
          })}
        </div>
      </Section>

      {/* Archetypes */}
      <Section title="Stream Archetypes" count={ARCHETYPES.length} color={T.teal} style={{ marginTop:12 }}>
        <div style={{ display:"flex", flexDirection:"column", gap:8 }}>
          {ARCHETYPES.map(arch => {
            const isOpen = expandedArch.has(arch.id);
            return (
              <div key={arch.id} style={{ background:T.bg2, border:`1px solid ${T.border0}`, borderRadius:T.rMd, overflow:"hidden" }}>
                <div onClick={() => toggleArch(arch.id)} style={{ padding:"10px 12px", cursor:"pointer" }}>
                  <div style={{ display:"flex", alignItems:"center", gap:8 }}>
                    <StatusDot color={T.teal} size={7} />
                    <span style={{ fontFamily:T.display, fontWeight:700, fontSize:"0.85rem", color:T.text0, flex:1 }}>{arch.name}</span>
                    <span style={{ fontFamily:T.mono, fontSize:"0.6rem", color:T.text3, transform:isOpen?"rotate(90deg)":"rotate(0)",transition:"transform 0.2s" }}>â–¸</span>
                  </div>
                  <div style={{ fontFamily:T.body, fontSize:"0.72rem", color:T.text2, marginTop:4, marginLeft:15 }}>{arch.description}</div>
                </div>
                <div style={{ maxHeight:isOpen?400:0, overflow:"hidden", transition:"max-height 0.3s ease" }}>
                  <div style={{ padding:"0 12px 12px", borderTop:`1px solid ${T.border0}` }}>
                    <div style={{ display:"grid", gridTemplateColumns:"1fr 1fr", gap:10, marginTop:10 }}>
                      <div>
                        <div style={{ fontFamily:T.mono, fontSize:"0.55rem", color:T.text3, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:6 }}>Example Streams</div>
                        {arch.streams.map((s,i) => (
                          <div key={i} style={{ fontFamily:T.mono, fontSize:"0.65rem", color:T.text1, padding:"2px 0", display:"flex", gap:4, alignItems:"center" }}>
                            <StatusDot color={T.blue} size={4} />{s}
                          </div>
                        ))}
                      </div>
                      <div>
                        <div style={{ fontFamily:T.mono, fontSize:"0.55rem", color:T.green, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:6 }}>Recommended Chain</div>
                        <div style={{ display:"flex", gap:4, flexWrap:"wrap" }}>
                          {arch.recommendedChain.map((tid,i) => {
                            const tech = TECHNIQUES.find(t => t.id === tid);
                            return (
                              <React.Fragment key={tid}>
                                {i > 0 && <span style={{ fontFamily:T.mono, fontSize:"0.6rem", color:T.text3 }}>â†’</span>}
                                <Chip style={{ fontSize:"0.6rem", background:familyColor(tech?.family)+"22",
                                  color:familyColor(tech?.family), border:`1px solid ${familyColor(tech?.family)}33` }}>
                                  {tech?.name || tid}
                                </Chip>
                              </React.Fragment>
                            );
                          })}
                        </div>
                        <div style={{ fontFamily:T.mono, fontSize:"0.55rem", color:T.crimson, textTransform:"uppercase", letterSpacing:"0.1em", marginTop:10, marginBottom:6 }}>Anti-Patterns</div>
                        {arch.antiPatterns.map((ap,i) => (
                          <div key={i} style={{ fontFamily:T.mono, fontSize:"0.62rem", color:T.text2, padding:"2px 0", display:"flex", gap:4, alignItems:"flex-start" }}>
                            <StatusDot color={T.crimson} size={4} />{ap}
                          </div>
                        ))}
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            );
          })}
        </div>
      </Section>
    </div>
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TAB 6: OBSERVATORY â€” Live Feeds + Analysis
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function ObservatoryTab() {
  const [feedData, setFeedData] = useState(null);
  const [feedName, setFeedName] = useState("");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [chars, setChars] = useState(null);
  const [techRecs, setTechRecs] = useState([]);
  const [pipeRecs, setPipeRecs] = useState([]);
  const [feedCategory, setFeedCategory] = useState("all");

  const loadLiveFeed = useCallback(async (feed) => {
    setLoading(true); setError(null); setFeedData(null); setChars(null);
    setTechRecs([]); setPipeRecs([]); setFeedName(feed.name);
    try {
      const resp = await fetch(feed.url);
      if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
      const json = await resp.json();
      const parsed = feed.parse(json);
      const values = parsed.values.filter(v => v != null && isFinite(v));
      if (values.length < 10) throw new Error("Too few valid data points");
      setFeedData(values);
      setFeedName(parsed.name || feed.name);
      const c = detectCharacteristics(values);
      setChars(c);
      setTechRecs(recommendTechniques(c));
      setPipeRecs(recommendPipelines(c));
    } catch (e) {
      setError(e.message);
    }
    setLoading(false);
  }, []);

  const loadSynthetic = useCallback((feed) => {
    setLoading(false); setError(null);
    setFeedName(feed.name);
    const values = feed.generate();
    setFeedData(values);
    const c = detectCharacteristics(values);
    setChars(c);
    setTechRecs(recommendTechniques(c));
    setPipeRecs(recommendPipelines(c));
  }, []);

  const feedCategories = [...new Set(LIVE_FEEDS.map(f => f.category))];
  const filteredFeeds = feedCategory === "all" ? LIVE_FEEDS : LIVE_FEEDS.filter(f => f.category === feedCategory);

  const labelS = { fontFamily:T.mono, fontSize:"0.55rem", color:T.text3, textTransform:"uppercase", letterSpacing:"0.1em", marginBottom:5 };
  const statS = { fontFamily:T.mono, fontSize:"0.72rem" };

  return (
    <div>
      {/* Live Feeds */}
      <Section title="Live Data Feeds" count={LIVE_FEEDS.length} color={T.blue}>
        <div style={{ marginBottom:10 }}>
          <Segmented options={[{key:"all",label:`All (${LIVE_FEEDS.length})`}, ...feedCategories.map(c => ({key:c,label:`${c} (${LIVE_FEEDS.filter(f=>f.category===c).length})`}))]}
            active={feedCategory} onChange={setFeedCategory} />
        </div>
        <div style={{ display:"grid", gridTemplateColumns:"repeat(auto-fill, minmax(260px, 1fr))", gap:6 }}>
          {filteredFeeds.map(f => (
            <button key={f.id} onClick={() => loadLiveFeed(f)} style={{
              background: feedName === f.name ? T.bg4 : T.bg2, border:`1px solid ${feedName === f.name ? T.blue : T.border0}`,
              borderRadius:T.rSm, padding:"8px 10px", cursor:"pointer", textAlign:"left", borderLeft:`3px solid ${T.blue}`,
              display:"block", width:"100%",
            }}>
              <div style={{ fontFamily:T.mono, fontSize:"0.72rem", color:T.text0, fontWeight:600 }}>{f.name}</div>
              <div style={{ fontFamily:T.body, fontSize:"0.65rem", color:T.text2, marginTop:2 }}>{f.description}</div>
              <div style={{ display:"flex", gap:4, marginTop:4 }}>
                <span style={{ fontFamily:T.mono, fontSize:"0.52rem", padding:"0.1em 0.35em", borderRadius:T.rSm,
                  background:T.bg4, color:T.text3 }}>{f.category}</span>
                <span style={{ fontFamily:T.mono, fontSize:"0.52rem", padding:"0.1em 0.35em", borderRadius:T.rSm,
                  background:T.tealDim, color:T.teal }}>{f.archetype}</span>
              </div>
            </button>
          ))}
        </div>
      </Section>

      {/* Synthetic Generators */}
      <Section title="Synthetic Generators" count={SYNTHETIC_FEEDS.length} color={T.green} style={{ marginTop:12 }}>
        <div style={{ fontFamily:T.mono, fontSize:"0.62rem", color:T.text3, marginBottom:8 }}>
          Generate controlled time series to test technique recommendations
        </div>
        <div style={{ display:"grid", gridTemplateColumns:"repeat(auto-fill, minmax(260px, 1fr))", gap:6 }}>
          {SYNTHETIC_FEEDS.map(f => (
            <button key={f.id} onClick={() => loadSynthetic(f)} style={{
              background: feedName === f.name ? T.bg4 : T.bg2, border:`1px solid ${feedName === f.name ? T.green : T.border0}`,
              borderRadius:T.rSm, padding:"8px 10px", cursor:"pointer", textAlign:"left", borderLeft:`3px solid ${T.green}`,
              display:"block", width:"100%",
            }}>
              <div style={{ fontFamily:T.mono, fontSize:"0.72rem", color:T.text0, fontWeight:600 }}>{f.name}</div>
              <div style={{ fontFamily:T.body, fontSize:"0.65rem", color:T.text2, marginTop:2 }}>{f.description}</div>
              <span style={{ fontFamily:T.mono, fontSize:"0.52rem", padding:"0.1em 0.35em", borderRadius:T.rSm,
                background:T.tealDim, color:T.teal, marginTop:4, display:"inline-block" }}>{f.archetype}</span>
            </button>
          ))}
        </div>
      </Section>

      {/* Loading / Error */}
      {loading && (
        <div style={{ textAlign:"center", padding:"24px 0", fontFamily:T.mono, fontSize:"0.78rem", color:T.blue }}>
          <StatusDot color={T.blue} pulse size={8} /> Fetching data...
        </div>
      )}
      {error && (
        <div style={{ margin:"12px 0", padding:"10px 14px", background:T.crimsonDim, border:`1px solid ${T.crimson}33`,
          borderRadius:T.rMd, fontFamily:T.mono, fontSize:"0.72rem", color:T.crimson }}>
          Error: {error}
        </div>
      )}

      {/* Analysis Results */}
      {feedData && chars && !chars.error && (
        <div style={{ marginTop:16 }}>
          {/* Series Overview */}
          <Section title={feedName} count={chars.n} color={T.orange}>
            <div style={{ marginBottom:12 }}>
              <Sparkline data={feedData} width={Math.min(800, feedData.length)} height={80} color={T.blue} showRange filled showMean />
            </div>

            {/* Detected Characteristics */}
            <div style={{ display:"grid", gridTemplateColumns:"repeat(auto-fill, minmax(180px, 1fr))", gap:8, marginBottom:12 }}>
              <div style={{ background:T.bg3, padding:"8px 10px", borderRadius:T.rSm }}>
                <div style={labelS}>Observations</div>
                <div style={statS}><span style={{ color:T.text0, fontWeight:700 }}>{chars.n}</span></div>
              </div>
              <div style={{ background:T.bg3, padding:"8px 10px", borderRadius:T.rSm }}>
                <div style={labelS}>Mean Â± Std</div>
                <div style={statS}><span style={{ color:T.text0 }}>{chars.mean.toFixed(2)}</span> <span style={{ color:T.text3 }}>Â±</span> <span style={{ color:T.yellow }}>{chars.std.toFixed(2)}</span></div>
              </div>
              <div style={{ background:T.bg3, padding:"8px 10px", borderRadius:T.rSm }}>
                <div style={labelS}>Range</div>
                <div style={statS}><span style={{ color:T.teal }}>{chars.min.toFixed(2)}</span> <span style={{ color:T.text3 }}>â†’</span> <span style={{ color:T.orange }}>{chars.max.toFixed(2)}</span></div>
              </div>
              <div style={{ background:T.bg3, padding:"8px 10px", borderRadius:T.rSm }}>
                <div style={labelS}>Trend</div>
                <div style={{ display:"flex", alignItems:"center", gap:4 }}>
                  <StatusDot color={chars.hasTrend ? T.orange : T.text3} size={6} />
                  <span style={{ ...statS, color: chars.hasTrend ? T.orange : T.text3 }}>{chars.hasTrend ? `${chars.trendDirection} (${chars.trendStrength.toFixed(2)})` : "none"}</span>
                </div>
              </div>
              <div style={{ background:T.bg3, padding:"8px 10px", borderRadius:T.rSm }}>
                <div style={labelS}>Seasonality</div>
                <div style={{ display:"flex", alignItems:"center", gap:4 }}>
                  <StatusDot color={chars.hasSeasonality ? T.green : T.text3} size={6} />
                  <span style={{ ...statS, color: chars.hasSeasonality ? T.green : T.text3 }}>{chars.hasSeasonality ? `periodâ‰ˆ${chars.seasonalPeriod} (${chars.seasonalStrength.toFixed(2)})` : "none"}</span>
                </div>
              </div>
              <div style={{ background:T.bg3, padding:"8px 10px", borderRadius:T.rSm }}>
                <div style={labelS}>Stationarity</div>
                <div style={{ display:"flex", alignItems:"center", gap:4 }}>
                  <StatusDot color={chars.isStationary ? T.green : T.crimson} size={6} />
                  <span style={{ ...statS, color: chars.isStationary ? T.green : T.crimson }}>{chars.isStationary ? "stationary" : "non-stationary"}</span>
                </div>
              </div>
              <div style={{ background:T.bg3, padding:"8px 10px", borderRadius:T.rSm }}>
                <div style={labelS}>Vol Clustering</div>
                <div style={{ display:"flex", alignItems:"center", gap:4 }}>
                  <StatusDot color={chars.hasVolClustering ? T.crimson : T.text3} size={6} />
                  <span style={{ ...statS, color: chars.hasVolClustering ? T.crimson : T.text3 }}>{chars.hasVolClustering ? `yes (${chars.volAutocorr.toFixed(2)})` : "no"}</span>
                </div>
              </div>
              <div style={{ background:T.bg3, padding:"8px 10px", borderRadius:T.rSm }}>
                <div style={labelS}>Noise Level</div>
                <span style={{ ...statS, color: chars.noiseLevel === "high" ? T.crimson : chars.noiseLevel === "medium" ? T.yellow : T.green }}>{chars.noiseLevel}</span>
              </div>
              <div style={{ background:T.bg3, padding:"8px 10px", borderRadius:T.rSm }}>
                <div style={labelS}>Lag-1 ACF</div>
                <span style={{ ...statS, color: chars.lag1Autocorr > 0.5 ? T.blue : T.text2 }}>{chars.lag1Autocorr.toFixed(3)}</span>
              </div>
              <div style={{ background:T.bg3, padding:"8px 10px", borderRadius:T.rSm }}>
                <div style={labelS}>Skewness</div>
                <span style={{ ...statS, color: Math.abs(chars.skewness) > 1 ? T.orange : T.text2 }}>{chars.skewness.toFixed(3)}</span>
              </div>
              <div style={{ background:T.bg3, padding:"8px 10px", borderRadius:T.rSm }}>
                <div style={labelS}>Excess Kurtosis</div>
                <span style={{ ...statS, color: Math.abs(chars.kurtosis) > 3 ? T.crimson : T.text2 }}>{chars.kurtosis.toFixed(3)}</span>
              </div>
              <div style={{ background:T.bg3, padding:"8px 10px", borderRadius:T.rSm }}>
                <div style={labelS}>Return Std</div>
                <span style={{ ...statS, color:T.text1 }}>{chars.retStd.toFixed(4)}</span>
              </div>
            </div>

            {/* ACF chart */}
            {chars.allAcfs && chars.allAcfs.length > 0 && (
              <div style={{ marginBottom:12 }}>
                <div style={labelS}>Autocorrelation at Candidate Lags</div>
                <AcfChart acfs={chars.allAcfs} width={360} height={60} />
              </div>
            )}
          </Section>

          {/* Technique Recommendations */}
          <Section title="Recommended Techniques" count={techRecs.length} color={T.orange} style={{ marginTop:12 }}>
            <div style={{ fontFamily:T.mono, fontSize:"0.62rem", color:T.text3, marginBottom:10 }}>
              Ranked by priority â€” based on detected series characteristics
            </div>
            <div style={{ display:"flex", flexDirection:"column", gap:4 }}>
              {techRecs.map((rec, idx) => {
                const tech = TECHNIQUES.find(t => t.id === rec.id);
                if (!tech) return null;
                const fc = familyColor(tech.family);
                const prioColors = { 1:T.green, 2:T.blue, 3:T.purple };
                const prioLabels = { 1:"essential", 2:"recommended", 3:"consider" };
                const pc = prioColors[rec.priority] || T.text3;
                return (
                  <div key={rec.id} style={{ display:"flex", alignItems:"center", gap:8, padding:"6px 10px",
                    background:T.bg2, borderRadius:T.rSm, border:`1px solid ${T.border0}`, borderLeft:`3px solid ${fc}` }}>
                    <Badge color={pc}>{idx + 1}</Badge>
                    <div style={{ flex:1 }}>
                      <div style={{ display:"flex", alignItems:"center", gap:6, marginBottom:2 }}>
                        <span style={{ fontFamily:T.mono, fontSize:"0.72rem", fontWeight:600, color:T.text0 }}>{tech.name}</span>
                        <span style={{ fontFamily:T.mono, fontSize:"0.52rem", padding:"0.1em 0.35em", borderRadius:T.rSm,
                          background:`${fc}18`, color:fc }}>{tech.family}</span>
                        <span style={{ fontFamily:T.mono, fontSize:"0.52rem", padding:"0.1em 0.35em", borderRadius:T.rSm,
                          background:`${pc}18`, color:pc }}>{prioLabels[rec.priority]}</span>
                      </div>
                      <div style={{ fontFamily:T.mono, fontSize:"0.62rem", color:T.text2 }}>{rec.reason}</div>
                    </div>
                    <span style={{ fontFamily:T.mono, fontSize:"0.55rem", color:T.text3 }}>{tech.pipelineRole}</span>
                  </div>
                );
              })}
            </div>
          </Section>

          {/* Pipeline Recommendations */}
          {pipeRecs.length > 0 && (
            <Section title="Matching Pipelines" count={pipeRecs.length} color={T.green} style={{ marginTop:12 }}>
              <div style={{ fontFamily:T.mono, fontSize:"0.62rem", color:T.text3, marginBottom:10 }}>
                Canonical pipelines that match this series' characteristics
              </div>
              <div style={{ display:"flex", flexDirection:"column", gap:6 }}>
                {pipeRecs.map(p => (
                  <div key={p.id} style={{ background:T.bg2, border:`1px solid ${T.border0}`, borderRadius:T.rMd,
                    padding:"10px 12px", borderLeft:`3px solid ${T.green}` }}>
                    <div style={{ display:"flex", alignItems:"center", gap:6, marginBottom:4 }}>
                      <span style={{ fontFamily:T.display, fontWeight:700, fontSize:"0.78rem", color:T.text0, flex:1 }}>{p.name}</span>
                      <span style={{ fontFamily:T.mono, fontSize:"0.52rem", padding:"0.1em 0.35em", borderRadius:T.rSm,
                        background:T.bg4, color:T.text3 }}>complexity {p.complexity}</span>
                    </div>
                    <div style={{ fontFamily:T.body, fontSize:"0.68rem", color:T.text2, marginBottom:6 }}>{p.description}</div>
                    <div style={{ display:"flex", gap:3, alignItems:"center", flexWrap:"wrap", marginBottom:4 }}>
                      {p.steps.map((sid, i) => {
                        const t = TECHNIQUES.find(x => x.id === sid);
                        const fc = t ? familyColor(t.family) : T.text3;
                        const isRec = techRecs.some(r => r.id === sid);
                        return (
                          <React.Fragment key={sid}>
                            {i > 0 && <span style={{ fontFamily:T.mono, fontSize:"0.6rem", color:T.text3 }}>â†’</span>}
                            <span style={{ fontFamily:T.mono, fontSize:"0.6rem", padding:"0.12em 0.45em", borderRadius:T.rSm,
                              background:`${fc}${isRec ? "28" : "12"}`, color:fc,
                              border:`1px solid ${fc}${isRec ? "55" : "28"}`, fontWeight: isRec ? 600 : 400 }}>
                              {t ? t.name : sid}{isRec ? " â˜…" : ""}
                            </span>
                          </React.Fragment>
                        );
                      })}
                    </div>
                    <div style={{ fontFamily:T.mono, fontSize:"0.55rem", color:T.text3 }}>{p.useCase}</div>
                  </div>
                ))}
              </div>
            </Section>
          )}
        </div>
      )}

      {/* Empty state */}
      {!feedData && !loading && !error && (
        <div style={{ textAlign:"center", padding:"32px 0", fontFamily:T.mono, fontSize:"0.78rem", color:T.text3 }}>
          Select a live feed or synthetic generator above to analyze
        </div>
      )}
    </div>
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TAB 7: GRAPH â€” Technique network + path tracing + percolation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function GraphTab() {
  const GW = 1000, GH = 620;
  const nodeR = 18;
  const positions = useMemo(() => computeNodePositions(GH), []);

  const [selected, setSelected] = useState(null);
  const [hoveredNode, setHoveredNode] = useState(null);
  const [hoveredEdge, setHoveredEdge] = useState(null);
  const [showConflicts, setShowConflicts] = useState(true);
  const [paths, setPaths] = useState([]);
  const [activePath, setActivePath] = useState(null);
  const [showCanonical, setShowCanonical] = useState(null);

  // Percolation state
  const [percFeedId, setPercFeedId] = useState("syn_seasonal");
  const [percStages, setPercStages] = useState(null);
  const [percStep, setPercStep] = useState(-1);
  const [percRunning, setPercRunning] = useState(false);

  // Discover paths on node select
  useEffect(() => {
    if (selected) {
      const found = findSynergyPaths(selected, 5);
      setPaths(found.slice(0, 30));
    } else {
      setPaths([]);
    }
    setActivePath(null);
    setPercStages(null);
    setPercStep(-1);
    setPercRunning(false);
  }, [selected]);

  // Percolation timer â€” advances one step every 1.8 seconds
  useEffect(() => {
    if (!percRunning || !percStages) return;
    if (percStep >= percStages.length - 1) { setPercRunning(false); return; }
    const timer = setTimeout(() => setPercStep(s => s + 1), 1800);
    return () => clearTimeout(timer);
  }, [percRunning, percStep, percStages]);

  // Start percolation for a path
  const startPercolation = useCallback((pathSteps) => {
    const feed = SYNTHETIC_FEEDS.find(f => f.id === percFeedId);
    if (!feed) return;
    const rawData = feed.generate();
    const stages = percolatePipeline(rawData, pathSteps);
    setPercStages(stages);
    setPercStep(0);
    setPercRunning(true);
    setActivePath(pathSteps);
  }, [percFeedId]);

  // Build edge list
  const synergyEdges = useMemo(() => KNOWN_SYNERGIES.filter(s => positions[s.from] && positions[s.to]), [positions]);
  const conflictEdges = useMemo(() => KNOWN_CONFLICTS.filter(c => positions[c.from] && positions[c.to]), [positions]);

  // Determine highlighted nodes/edges
  const activePathSet = useMemo(() => new Set(activePath || []), [activePath]);
  const activeEdgeSet = useMemo(() => {
    if (!activePath) return new Set();
    const s = new Set();
    for (let i = 0; i < activePath.length - 1; i++) s.add(`${activePath[i]}|${activePath[i + 1]}`);
    return s;
  }, [activePath]);

  const selectedConnections = useMemo(() => {
    if (!selected) return { synTo: new Set(), synFrom: new Set(), confTo: new Set(), confFrom: new Set() };
    const synTo = new Set(), synFrom = new Set(), confTo = new Set(), confFrom = new Set();
    KNOWN_SYNERGIES.forEach(s => { if (s.from === selected) synTo.add(s.to); if (s.to === selected) synFrom.add(s.from); });
    KNOWN_CONFLICTS.forEach(c => { if (c.from === selected) confTo.add(c.to); if (c.to === selected) confFrom.add(c.from); });
    return { synTo, synFrom, confTo, confFrom };
  }, [selected]);

  // Canonical path overlay
  const canonicalEdgeSet = useMemo(() => {
    if (!showCanonical) return new Set();
    const cp = CANONICAL_PIPELINES.find(p => p.id === showCanonical);
    if (!cp) return new Set();
    const s = new Set();
    for (let i = 0; i < cp.steps.length - 1; i++) s.add(`${cp.steps[i]}|${cp.steps[i + 1]}`);
    return s;
  }, [showCanonical]);
  const canonicalNodeSet = useMemo(() => {
    if (!showCanonical) return new Set();
    const cp = CANONICAL_PIPELINES.find(p => p.id === showCanonical);
    return cp ? new Set(cp.steps) : new Set();
  }, [showCanonical]);

  // Get percolation sparkline for a node
  const percDataForNode = useCallback((techId) => {
    if (!percStages || percStep < 0) return null;
    const stage = percStages.find(s => s.techId === techId);
    if (!stage) return null;
    const stageIdx = percStages.indexOf(stage);
    if (stageIdx > percStep) return null; // not yet reached
    return stage;
  }, [percStages, percStep]);

  function edgePath(fromId, toId) {
    const a = positions[fromId], b = positions[toId];
    if (!a || !b) return "";
    const dx = b.x - a.x, dy = b.y - a.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const ox = (dx / dist) * nodeR, oy = (dy / dist) * nodeR;
    const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
    const bend = Math.abs(dy) > 200 ? dx * 0.15 : dy * 0.15;
    return `M${a.x + ox},${a.y + oy} Q${mx + bend},${my - Math.abs(bend) * 0.3} ${b.x - ox},${b.y - oy}`;
  }

  return (
    <div>
      {/* Controls */}
      <div style={{ display: "flex", gap: 8, alignItems: "center", flexWrap: "wrap", marginBottom: 12 }}>
        <button onClick={() => setShowConflicts(!showConflicts)} style={{
          fontFamily: T.mono, fontSize: "0.62rem", padding: "4px 10px", borderRadius: T.rSm,
          border: `1px solid ${showConflicts ? T.crimson : T.border1}`, background: showConflicts ? T.crimsonDim : T.bg3,
          color: showConflicts ? T.crimson : T.text2, cursor: "pointer"
        }}>{showConflicts ? "Hide" : "Show"} Conflicts ({conflictEdges.length})</button>
        <button onClick={() => { setSelected(null); setShowCanonical(null); setActivePath(null); setPercStages(null); }} style={{
          fontFamily: T.mono, fontSize: "0.62rem", padding: "4px 10px", borderRadius: T.rSm,
          border: `1px solid ${T.border1}`, background: T.bg3, color: T.text2, cursor: "pointer"
        }}>Reset</button>
        <span style={{ fontFamily: T.mono, fontSize: "0.58rem", color: T.text3, marginLeft: 4 }}>
          {TECHNIQUES.length} nodes Â· {synergyEdges.length} synergies Â· {conflictEdges.length} conflicts
        </span>
        {selected && <span style={{ fontFamily: T.mono, fontSize: "0.62rem", color: T.orange }}>
          Selected: {(TECHNIQUES.find(t => t.id === selected) || {}).name} Â· {paths.length} paths found
        </span>}
      </div>

      {/* SVG Graph */}
      <div style={{ background: T.bg1, border: `1px solid ${T.border0}`, borderRadius: T.rMd, overflow: "hidden", position: "relative" }}>
        <svg width={GW} height={GH} viewBox={`0 0 ${GW} ${GH}`} style={{ display: "block", width: "100%" }}>
          {/* Column labels */}
          {GRAPH_COL_DEFS.map((col, i) => (
            <text key={i} x={col.x} y={14} textAnchor="middle"
              style={{ fontFamily: T.mono, fontSize: 8, fill: T.text3, letterSpacing: "0.12em" }}>{col.label}</text>
          ))}
          {/* Column separator lines */}
          {GRAPH_COL_DEFS.map((col, i) => (
            <line key={`cl${i}`} x1={col.x} y1={22} x2={col.x} y2={GH - 10}
              stroke={T.border0} strokeWidth={0.5} strokeDasharray="2,4" />
          ))}

          {/* Synergy edges */}
          {synergyEdges.map((s, i) => {
            const key = `${s.from}|${s.to}`;
            const isActive = activeEdgeSet.has(key);
            const isCanon = canonicalEdgeSet.has(key);
            const isConnected = selected && (s.from === selected || s.to === selected);
            const dim = (selected || activePath || showCanonical) && !isActive && !isCanon && !isConnected;
            return (
              <path key={`syn${i}`} d={edgePath(s.from, s.to)}
                fill="none" stroke={isActive ? T.green : isCanon ? T.blue : T.green}
                strokeWidth={isActive || isCanon ? 2.5 : isConnected ? 1.8 : 0.8}
                strokeOpacity={dim ? 0.08 : isActive || isCanon ? 1 : isConnected ? 0.7 : 0.2}
                onMouseEnter={() => setHoveredEdge(s)}
                onMouseLeave={() => setHoveredEdge(null)}
                style={{ cursor: "pointer", transition: "stroke-opacity 0.3s" }}
                markerEnd={isActive || isCanon || isConnected ? "url(#arrowG)" : ""} />
            );
          })}

          {/* Conflict edges */}
          {showConflicts && conflictEdges.map((c, i) => {
            const isConnected = selected && (c.from === selected || c.to === selected);
            const dim = (selected || activePath || showCanonical) && !isConnected;
            return (
              <path key={`con${i}`} d={edgePath(c.from, c.to)}
                fill="none" stroke={T.crimson}
                strokeWidth={isConnected ? 1.5 : 0.6}
                strokeOpacity={dim ? 0.05 : isConnected ? 0.6 : 0.12}
                strokeDasharray="4,3"
                onMouseEnter={() => setHoveredEdge(c)}
                onMouseLeave={() => setHoveredEdge(null)}
                style={{ cursor: "pointer", transition: "stroke-opacity 0.3s" }} />
            );
          })}

          {/* Arrow markers */}
          <defs>
            <marker id="arrowG" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="6" markerHeight="6" orient="auto">
              <path d="M0,1 L9,5 L0,9" fill={T.green} />
            </marker>
            <marker id="arrowB" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="6" markerHeight="6" orient="auto">
              <path d="M0,1 L9,5 L0,9" fill={T.blue} />
            </marker>
          </defs>

          {/* Technique nodes */}
          {TECHNIQUES.map(t => {
            const p = positions[t.id];
            if (!p) return null;
            const fc = familyColor(t.family);
            const isSel = t.id === selected;
            const isHov = t.id === hoveredNode;
            const isOnPath = activePathSet.has(t.id);
            const isCanon = canonicalNodeSet.has(t.id);
            const isConn = selected && (selectedConnections.synTo.has(t.id) || selectedConnections.synFrom.has(t.id) || selectedConnections.confTo.has(t.id) || selectedConnections.confFrom.has(t.id));
            const dim = (selected || activePath || showCanonical) && !isSel && !isOnPath && !isCanon && !isConn;
            const percData = percDataForNode(t.id);
            const reached = !!percData;

            return (
              <g key={t.id}
                onClick={() => setSelected(s => s === t.id ? null : t.id)}
                onMouseEnter={() => setHoveredNode(t.id)}
                onMouseLeave={() => setHoveredNode(null)}
                style={{ cursor: "pointer" }}>
                {/* Glow ring for active path nodes */}
                {(isOnPath || isCanon) && reached && (
                  <circle cx={p.x} cy={p.y} r={nodeR + 5} fill="none" stroke={T.green}
                    strokeWidth={1} strokeOpacity={0.4}>
                    <animate attributeName="r" values={`${nodeR + 3};${nodeR + 7};${nodeR + 3}`} dur="2s" repeatCount="indefinite" />
                    <animate attributeName="stroke-opacity" values="0.5;0.15;0.5" dur="2s" repeatCount="indefinite" />
                  </circle>
                )}
                {/* Node circle */}
                <circle cx={p.x} cy={p.y} r={isSel ? nodeR + 2 : isHov ? nodeR + 1 : nodeR}
                  fill={dim ? T.bg3 : `${fc}22`}
                  stroke={isSel ? T.text0 : isOnPath || isCanon ? T.green : isConn ? fc : dim ? T.border0 : fc}
                  strokeWidth={isSel ? 2 : isOnPath || isCanon ? 2 : 1}
                  opacity={dim ? 0.3 : 1}
                  style={{ transition: "opacity 0.3s, stroke 0.3s" }} />
                {/* Label */}
                <text x={p.x} y={p.y + 1} textAnchor="middle" dominantBaseline="middle"
                  style={{ fontFamily: T.mono, fontSize: 7.5, fontWeight: isSel || isOnPath ? 700 : 500,
                    fill: dim ? T.text3 : isSel ? T.text0 : fc, pointerEvents: "none",
                    transition: "fill 0.3s" }}>
                  {t.name.length > 10 ? t.name.slice(0, 9) + "â€¦" : t.name}
                </text>
                {/* Percolation sparkline below node */}
                {reached && percData.values && percData.values.length > 3 && (
                  <g transform={`translate(${p.x - 25},${p.y + nodeR + 2})`}>
                    <rect x={-2} y={-1} width={54} height={18} rx={2} fill={T.bg0} fillOpacity={0.85} stroke={T.green} strokeWidth={0.5} />
                    {(() => {
                      const vals = percData.values.slice(0, 200);
                      const vMin = Math.min(...vals), vMax = Math.max(...vals), vR = vMax - vMin || 1;
                      const pts = vals.map((v, i) => `${(i / (vals.length - 1)) * 50},${15 - ((v - vMin) / vR) * 14}`).join(" ");
                      return <polyline points={pts} fill="none" stroke={T.green} strokeWidth={0.8} />;
                    })()}
                  </g>
                )}
              </g>
            );
          })}
        </svg>

        {/* Edge tooltip */}
        {hoveredEdge && (
          <div style={{
            position: "absolute", top: 10, right: 10, maxWidth: 320, padding: "8px 12px",
            background: T.bg3, border: `1px solid ${hoveredEdge.violation ? T.crimson : T.green}33`,
            borderRadius: T.rMd, zIndex: 10,
          }}>
            <div style={{ fontFamily: T.mono, fontSize: "0.68rem", color: T.text0, marginBottom: 4 }}>
              <span style={{ color: familyColor((TECHNIQUES.find(t => t.id === hoveredEdge.from) || {}).family) }}>
                {(TECHNIQUES.find(t => t.id === hoveredEdge.from) || {}).name}
              </span>
              <span style={{ color: T.text3 }}> â†’ </span>
              <span style={{ color: familyColor((TECHNIQUES.find(t => t.id === hoveredEdge.to) || {}).family) }}>
                {(TECHNIQUES.find(t => t.id === hoveredEdge.to) || {}).name}
              </span>
            </div>
            <div style={{ fontFamily: T.body, fontSize: "0.65rem", color: T.text2 }}>{hoveredEdge.reason}</div>
            {hoveredEdge.principles && <div style={{ fontFamily: T.mono, fontSize: "0.55rem", color: T.green, marginTop: 4 }}>Principles: {hoveredEdge.principles.join(", ")}</div>}
            {hoveredEdge.violation && <div style={{ fontFamily: T.mono, fontSize: "0.55rem", color: T.crimson, marginTop: 4 }}>Violates principle {hoveredEdge.violation} ({hoveredEdge.severity})</div>}
          </div>
        )}
      </div>

      {/* Bottom panels: paths + percolation + canonical */}
      <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: 12, marginTop: 12 }}>
        {/* Discovered paths */}
        <Section title={selected ? `Paths from ${(TECHNIQUES.find(t => t.id === selected) || {}).name}` : "Discovered Paths"} count={paths.length} color={T.green}>
          {!selected && <div style={{ fontFamily: T.mono, fontSize: "0.65rem", color: T.text3, padding: "12px 0" }}>Click a technique node to discover composition paths</div>}
          {paths.length > 0 && (
            <div style={{ marginBottom: 8 }}>
              <div style={{ fontFamily: T.mono, fontSize: "0.55rem", color: T.text3, marginBottom: 6 }}>Feed for percolation:</div>
              <div style={{ display: "flex", gap: 4, flexWrap: "wrap" }}>
                {SYNTHETIC_FEEDS.map(f => (
                  <button key={f.id} onClick={() => setPercFeedId(f.id)} style={{
                    fontFamily: T.mono, fontSize: "0.55rem", padding: "2px 6px", borderRadius: T.rSm,
                    background: percFeedId === f.id ? T.greenDim : T.bg3, border: `1px solid ${percFeedId === f.id ? T.green : T.border0}`,
                    color: percFeedId === f.id ? T.green : T.text3, cursor: "pointer"
                  }}>{f.name}</button>
                ))}
              </div>
            </div>
          )}
          <div style={{ maxHeight: 280, overflowY: "auto", display: "flex", flexDirection: "column", gap: 4 }}>
            {paths.map((p, idx) => {
              const isActive = activePath && activePath.join(",") === p.steps.join(",");
              return (
                <div key={idx} style={{
                  background: isActive ? T.bg4 : T.bg2, border: `1px solid ${isActive ? T.green : T.border0}`,
                  borderRadius: T.rSm, padding: "6px 8px", cursor: "pointer",
                }} onClick={() => { setActivePath(p.steps); setPercStages(null); setPercStep(-1); setPercRunning(false); }}>
                  <div style={{ display: "flex", alignItems: "center", gap: 4, marginBottom: 3, flexWrap: "wrap" }}>
                    {p.steps.map((sid, i) => {
                      const t = TECHNIQUES.find(x => x.id === sid);
                      return (
                        <React.Fragment key={sid}>
                          {i > 0 && <span style={{ fontFamily: T.mono, fontSize: "0.55rem", color: T.text3 }}>â†’</span>}
                          <span style={{ fontFamily: T.mono, fontSize: "0.58rem", color: familyColor(t?.family), fontWeight: 500 }}>
                            {t?.name || sid}
                          </span>
                        </React.Fragment>
                      );
                    })}
                    <span style={{ marginLeft: "auto", fontFamily: T.mono, fontSize: "0.55rem",
                      color: p.score > 0.8 ? T.green : p.score > 0.5 ? T.yellow : T.crimson }}>
                      {(p.score * 100).toFixed(0)}%
                    </span>
                  </div>
                  {isActive && (
                    <button onClick={(e) => { e.stopPropagation(); startPercolation(p.steps); }} style={{
                      fontFamily: T.mono, fontSize: "0.58rem", padding: "3px 8px", borderRadius: T.rSm, marginTop: 4,
                      background: T.greenDim, border: `1px solid ${T.green}44`, color: T.green, cursor: "pointer",
                    }}>
                      {percRunning ? `Percolating... step ${percStep}/${percStages?.length - 1 || "?"}` : "â–¶ Percolate Feed"}
                    </button>
                  )}
                </div>
              );
            })}
          </div>
        </Section>

        {/* Canonical pipelines + Percolation output */}
        <div>
          {/* Percolation results */}
          {percStages && percStep >= 0 && (
            <Section title="Percolation" count={`${percStep + 1}/${percStages.length}`} color={T.yellow} style={{ marginBottom: 12 }}>
              <div style={{ display: "flex", flexDirection: "column", gap: 6 }}>
                {percStages.slice(0, percStep + 1).map((stage, i) => {
                  const tech = TECHNIQUES.find(t => t.id === stage.techId);
                  const fc = tech ? familyColor(tech.family) : T.text3;
                  const vals = stage.values;
                  const isLatest = i === percStep;
                  return (
                    <div key={i} style={{
                      background: isLatest ? T.bg4 : T.bg2, border: `1px solid ${isLatest ? T.yellow : T.border0}`,
                      borderRadius: T.rSm, padding: "6px 8px", borderLeft: `3px solid ${fc}`,
                      opacity: isLatest ? 1 : 0.7, transition: "opacity 0.5s",
                    }}>
                      <div style={{ display: "flex", alignItems: "center", gap: 6, marginBottom: 4 }}>
                        <span style={{ fontFamily: T.mono, fontSize: "0.55rem", color: T.text3 }}>Step {i}</span>
                        <span style={{ fontFamily: T.mono, fontSize: "0.68rem", color: fc, fontWeight: 600 }}>
                          {tech ? tech.name : "Input"}
                        </span>
                        <span style={{ fontFamily: T.mono, fontSize: "0.55rem", color: T.text2, marginLeft: "auto" }}>{stage.label}</span>
                      </div>
                      {vals && vals.length > 3 && typeof vals[0] === 'number' && (
                        <Sparkline data={vals.slice(0, 300)} width={320} height={28} color={fc} showRange filled />
                      )}
                      {stage.band && (
                        <div style={{ fontFamily: T.mono, fontSize: "0.55rem", color: T.teal, marginTop: 2 }}>
                          Band: Â±{stage.band.toFixed(3)}
                        </div>
                      )}
                    </div>
                  );
                })}
              </div>
            </Section>
          )}

          {/* Canonical pipelines overlay selector */}
          <Section title="Canonical Pipelines" count={CANONICAL_PIPELINES.length} color={T.blue}>
            <div style={{ fontFamily: T.mono, fontSize: "0.58rem", color: T.text3, marginBottom: 8 }}>Click to highlight on graph</div>
            <div style={{ maxHeight: percStages ? 150 : 320, overflowY: "auto", display: "flex", flexDirection: "column", gap: 3 }}>
              {CANONICAL_PIPELINES.map(cp => (
                <button key={cp.id}
                  onClick={() => { setShowCanonical(s => s === cp.id ? null : cp.id); setActivePath(null); setSelected(null); }}
                  style={{
                    background: showCanonical === cp.id ? T.bg4 : T.bg2, border: `1px solid ${showCanonical === cp.id ? T.blue : T.border0}`,
                    borderRadius: T.rSm, padding: "5px 8px", cursor: "pointer", textAlign: "left", display: "block", width: "100%",
                  }}>
                  <div style={{ fontFamily: T.mono, fontSize: "0.65rem", color: T.text0, fontWeight: 600, marginBottom: 2 }}>{cp.name}</div>
                  <div style={{ display: "flex", gap: 3, alignItems: "center", flexWrap: "wrap" }}>
                    {cp.steps.map((sid, i) => (
                      <React.Fragment key={sid}>
                        {i > 0 && <span style={{ fontFamily: T.mono, fontSize: "0.5rem", color: T.text3 }}>â†’</span>}
                        <span style={{ fontFamily: T.mono, fontSize: "0.55rem",
                          color: familyColor((TECHNIQUES.find(x => x.id === sid) || {}).family) }}>
                          {(TECHNIQUES.find(x => x.id === sid) || {}).name || sid}
                        </span>
                      </React.Fragment>
                    ))}
                  </div>
                </button>
              ))}
            </div>
          </Section>
        </div>
      </div>
    </div>
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TAB 8: CAUSAL LAB â€” Hilbert space causal inference
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function CausalTab() {
  const [causalType, setCausalType] = useState("linear");
  const [delay, setDelay] = useState(3);
  const [noise, setNoise] = useState(0.5);
  const [nPts, setNPts] = useState(300);
  const [signals, setSignals] = useState(null);
  const [results, setResults] = useState(null);
  const [running, setRunning] = useState(false);
  const [expandedConcept, setExpandedConcept] = useState(null);

  const runExperiment = useCallback(() => {
    setRunning(true);
    setTimeout(() => {
      const n = nPts;
      const x = Array.from({ length: n }, () => gaussianRandom());
      const y = new Array(n).fill(0);
      if (causalType === "linear") {
        for (let t = delay; t < n; t++) y[t] = 0.7 * x[t - delay] + noise * gaussianRandom();
      } else if (causalType === "nonlinear") {
        for (let t = delay; t < n; t++) y[t] = 0.6 * Math.sin(2.5 * x[t - delay]) + 0.3 * x[t - delay] * x[t - delay] + noise * gaussianRandom();
      } else if (causalType === "none") {
        for (let t = 0; t < n; t++) y[t] = gaussianRandom();
      } else if (causalType === "bidirectional") {
        for (let t = delay; t < n; t++) {
          y[t] = 0.5 * x[t - delay] + noise * gaussianRandom();
          if (t >= delay * 2) x[t] = x[t] * 0.5 + 0.3 * y[t - delay] + noise * 0.5 * gaussianRandom();
        }
      }
      setSignals({ x, y });
      const lags = Math.max(delay + 2, 5);
      const linXY = grangerTest(x, y, lags);
      const linYX = grangerTest(y, x, lags);
      const kXY = kernelGrangerTest(x, y, lags);
      const kYX = kernelGrangerTest(y, x, lags);
      const hXY = hsicTest(x.slice(delay), y.slice(delay));
      setResults({ linXY, linYX, kXY, kYX, hXY });
      setRunning(false);
    }, 50);
  }, [causalType, delay, noise, nPts]);

  const conceptColor = id => (HILBERT_CONCEPTS.find(c => c.id === id) || {}).color || T.text3;
  const labelS = { fontFamily: T.mono, fontSize: "0.55rem", color: T.text3, textTransform: "uppercase", letterSpacing: "0.1em", marginBottom: 5 };
  const statS = { fontFamily: T.mono, fontSize: "0.72rem" };

  return (
    <div>
      {/* Hilbert Concepts Reference */}
      <Section title="Hilbert Space â†” Causality" count={HILBERT_CONCEPTS.length} color={T.purple}>
        <div style={{ fontFamily: T.body, fontSize: "0.72rem", color: T.text2, marginBottom: 12, lineHeight: 1.6 }}>
          A variable <strong style={{ color: T.text0 }}>causes</strong> another if adding it <strong style={{ color: T.text0 }}>changes the orthogonal decomposition</strong> of future information.
          Modern causal discovery operates in Hilbert spaces â€” often infinite-dimensional ones â€” even when data look raw and discrete.
        </div>
        {/* Summary table */}
        <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: 6, marginBottom: 12 }}>
          {[
            { concept: "Prediction", hilbert: "Projection P_H", color: T.blue },
            { concept: "Independence", hilbert: "Orthogonality X âŠ¥ Y", color: T.green },
            { concept: "Causality", hilbert: "Subspace expansion", color: T.orange },
            { concept: "Multimodal fusion", hilbert: "Tensor factorization âŠ—", color: T.crimson },
            { concept: "Nonlinear relations", hilbert: "RKHS lifting Ï†(x)", color: T.orange },
            { concept: "Time direction", hilbert: "Spectral asymmetry S(Ï‰)", color: T.purple },
          ].map((r, i) => (
            <div key={i} style={{ display: "flex", alignItems: "center", gap: 8, padding: "4px 8px", background: T.bg3, borderRadius: T.rSm }}>
              <StatusDot color={r.color} size={5} />
              <span style={{ fontFamily: T.mono, fontSize: "0.65rem", color: T.text1, flex: 1 }}>{r.concept}</span>
              <span style={{ fontFamily: T.mono, fontSize: "0.62rem", color: r.color }}>= {r.hilbert}</span>
            </div>
          ))}
        </div>
        {/* Expandable concept cards */}
        <div style={{ display: "flex", flexDirection: "column", gap: 6 }}>
          {HILBERT_CONCEPTS.map(hc => {
            const isOpen = expandedConcept === hc.id;
            return (
              <div key={hc.id} style={{ background: T.bg2, border: `1px solid ${T.border0}`, borderRadius: T.rMd, overflow: "hidden", borderLeft: `3px solid ${hc.color}` }}>
                <div onClick={() => setExpandedConcept(isOpen ? null : hc.id)} style={{ padding: "8px 10px", cursor: "pointer" }}>
                  <div style={{ display: "flex", alignItems: "center", gap: 6 }}>
                    <span style={{ fontFamily: T.mono, fontSize: "0.72rem", fontWeight: 600, color: hc.color }}>{hc.symbol}</span>
                    <span style={{ fontFamily: T.display, fontWeight: 700, fontSize: "0.82rem", color: T.text0, flex: 1 }}>{hc.name}</span>
                    <Badge color={hc.color}>{hc.techniques.length}</Badge>
                    <span style={{ fontFamily: T.mono, fontSize: "0.6rem", color: T.text3, transform: isOpen ? "rotate(90deg)" : "rotate(0)", transition: "transform 0.2s" }}>â–¸</span>
                  </div>
                  <div style={{ fontFamily: T.body, fontSize: "0.68rem", color: T.text2, marginTop: 4 }}>{hc.description}</div>
                </div>
                <div style={{ maxHeight: isOpen ? 400 : 0, overflow: "hidden", transition: "max-height 0.3s ease" }}>
                  <div style={{ padding: "0 10px 10px", borderTop: `1px solid ${T.border0}` }}>
                    <div style={{ fontFamily: T.mono, fontSize: "0.65rem", color: T.text1, padding: "8px 0 6px" }}>
                      <span style={{ color: T.text3 }}>Hilbert: </span>{hc.hilbertMeaning}
                    </div>
                    <div style={{ fontFamily: T.mono, fontSize: "0.65rem", color: T.text1, paddingBottom: 8, borderBottom: `1px dashed ${T.border0}` }}>
                      <span style={{ color: T.text3 }}>Causal role: </span>{hc.causalRole}
                    </div>
                    <div style={{ marginTop: 8 }}>
                      <div style={labelS}>Techniques using this structure</div>
                      <div style={{ display: "flex", gap: 3, flexWrap: "wrap" }}>
                        {hc.techniques.map(tid => {
                          const t = TECHNIQUES.find(x => x.id === tid);
                          return t ? (
                            <span key={tid} style={{ fontFamily: T.mono, fontSize: "0.6rem", padding: "0.12em 0.4em", borderRadius: T.rSm,
                              background: `${familyColor(t.family)}15`, color: familyColor(t.family), border: `1px solid ${familyColor(t.family)}28` }}>
                              {t.name}
                            </span>
                          ) : null;
                        })}
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            );
          })}
        </div>
      </Section>

      {/* Causal Detection Lab */}
      <Section title="Causal Detection Lab" color={T.orange} style={{ marginTop: 12 }}>
        <div style={{ fontFamily: T.body, fontSize: "0.72rem", color: T.text2, marginBottom: 12, lineHeight: 1.6 }}>
          Generate paired signals with known causal structure, then run <strong style={{ color: T.blue }}>linear Granger</strong> (projection in LÂ²)
          and <strong style={{ color: T.orange }}>kernel Granger</strong> (projection in RKHS) tests.
          The <strong style={{ color: T.teal }}>HSIC</strong> measures total dependence via cross-covariance operator norm.
        </div>
        <div style={{ display: "grid", gridTemplateColumns: "repeat(auto-fill, minmax(160px, 1fr))", gap: 8, marginBottom: 12 }}>
          <div>
            <div style={labelS}>Causal Structure</div>
            <div style={{ display: "flex", flexDirection: "column", gap: 3 }}>
              {[["linear", "Xâ†’Y linear"], ["nonlinear", "Xâ†’Y nonlinear"], ["none", "Independent"], ["bidirectional", "Xâ†”Y mutual"]].map(([k, l]) => (
                <button key={k} onClick={() => setCausalType(k)} style={{
                  fontFamily: T.mono, fontSize: "0.62rem", padding: "4px 8px", borderRadius: T.rSm, cursor: "pointer", textAlign: "left",
                  background: causalType === k ? T.orangeDim : T.bg3, border: `1px solid ${causalType === k ? T.orange : T.border0}`,
                  color: causalType === k ? T.orange : T.text2,
                }}>{l}</button>
              ))}
            </div>
          </div>
          <div>
            <div style={labelS}>Delay (lags)</div>
            <input type="range" min={1} max={10} value={delay} onChange={e => setDelay(+e.target.value)} style={{ width: "100%" }} />
            <div style={{ fontFamily: T.mono, fontSize: "0.68rem", color: T.text0, textAlign: "center" }}>{delay}</div>
          </div>
          <div>
            <div style={labelS}>Noise Ïƒ</div>
            <input type="range" min={0} max={2} step={0.1} value={noise} onChange={e => setNoise(+e.target.value)} style={{ width: "100%" }} />
            <div style={{ fontFamily: T.mono, fontSize: "0.68rem", color: T.text0, textAlign: "center" }}>{noise.toFixed(1)}</div>
          </div>
          <div>
            <div style={labelS}>Sample size</div>
            <input type="range" min={100} max={800} step={50} value={nPts} onChange={e => setNPts(+e.target.value)} style={{ width: "100%" }} />
            <div style={{ fontFamily: T.mono, fontSize: "0.68rem", color: T.text0, textAlign: "center" }}>{nPts}</div>
          </div>
        </div>
        <button onClick={runExperiment} disabled={running} style={{
          fontFamily: T.mono, fontSize: "0.72rem", padding: "8px 20px", borderRadius: T.rMd, cursor: running ? "wait" : "pointer",
          background: T.orangeDim, border: `1px solid ${T.orange}44`, color: T.orange, fontWeight: 600, marginBottom: 12,
        }}>{running ? "Computing projections..." : "â–¶ Run Causal Experiment"}</button>

        {/* Signal display */}
        {signals && (
          <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: 10, marginBottom: 12 }}>
            <div style={{ background: T.bg3, padding: "8px 10px", borderRadius: T.rSm }}>
              <div style={labelS}>X (driver)</div>
              <Sparkline data={signals.x} width={400} height={50} color={T.blue} filled showRange />
            </div>
            <div style={{ background: T.bg3, padding: "8px 10px", borderRadius: T.rSm }}>
              <div style={labelS}>Y (response)</div>
              <Sparkline data={signals.y} width={400} height={50} color={T.orange} filled showRange />
            </div>
          </div>
        )}

        {/* Results */}
        {results && (
          <div>
            <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gap: 10, marginBottom: 12 }}>
              {/* Linear Granger */}
              <div style={{ background: T.bg2, border: `1px solid ${T.border0}`, borderRadius: T.rMd, padding: "10px 12px", borderLeft: `3px solid ${T.blue}` }}>
                <div style={{ ...labelS, color: T.blue }}>Linear Granger (LÂ² projection)</div>
                <div style={{ marginBottom: 8 }}>
                  <div style={{ fontFamily: T.mono, fontSize: "0.62rem", color: T.text3, marginBottom: 2 }}>X â†’ Y</div>
                  <div style={{ display: "flex", alignItems: "center", gap: 6 }}>
                    <ProgressBar value={Math.abs(results.linXY.reduction)} color={results.linXY.reduction > 0.05 ? T.green : T.text3} thick />
                    <span style={{ ...statS, color: results.linXY.reduction > 0.05 ? T.green : T.text3, fontWeight: 700, minWidth: 50 }}>
                      {(results.linXY.reduction * 100).toFixed(1)}%
                    </span>
                  </div>
                  <div style={{ fontFamily: T.mono, fontSize: "0.55rem", color: T.text3 }}>F={results.linXY.fStat.toFixed(2)}</div>
                </div>
                <div>
                  <div style={{ fontFamily: T.mono, fontSize: "0.62rem", color: T.text3, marginBottom: 2 }}>Y â†’ X</div>
                  <div style={{ display: "flex", alignItems: "center", gap: 6 }}>
                    <ProgressBar value={Math.abs(results.linYX.reduction)} color={results.linYX.reduction > 0.05 ? T.green : T.text3} thick />
                    <span style={{ ...statS, color: results.linYX.reduction > 0.05 ? T.green : T.text3, fontWeight: 700, minWidth: 50 }}>
                      {(results.linYX.reduction * 100).toFixed(1)}%
                    </span>
                  </div>
                  <div style={{ fontFamily: T.mono, fontSize: "0.55rem", color: T.text3 }}>F={results.linYX.fStat.toFixed(2)}</div>
                </div>
                <div style={{ fontFamily: T.mono, fontSize: "0.55rem", color: T.blue, marginTop: 8, fontStyle: "italic" }}>
                  {"P_{H_X}(X_{t+1})"}: adding Y lags shrinks residual by {(results.linXY.reduction * 100).toFixed(1)}%
                </div>
              </div>

              {/* Kernel Granger */}
              <div style={{ background: T.bg2, border: `1px solid ${T.border0}`, borderRadius: T.rMd, padding: "10px 12px", borderLeft: `3px solid ${T.orange}` }}>
                <div style={{ ...labelS, color: T.orange }}>Kernel Granger (RKHS projection)</div>
                <div style={{ marginBottom: 8 }}>
                  <div style={{ fontFamily: T.mono, fontSize: "0.62rem", color: T.text3, marginBottom: 2 }}>X â†’ Y (kernel)</div>
                  <div style={{ display: "flex", alignItems: "center", gap: 6 }}>
                    <ProgressBar value={Math.abs(results.kXY.reduction)} color={results.kXY.reduction > 0.05 ? T.green : T.text3} thick />
                    <span style={{ ...statS, color: results.kXY.reduction > 0.05 ? T.green : T.text3, fontWeight: 700, minWidth: 50 }}>
                      {(results.kXY.reduction * 100).toFixed(1)}%
                    </span>
                  </div>
                  <div style={{ fontFamily: T.mono, fontSize: "0.55rem", color: T.text3 }}>Ïƒ={results.kXY.sigma.toFixed(2)}, n={results.kXY.n}</div>
                </div>
                <div>
                  <div style={{ fontFamily: T.mono, fontSize: "0.62rem", color: T.text3, marginBottom: 2 }}>Y â†’ X (kernel)</div>
                  <div style={{ display: "flex", alignItems: "center", gap: 6 }}>
                    <ProgressBar value={Math.abs(results.kYX.reduction)} color={results.kYX.reduction > 0.05 ? T.green : T.text3} thick />
                    <span style={{ ...statS, color: results.kYX.reduction > 0.05 ? T.green : T.text3, fontWeight: 700, minWidth: 50 }}>
                      {(results.kYX.reduction * 100).toFixed(1)}%
                    </span>
                  </div>
                </div>
                <div style={{ fontFamily: T.mono, fontSize: "0.55rem", color: T.orange, marginTop: 8, fontStyle: "italic" }}>
                  Ï†(x) âˆˆ H: lifts nonlinear f(X) into RKHS where projection detects causal links
                </div>
              </div>

              {/* HSIC */}
              <div style={{ background: T.bg2, border: `1px solid ${T.border0}`, borderRadius: T.rMd, padding: "10px 12px", borderLeft: `3px solid ${T.teal}` }}>
                <div style={{ ...labelS, color: T.teal }}>HSIC (cross-covariance operator)</div>
                <div style={{ fontFamily: T.display, fontWeight: 700, fontSize: "1.6rem", color: T.teal, lineHeight: 1 }}>
                  {results.hXY.hsic.toFixed(6)}
                </div>
                <div style={{ fontFamily: T.mono, fontSize: "0.55rem", color: T.text3, marginBottom: 6 }}>
                  n={results.hXY.n}, Ïƒ={results.hXY.sigma.toFixed(2)}
                </div>
                <div style={{ fontFamily: T.mono, fontSize: "0.62rem", color: results.hXY.hsic > 0.001 ? T.green : T.text3, marginBottom: 4 }}>
                  {results.hXY.hsic > 0.01 ? "Strong dependence detected" :
                   results.hXY.hsic > 0.001 ? "Weak dependence detected" : "Near-independent (â€–C_XYâ€– â‰ˆ 0)"}
                </div>
                <div style={{ fontFamily: T.mono, fontSize: "0.55rem", color: T.teal, fontStyle: "italic" }}>
                  â€–C_XYâ€–Â² = â€–E[Ï†(X)âŠ—Ïˆ(Y)]â€–Â² â€” measures all (including nonlinear) dependence
                </div>
              </div>
            </div>

            {/* Interpretation */}
            <div style={{ background: T.bg3, border: `1px solid ${T.border0}`, borderRadius: T.rMd, padding: "10px 12px" }}>
              <div style={labelS}>Causal Interpretation</div>
              {(() => {
                const linFwd = results.linXY.reduction > 0.05;
                const linBck = results.linYX.reduction > 0.05;
                const kerFwd = results.kXY.reduction > 0.05;
                const kerBck = results.kYX.reduction > 0.05;
                const lines = [];
                if (linFwd && kerFwd) lines.push({ color: T.green, text: `X â†’ Y: Both linear and kernel Granger detect forward causation (linear: ${(results.linXY.reduction*100).toFixed(1)}%, kernel: ${(results.kXY.reduction*100).toFixed(1)}%)` });
                else if (!linFwd && kerFwd) lines.push({ color: T.orange, text: `X â†’ Y: Only kernel Granger detects causation â€” relationship is nonlinear (RKHS lifting reveals structure invisible to LÂ² projection)` });
                else if (linFwd && !kerFwd) lines.push({ color: T.blue, text: `X â†’ Y: Linear Granger detects causation (linear relationship confirmed)` });
                else lines.push({ color: T.text3, text: `X â†’ Y: No forward causation detected (adding Y does not shrink residual)` });
                if (linBck || kerBck) lines.push({ color: T.yellow, text: `Y â†’ X: Reverse causation ${linBck && kerBck ? "(linear + kernel)" : kerBck ? "(kernel only â€” nonlinear)" : "(linear)"} â€” ${causalType === "bidirectional" ? "expected for bidirectional" : "possible confounding or feedback"}` });
                else lines.push({ color: T.text3, text: `Y â†’ X: No reverse causation (correct for ${causalType === "none" ? "independent" : "unidirectional"} case)` });
                return lines.map((l, i) => (
                  <div key={i} style={{ display: "flex", gap: 6, alignItems: "flex-start", padding: "3px 0" }}>
                    <StatusDot color={l.color} size={6} />
                    <span style={{ fontFamily: T.mono, fontSize: "0.65rem", color: T.text1 }}>{l.text}</span>
                  </div>
                ));
              })()}
            </div>
          </div>
        )}
      </Section>

      {/* Technique â†” Hilbert mapping */}
      <Section title="Technique â†’ Hilbert Mapping" count={Object.keys(HILBERT_MAPPING).length} color={T.teal} style={{ marginTop: 12 }}>
        <div style={{ fontFamily: T.mono, fontSize: "0.62rem", color: T.text3, marginBottom: 8 }}>
          Every forecasting technique secretly operates via a Hilbert space mechanism
        </div>
        <div style={{ display: "grid", gridTemplateColumns: "repeat(auto-fill, minmax(350px, 1fr))", gap: 4 }}>
          {TECHNIQUES.map(t => {
            const hm = HILBERT_MAPPING[t.id];
            if (!hm) return null;
            const hc = HILBERT_CONCEPTS.find(c => c.id === hm.concept);
            if (!hc) return null;
            return (
              <div key={t.id} style={{ display: "flex", alignItems: "flex-start", gap: 6, padding: "5px 8px",
                background: T.bg2, borderRadius: T.rSm, border: `1px solid ${T.border0}`, borderLeft: `3px solid ${hc.color}` }}>
                <span style={{ fontFamily: T.mono, fontSize: "0.65rem", color: familyColor(t.family), fontWeight: 600, minWidth: 90 }}>{t.name}</span>
                <span style={{ fontFamily: T.mono, fontSize: "0.52rem", padding: "0.1em 0.3em", borderRadius: T.rSm,
                  background: `${hc.color}15`, color: hc.color, flexShrink: 0 }}>{hc.symbol.split(" ")[0]}</span>
                <span style={{ fontFamily: T.mono, fontSize: "0.58rem", color: T.text2, flex: 1 }}>{hm.interpretation}</span>
              </div>
            );
          })}
        </div>
      </Section>
    </div>
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN APPLICATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function App() {
  const [tab, setTab] = useState("techniques");

  const tabs = [
    { key:"techniques", label:"Techniques", color:T.orange },
    { key:"composer", label:"Composer", color:T.green },
    { key:"matrix", label:"Matrix", color:T.blue },
    { key:"principles", label:"Principles", color:T.purple },
    { key:"logs", label:"Condensed Logs", color:T.teal },
    { key:"graph", label:"Graph", color:T.green },
    { key:"causal", label:"Causal", color:T.crimson },
    { key:"observatory", label:"Observatory", color:T.yellow },
  ];

  // Summary stats
  const familyCounts = {};
  TECHNIQUES.forEach(t => { familyCounts[t.family] = (familyCounts[t.family]||0)+1; });

  return (
    <div style={{ minHeight:"100vh", background:T.bg0, color:T.text1, fontFamily:T.body, fontSize:13, lineHeight:1.5 }}>
      <style>{`
        * { box-sizing:border-box; margin:0; padding:0; }
        ::-webkit-scrollbar { width:3px; height:3px; }
        ::-webkit-scrollbar-track { background:transparent; }
        ::-webkit-scrollbar-thumb { background:${T.border1}; border-radius:2px; }
        @keyframes statusPulse {
          0%, 100% { opacity:0; transform:scale(0.8); }
          50% { opacity:0.6; transform:scale(1.6); }
        }
        button:hover { opacity:0.85; }
      `}</style>

      <div style={{ padding:"24px 32px 48px", maxWidth:1200, margin:"0 auto" }}>

        {/* HEADER */}
        <header style={{ marginBottom:24 }}>
          <div style={{ fontFamily:T.display, fontWeight:700, fontSize:"1.8rem", color:T.text0, lineHeight:1.1, marginBottom:4 }}>
            Foresight Compendium
          </div>
          <div style={{ fontFamily:T.mono, fontSize:"0.55rem", textTransform:"uppercase", letterSpacing:"0.16em", color:T.text3, marginBottom:16 }}>
            Chromatic Lattice â€” Time Series Forecasting Observatory
          </div>
          <div style={{ display:"flex", gap:"0.4em", alignItems:"center", flexWrap:"wrap" }}>
            <Chip level="verified">{TECHNIQUES.length} techniques</Chip>
            <Chip level="invariant">{FAMILIES.length} families</Chip>
            <Chip level="asserted">{PRINCIPLES.length} principles</Chip>
            <Chip level="used">{OPERATORS.length} operators</Chip>
            <Chip level="inferred">{ARCHETYPES.length} archetypes</Chip>
            <Chip style={{ background:T.greenDim, color:T.green, border:`1px solid ${T.green}33` }}>{KNOWN_SYNERGIES.length} synergies</Chip>
            <Chip style={{ background:T.crimsonDim, color:T.crimson, border:`1px solid ${T.crimson}33` }}>{KNOWN_CONFLICTS.length} conflicts</Chip>
            <Chip style={{ background:T.blueDim, color:T.blue, border:`1px solid ${T.blue}33` }}>{CANONICAL_PIPELINES.length} pipelines</Chip>
          </div>
        </header>

        {/* METRIC CARDS */}
        <div style={{ display:"grid", gridTemplateColumns:"repeat(auto-fill, minmax(150px, 1fr))", gap:10, marginBottom:24 }}>
          <MetricCard label="Techniques" value={TECHNIQUES.length} delta={`${FAMILIES.length} families`} deltaDir="up" color={T.orange} />
          <MetricCard label="Synergies" value={KNOWN_SYNERGIES.length} delta="documented pairings" deltaDir="up" color={T.green} />
          <MetricCard label="Conflicts" value={KNOWN_CONFLICTS.length} delta="anti-patterns" deltaDir="down" color={T.crimson} />
          <MetricCard label="Pipelines" value={CANONICAL_PIPELINES.length} delta="canonical chains" deltaDir="up" color={T.blue} />
          <MetricCard label="Principles" value={PRINCIPLES.length} delta="composability rules" deltaDir="flat" color={T.purple} />
          <MetricCard label="Operators" value={OPERATORS.length} delta={`${OP_CATEGORIES.length} categories`} deltaDir="up" color={T.teal} />
        </div>

        {/* TAB BAR */}
        <TabBar tabs={tabs} active={tab} onChange={setTab} />

        {/* TAB CONTENT */}
        {tab === "techniques" && <TechniquesTab />}
        {tab === "composer" && <ComposerTab />}
        {tab === "matrix" && <MatrixTab />}
        {tab === "principles" && <PrinciplesTab />}
        {tab === "logs" && <CondensedLogsTab />}
        {tab === "graph" && <GraphTab />}
        {tab === "causal" && <CausalTab />}
        {tab === "observatory" && <ObservatoryTab />}

        {/* FOOTER */}
        <div style={{ marginTop:32, paddingTop:12, borderTop:`1px solid ${T.border0}`,
          display:"flex", gap:6, flexWrap:"wrap", alignItems:"center" }}>
          <span style={{ fontFamily:T.mono, fontSize:"0.55rem", textTransform:"uppercase", letterSpacing:"0.16em", color:T.text3, marginRight:6 }}>
            Epistemic Levels
          </span>
          {Object.keys(LEVEL_COLOR).map(k => <Chip key={k} level={k}>{k}</Chip>)}
        </div>

        {/* Family legend */}
        <div style={{ marginTop:8, display:"flex", gap:6, flexWrap:"wrap", alignItems:"center" }}>
          <span style={{ fontFamily:T.mono, fontSize:"0.55rem", textTransform:"uppercase", letterSpacing:"0.16em", color:T.text3, marginRight:6 }}>
            Technique Families
          </span>
          {FAMILIES.map(f => (
            <span key={f.id} style={{ display:"inline-flex", alignItems:"center", gap:4, fontFamily:T.mono, fontSize:"0.62rem", color:f.color }}>
              <span style={{ width:6, height:6, borderRadius:"50%", background:f.color }} />
              {f.name} ({familyCounts[f.id]||0})
            </span>
          ))}
        </div>
      </div>
    </div>
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RENDER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
</script>
</body>
</html>
